/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/prettier/standalone.js":
/*!*********************************************!*\
  !*** ./node_modules/prettier/standalone.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (e) {\n  if (true) module.exports = e();else { var f; }\n})(function () {\n  \"use strict\";\n\n  var xe = (e, r) => () => (r || e((r = {\n    exports: {}\n  }).exports, r), r.exports);\n  var pt = xe((r0, pu) => {\n    var ir = function (e) {\n      return e && e.Math == Math && e;\n    };\n    pu.exports = ir(typeof globalThis == \"object\" && globalThis) || ir(typeof window == \"object\" && window) || ir(typeof self == \"object\" && self) || ir(typeof __webpack_require__.g == \"object\" && __webpack_require__.g) || function () {\n      return this;\n    }() || Function(\"return this\")();\n  });\n  var Dt = xe((n0, fu) => {\n    fu.exports = function (e) {\n      try {\n        return !!e();\n      } catch {\n        return !0;\n      }\n    };\n  });\n  var yt = xe((u0, Du) => {\n    var Mo = Dt();\n    Du.exports = !Mo(function () {\n      return Object.defineProperty({}, 1, {\n        get: function () {\n          return 7;\n        }\n      })[1] != 7;\n    });\n  });\n  var ar = xe((s0, mu) => {\n    var Ro = Dt();\n    mu.exports = !Ro(function () {\n      var e = function () {}.bind();\n      return typeof e != \"function\" || e.hasOwnProperty(\"prototype\");\n    });\n  });\n  var At = xe((i0, du) => {\n    var $o = ar(),\n      or = Function.prototype.call;\n    du.exports = $o ? or.bind(or) : function () {\n      return or.apply(or, arguments);\n    };\n  });\n  var vu = xe(hu => {\n    \"use strict\";\n\n    var gu = {}.propertyIsEnumerable,\n      yu = Object.getOwnPropertyDescriptor,\n      Vo = yu && !gu.call({\n        1: 2\n      }, 1);\n    hu.f = Vo ? function (r) {\n      var t = yu(this, r);\n      return !!t && t.enumerable;\n    } : gu;\n  });\n  var lr = xe((o0, Cu) => {\n    Cu.exports = function (e, r) {\n      return {\n        enumerable: !(e & 1),\n        configurable: !(e & 2),\n        writable: !(e & 4),\n        value: r\n      };\n    };\n  });\n  var mt = xe((l0, Au) => {\n    var Eu = ar(),\n      Fu = Function.prototype,\n      Wr = Fu.call,\n      Wo = Eu && Fu.bind.bind(Wr, Wr);\n    Au.exports = Eu ? Wo : function (e) {\n      return function () {\n        return Wr.apply(e, arguments);\n      };\n    };\n  });\n  var Vt = xe((c0, xu) => {\n    var Su = mt(),\n      Ho = Su({}.toString),\n      Go = Su(\"\".slice);\n    xu.exports = function (e) {\n      return Go(Ho(e), 8, -1);\n    };\n  });\n  var Tu = xe((p0, bu) => {\n    var Uo = mt(),\n      Jo = Dt(),\n      zo = Vt(),\n      Hr = Object,\n      Xo = Uo(\"\".split);\n    bu.exports = Jo(function () {\n      return !Hr(\"z\").propertyIsEnumerable(0);\n    }) ? function (e) {\n      return zo(e) == \"String\" ? Xo(e, \"\") : Hr(e);\n    } : Hr;\n  });\n  var cr = xe((f0, Bu) => {\n    Bu.exports = function (e) {\n      return e == null;\n    };\n  });\n  var Gr = xe((D0, Nu) => {\n    var Ko = cr(),\n      Yo = TypeError;\n    Nu.exports = function (e) {\n      if (Ko(e)) throw Yo(\"Can't call method on \" + e);\n      return e;\n    };\n  });\n  var pr = xe((m0, wu) => {\n    var Qo = Tu(),\n      Zo = Gr();\n    wu.exports = function (e) {\n      return Qo(Zo(e));\n    };\n  });\n  var Jr = xe((d0, _u) => {\n    var Ur = typeof document == \"object\" && document.all,\n      el = typeof Ur > \"u\" && Ur !== void 0;\n    _u.exports = {\n      all: Ur,\n      IS_HTMLDDA: el\n    };\n  });\n  var ot = xe((g0, Iu) => {\n    var Pu = Jr(),\n      tl = Pu.all;\n    Iu.exports = Pu.IS_HTMLDDA ? function (e) {\n      return typeof e == \"function\" || e === tl;\n    } : function (e) {\n      return typeof e == \"function\";\n    };\n  });\n  var St = xe((y0, Ou) => {\n    var ku = ot(),\n      Lu = Jr(),\n      rl = Lu.all;\n    Ou.exports = Lu.IS_HTMLDDA ? function (e) {\n      return typeof e == \"object\" ? e !== null : ku(e) || e === rl;\n    } : function (e) {\n      return typeof e == \"object\" ? e !== null : ku(e);\n    };\n  });\n  var Wt = xe((h0, ju) => {\n    var zr = pt(),\n      nl = ot(),\n      ul = function (e) {\n        return nl(e) ? e : void 0;\n      };\n    ju.exports = function (e, r) {\n      return arguments.length < 2 ? ul(zr[e]) : zr[e] && zr[e][r];\n    };\n  });\n  var Xr = xe((v0, qu) => {\n    var sl = mt();\n    qu.exports = sl({}.isPrototypeOf);\n  });\n  var Ru = xe((C0, Mu) => {\n    var il = Wt();\n    Mu.exports = il(\"navigator\", \"userAgent\") || \"\";\n  });\n  var Ju = xe((E0, Uu) => {\n    var Gu = pt(),\n      Kr = Ru(),\n      $u = Gu.process,\n      Vu = Gu.Deno,\n      Wu = $u && $u.versions || Vu && Vu.version,\n      Hu = Wu && Wu.v8,\n      dt,\n      fr;\n    Hu && (dt = Hu.split(\".\"), fr = dt[0] > 0 && dt[0] < 4 ? 1 : +(dt[0] + dt[1]));\n    !fr && Kr && (dt = Kr.match(/Edge\\/(\\d+)/), (!dt || dt[1] >= 74) && (dt = Kr.match(/Chrome\\/(\\d+)/), dt && (fr = +dt[1])));\n    Uu.exports = fr;\n  });\n  var Yr = xe((F0, Xu) => {\n    var zu = Ju(),\n      al = Dt();\n    Xu.exports = !!Object.getOwnPropertySymbols && !al(function () {\n      var e = Symbol();\n      return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && zu && zu < 41;\n    });\n  });\n  var Qr = xe((A0, Ku) => {\n    var ol = Yr();\n    Ku.exports = ol && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n  });\n  var Zr = xe((S0, Yu) => {\n    var ll = Wt(),\n      cl = ot(),\n      pl = Xr(),\n      fl = Qr(),\n      Dl = Object;\n    Yu.exports = fl ? function (e) {\n      return typeof e == \"symbol\";\n    } : function (e) {\n      var r = ll(\"Symbol\");\n      return cl(r) && pl(r.prototype, Dl(e));\n    };\n  });\n  var Dr = xe((x0, Qu) => {\n    var ml = String;\n    Qu.exports = function (e) {\n      try {\n        return ml(e);\n      } catch {\n        return \"Object\";\n      }\n    };\n  });\n  var Ht = xe((b0, Zu) => {\n    var dl = ot(),\n      gl = Dr(),\n      yl = TypeError;\n    Zu.exports = function (e) {\n      if (dl(e)) return e;\n      throw yl(gl(e) + \" is not a function\");\n    };\n  });\n  var mr = xe((T0, es) => {\n    var hl = Ht(),\n      vl = cr();\n    es.exports = function (e, r) {\n      var t = e[r];\n      return vl(t) ? void 0 : hl(t);\n    };\n  });\n  var rs = xe((B0, ts) => {\n    var en = At(),\n      tn = ot(),\n      rn = St(),\n      Cl = TypeError;\n    ts.exports = function (e, r) {\n      var t, s;\n      if (r === \"string\" && tn(t = e.toString) && !rn(s = en(t, e)) || tn(t = e.valueOf) && !rn(s = en(t, e)) || r !== \"string\" && tn(t = e.toString) && !rn(s = en(t, e))) return s;\n      throw Cl(\"Can't convert object to primitive value\");\n    };\n  });\n  var us = xe((N0, ns) => {\n    ns.exports = !1;\n  });\n  var dr = xe((w0, is) => {\n    var ss = pt(),\n      El = Object.defineProperty;\n    is.exports = function (e, r) {\n      try {\n        El(ss, e, {\n          value: r,\n          configurable: !0,\n          writable: !0\n        });\n      } catch {\n        ss[e] = r;\n      }\n      return r;\n    };\n  });\n  var gr = xe((_0, os) => {\n    var Fl = pt(),\n      Al = dr(),\n      as = \"__core-js_shared__\",\n      Sl = Fl[as] || Al(as, {});\n    os.exports = Sl;\n  });\n  var nn = xe((P0, cs) => {\n    var xl = us(),\n      ls = gr();\n    (cs.exports = function (e, r) {\n      return ls[e] || (ls[e] = r !== void 0 ? r : {});\n    })(\"versions\", []).push({\n      version: \"3.26.1\",\n      mode: xl ? \"pure\" : \"global\",\n      copyright: \"\\xA9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n      license: \"https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE\",\n      source: \"https://github.com/zloirock/core-js\"\n    });\n  });\n  var yr = xe((I0, ps) => {\n    var bl = Gr(),\n      Tl = Object;\n    ps.exports = function (e) {\n      return Tl(bl(e));\n    };\n  });\n  var Ct = xe((k0, fs) => {\n    var Bl = mt(),\n      Nl = yr(),\n      wl = Bl({}.hasOwnProperty);\n    fs.exports = Object.hasOwn || function (r, t) {\n      return wl(Nl(r), t);\n    };\n  });\n  var un = xe((L0, Ds) => {\n    var _l = mt(),\n      Pl = 0,\n      Il = Math.random(),\n      kl = _l(1 .toString);\n    Ds.exports = function (e) {\n      return \"Symbol(\" + (e === void 0 ? \"\" : e) + \")_\" + kl(++Pl + Il, 36);\n    };\n  });\n  var bt = xe((O0, hs) => {\n    var Ll = pt(),\n      Ol = nn(),\n      ms = Ct(),\n      jl = un(),\n      ds = Yr(),\n      ys = Qr(),\n      It = Ol(\"wks\"),\n      xt = Ll.Symbol,\n      gs = xt && xt.for,\n      ql = ys ? xt : xt && xt.withoutSetter || jl;\n    hs.exports = function (e) {\n      if (!ms(It, e) || !(ds || typeof It[e] == \"string\")) {\n        var r = \"Symbol.\" + e;\n        ds && ms(xt, e) ? It[e] = xt[e] : ys && gs ? It[e] = gs(r) : It[e] = ql(r);\n      }\n      return It[e];\n    };\n  });\n  var Fs = xe((j0, Es) => {\n    var Ml = At(),\n      vs = St(),\n      Cs = Zr(),\n      Rl = mr(),\n      $l = rs(),\n      Vl = bt(),\n      Wl = TypeError,\n      Hl = Vl(\"toPrimitive\");\n    Es.exports = function (e, r) {\n      if (!vs(e) || Cs(e)) return e;\n      var t = Rl(e, Hl),\n        s;\n      if (t) {\n        if (r === void 0 && (r = \"default\"), s = Ml(t, e, r), !vs(s) || Cs(s)) return s;\n        throw Wl(\"Can't convert object to primitive value\");\n      }\n      return r === void 0 && (r = \"number\"), $l(e, r);\n    };\n  });\n  var hr = xe((q0, As) => {\n    var Gl = Fs(),\n      Ul = Zr();\n    As.exports = function (e) {\n      var r = Gl(e, \"string\");\n      return Ul(r) ? r : r + \"\";\n    };\n  });\n  var bs = xe((M0, xs) => {\n    var Jl = pt(),\n      Ss = St(),\n      sn = Jl.document,\n      zl = Ss(sn) && Ss(sn.createElement);\n    xs.exports = function (e) {\n      return zl ? sn.createElement(e) : {};\n    };\n  });\n  var an = xe((R0, Ts) => {\n    var Xl = yt(),\n      Kl = Dt(),\n      Yl = bs();\n    Ts.exports = !Xl && !Kl(function () {\n      return Object.defineProperty(Yl(\"div\"), \"a\", {\n        get: function () {\n          return 7;\n        }\n      }).a != 7;\n    });\n  });\n  var on = xe(Ns => {\n    var Ql = yt(),\n      Zl = At(),\n      ec = vu(),\n      tc = lr(),\n      rc = pr(),\n      nc = hr(),\n      uc = Ct(),\n      sc = an(),\n      Bs = Object.getOwnPropertyDescriptor;\n    Ns.f = Ql ? Bs : function (r, t) {\n      if (r = rc(r), t = nc(t), sc) try {\n        return Bs(r, t);\n      } catch {}\n      if (uc(r, t)) return tc(!Zl(ec.f, r, t), r[t]);\n    };\n  });\n  var _s = xe((V0, ws) => {\n    var ic = yt(),\n      ac = Dt();\n    ws.exports = ic && ac(function () {\n      return Object.defineProperty(function () {}, \"prototype\", {\n        value: 42,\n        writable: !1\n      }).prototype != 42;\n    });\n  });\n  var Tt = xe((W0, Ps) => {\n    var oc = St(),\n      lc = String,\n      cc = TypeError;\n    Ps.exports = function (e) {\n      if (oc(e)) return e;\n      throw cc(lc(e) + \" is not an object\");\n    };\n  });\n  var kt = xe(ks => {\n    var pc = yt(),\n      fc = an(),\n      Dc = _s(),\n      vr = Tt(),\n      Is = hr(),\n      mc = TypeError,\n      ln = Object.defineProperty,\n      dc = Object.getOwnPropertyDescriptor,\n      cn = \"enumerable\",\n      pn = \"configurable\",\n      fn = \"writable\";\n    ks.f = pc ? Dc ? function (r, t, s) {\n      if (vr(r), t = Is(t), vr(s), typeof r == \"function\" && t === \"prototype\" && \"value\" in s && fn in s && !s[fn]) {\n        var a = dc(r, t);\n        a && a[fn] && (r[t] = s.value, s = {\n          configurable: pn in s ? s[pn] : a[pn],\n          enumerable: cn in s ? s[cn] : a[cn],\n          writable: !1\n        });\n      }\n      return ln(r, t, s);\n    } : ln : function (r, t, s) {\n      if (vr(r), t = Is(t), vr(s), fc) try {\n        return ln(r, t, s);\n      } catch {}\n      if (\"get\" in s || \"set\" in s) throw mc(\"Accessors not supported\");\n      return \"value\" in s && (r[t] = s.value), r;\n    };\n  });\n  var Dn = xe((G0, Ls) => {\n    var gc = yt(),\n      yc = kt(),\n      hc = lr();\n    Ls.exports = gc ? function (e, r, t) {\n      return yc.f(e, r, hc(1, t));\n    } : function (e, r, t) {\n      return e[r] = t, e;\n    };\n  });\n  var qs = xe((U0, js) => {\n    var mn = yt(),\n      vc = Ct(),\n      Os = Function.prototype,\n      Cc = mn && Object.getOwnPropertyDescriptor,\n      dn = vc(Os, \"name\"),\n      Ec = dn && function () {}.name === \"something\",\n      Fc = dn && (!mn || mn && Cc(Os, \"name\").configurable);\n    js.exports = {\n      EXISTS: dn,\n      PROPER: Ec,\n      CONFIGURABLE: Fc\n    };\n  });\n  var yn = xe((J0, Ms) => {\n    var Ac = mt(),\n      Sc = ot(),\n      gn = gr(),\n      xc = Ac(Function.toString);\n    Sc(gn.inspectSource) || (gn.inspectSource = function (e) {\n      return xc(e);\n    });\n    Ms.exports = gn.inspectSource;\n  });\n  var Vs = xe((z0, $s) => {\n    var bc = pt(),\n      Tc = ot(),\n      Rs = bc.WeakMap;\n    $s.exports = Tc(Rs) && /native code/.test(String(Rs));\n  });\n  var Gs = xe((X0, Hs) => {\n    var Bc = nn(),\n      Nc = un(),\n      Ws = Bc(\"keys\");\n    Hs.exports = function (e) {\n      return Ws[e] || (Ws[e] = Nc(e));\n    };\n  });\n  var hn = xe((K0, Us) => {\n    Us.exports = {};\n  });\n  var Ks = xe((Y0, Xs) => {\n    var wc = Vs(),\n      zs = pt(),\n      _c = St(),\n      Pc = Dn(),\n      vn = Ct(),\n      Cn = gr(),\n      Ic = Gs(),\n      kc = hn(),\n      Js = \"Object already initialized\",\n      En = zs.TypeError,\n      Lc = zs.WeakMap,\n      Cr,\n      Gt,\n      Er,\n      Oc = function (e) {\n        return Er(e) ? Gt(e) : Cr(e, {});\n      },\n      jc = function (e) {\n        return function (r) {\n          var t;\n          if (!_c(r) || (t = Gt(r)).type !== e) throw En(\"Incompatible receiver, \" + e + \" required\");\n          return t;\n        };\n      };\n    wc || Cn.state ? (gt = Cn.state || (Cn.state = new Lc()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, Cr = function (e, r) {\n      if (gt.has(e)) throw En(Js);\n      return r.facade = e, gt.set(e, r), r;\n    }, Gt = function (e) {\n      return gt.get(e) || {};\n    }, Er = function (e) {\n      return gt.has(e);\n    }) : (Bt = Ic(\"state\"), kc[Bt] = !0, Cr = function (e, r) {\n      if (vn(e, Bt)) throw En(Js);\n      return r.facade = e, Pc(e, Bt, r), r;\n    }, Gt = function (e) {\n      return vn(e, Bt) ? e[Bt] : {};\n    }, Er = function (e) {\n      return vn(e, Bt);\n    });\n    var gt, Bt;\n    Xs.exports = {\n      set: Cr,\n      get: Gt,\n      has: Er,\n      enforce: Oc,\n      getterFor: jc\n    };\n  });\n  var An = xe((Q0, Qs) => {\n    var qc = Dt(),\n      Mc = ot(),\n      Fr = Ct(),\n      Fn = yt(),\n      Rc = qs().CONFIGURABLE,\n      $c = yn(),\n      Ys = Ks(),\n      Vc = Ys.enforce,\n      Wc = Ys.get,\n      Ar = Object.defineProperty,\n      Hc = Fn && !qc(function () {\n        return Ar(function () {}, \"length\", {\n          value: 8\n        }).length !== 8;\n      }),\n      Gc = String(String).split(\"String\"),\n      Uc = Qs.exports = function (e, r, t) {\n        String(r).slice(0, 7) === \"Symbol(\" && (r = \"[\" + String(r).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\"), t && t.getter && (r = \"get \" + r), t && t.setter && (r = \"set \" + r), (!Fr(e, \"name\") || Rc && e.name !== r) && (Fn ? Ar(e, \"name\", {\n          value: r,\n          configurable: !0\n        }) : e.name = r), Hc && t && Fr(t, \"arity\") && e.length !== t.arity && Ar(e, \"length\", {\n          value: t.arity\n        });\n        try {\n          t && Fr(t, \"constructor\") && t.constructor ? Fn && Ar(e, \"prototype\", {\n            writable: !1\n          }) : e.prototype && (e.prototype = void 0);\n        } catch {}\n        var s = Vc(e);\n        return Fr(s, \"source\") || (s.source = Gc.join(typeof r == \"string\" ? r : \"\")), e;\n      };\n    Function.prototype.toString = Uc(function () {\n      return Mc(this) && Wc(this).source || $c(this);\n    }, \"toString\");\n  });\n  var ei = xe((Z0, Zs) => {\n    var Jc = ot(),\n      zc = kt(),\n      Xc = An(),\n      Kc = dr();\n    Zs.exports = function (e, r, t, s) {\n      s || (s = {});\n      var a = s.enumerable,\n        n = s.name !== void 0 ? s.name : r;\n      if (Jc(t) && Xc(t, n, s), s.global) a ? e[r] = t : Kc(r, t);else {\n        try {\n          s.unsafe ? e[r] && (a = !0) : delete e[r];\n        } catch {}\n        a ? e[r] = t : zc.f(e, r, {\n          value: t,\n          enumerable: !1,\n          configurable: !s.nonConfigurable,\n          writable: !s.nonWritable\n        });\n      }\n      return e;\n    };\n  });\n  var ri = xe((ey, ti) => {\n    var Yc = Math.ceil,\n      Qc = Math.floor;\n    ti.exports = Math.trunc || function (r) {\n      var t = +r;\n      return (t > 0 ? Qc : Yc)(t);\n    };\n  });\n  var Sr = xe((ty, ni) => {\n    var Zc = ri();\n    ni.exports = function (e) {\n      var r = +e;\n      return r !== r || r === 0 ? 0 : Zc(r);\n    };\n  });\n  var si = xe((ry, ui) => {\n    var ep = Sr(),\n      tp = Math.max,\n      rp = Math.min;\n    ui.exports = function (e, r) {\n      var t = ep(e);\n      return t < 0 ? tp(t + r, 0) : rp(t, r);\n    };\n  });\n  var ai = xe((ny, ii) => {\n    var np = Sr(),\n      up = Math.min;\n    ii.exports = function (e) {\n      return e > 0 ? up(np(e), 9007199254740991) : 0;\n    };\n  });\n  var Lt = xe((uy, oi) => {\n    var sp = ai();\n    oi.exports = function (e) {\n      return sp(e.length);\n    };\n  });\n  var pi = xe((sy, ci) => {\n    var ip = pr(),\n      ap = si(),\n      op = Lt(),\n      li = function (e) {\n        return function (r, t, s) {\n          var a = ip(r),\n            n = op(a),\n            u = ap(s, n),\n            i;\n          if (e && t != t) {\n            for (; n > u;) if (i = a[u++], i != i) return !0;\n          } else for (; n > u; u++) if ((e || u in a) && a[u] === t) return e || u || 0;\n          return !e && -1;\n        };\n      };\n    ci.exports = {\n      includes: li(!0),\n      indexOf: li(!1)\n    };\n  });\n  var mi = xe((iy, Di) => {\n    var lp = mt(),\n      Sn = Ct(),\n      cp = pr(),\n      pp = pi().indexOf,\n      fp = hn(),\n      fi = lp([].push);\n    Di.exports = function (e, r) {\n      var t = cp(e),\n        s = 0,\n        a = [],\n        n;\n      for (n in t) !Sn(fp, n) && Sn(t, n) && fi(a, n);\n      for (; r.length > s;) Sn(t, n = r[s++]) && (~pp(a, n) || fi(a, n));\n      return a;\n    };\n  });\n  var gi = xe((ay, di) => {\n    di.exports = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\n  });\n  var hi = xe(yi => {\n    var Dp = mi(),\n      mp = gi(),\n      dp = mp.concat(\"length\", \"prototype\");\n    yi.f = Object.getOwnPropertyNames || function (r) {\n      return Dp(r, dp);\n    };\n  });\n  var Ci = xe(vi => {\n    vi.f = Object.getOwnPropertySymbols;\n  });\n  var Fi = xe((cy, Ei) => {\n    var gp = Wt(),\n      yp = mt(),\n      hp = hi(),\n      vp = Ci(),\n      Cp = Tt(),\n      Ep = yp([].concat);\n    Ei.exports = gp(\"Reflect\", \"ownKeys\") || function (r) {\n      var t = hp.f(Cp(r)),\n        s = vp.f;\n      return s ? Ep(t, s(r)) : t;\n    };\n  });\n  var xi = xe((py, Si) => {\n    var Ai = Ct(),\n      Fp = Fi(),\n      Ap = on(),\n      Sp = kt();\n    Si.exports = function (e, r, t) {\n      for (var s = Fp(r), a = Sp.f, n = Ap.f, u = 0; u < s.length; u++) {\n        var i = s[u];\n        !Ai(e, i) && !(t && Ai(t, i)) && a(e, i, n(r, i));\n      }\n    };\n  });\n  var Ti = xe((fy, bi) => {\n    var xp = Dt(),\n      bp = ot(),\n      Tp = /#|\\.prototype\\./,\n      Ut = function (e, r) {\n        var t = Np[Bp(e)];\n        return t == _p ? !0 : t == wp ? !1 : bp(r) ? xp(r) : !!r;\n      },\n      Bp = Ut.normalize = function (e) {\n        return String(e).replace(Tp, \".\").toLowerCase();\n      },\n      Np = Ut.data = {},\n      wp = Ut.NATIVE = \"N\",\n      _p = Ut.POLYFILL = \"P\";\n    bi.exports = Ut;\n  });\n  var Jt = xe((Dy, Bi) => {\n    var xn = pt(),\n      Pp = on().f,\n      Ip = Dn(),\n      kp = ei(),\n      Lp = dr(),\n      Op = xi(),\n      jp = Ti();\n    Bi.exports = function (e, r) {\n      var t = e.target,\n        s = e.global,\n        a = e.stat,\n        n,\n        u,\n        i,\n        l,\n        p,\n        y;\n      if (s ? u = xn : a ? u = xn[t] || Lp(t, {}) : u = (xn[t] || {}).prototype, u) for (i in r) {\n        if (p = r[i], e.dontCallGetSet ? (y = Pp(u, i), l = y && y.value) : l = u[i], n = jp(s ? i : t + (a ? \".\" : \"#\") + i, e.forced), !n && l !== void 0) {\n          if (typeof p == typeof l) continue;\n          Op(p, l);\n        }\n        (e.sham || l && l.sham) && Ip(p, \"sham\", !0), kp(u, i, p, e);\n      }\n    };\n  });\n  var bn = xe((my, Ni) => {\n    var qp = Vt();\n    Ni.exports = Array.isArray || function (r) {\n      return qp(r) == \"Array\";\n    };\n  });\n  var _i = xe((dy, wi) => {\n    var Mp = TypeError,\n      Rp = 9007199254740991;\n    wi.exports = function (e) {\n      if (e > Rp) throw Mp(\"Maximum allowed index exceeded\");\n      return e;\n    };\n  });\n  var Ii = xe((gy, Pi) => {\n    var $p = Vt(),\n      Vp = mt();\n    Pi.exports = function (e) {\n      if ($p(e) === \"Function\") return Vp(e);\n    };\n  });\n  var Tn = xe((yy, Li) => {\n    var ki = Ii(),\n      Wp = Ht(),\n      Hp = ar(),\n      Gp = ki(ki.bind);\n    Li.exports = function (e, r) {\n      return Wp(e), r === void 0 ? e : Hp ? Gp(e, r) : function () {\n        return e.apply(r, arguments);\n      };\n    };\n  });\n  var Bn = xe((hy, ji) => {\n    \"use strict\";\n\n    var Up = bn(),\n      Jp = Lt(),\n      zp = _i(),\n      Xp = Tn(),\n      Oi = function (e, r, t, s, a, n, u, i) {\n        for (var l = a, p = 0, y = u ? Xp(u, i) : !1, h, g; p < s;) p in t && (h = y ? y(t[p], p, r) : t[p], n > 0 && Up(h) ? (g = Jp(h), l = Oi(e, r, h, g, l, n - 1) - 1) : (zp(l + 1), e[l] = h), l++), p++;\n        return l;\n      };\n    ji.exports = Oi;\n  });\n  var Ri = xe((vy, Mi) => {\n    var Kp = bt(),\n      Yp = Kp(\"toStringTag\"),\n      qi = {};\n    qi[Yp] = \"z\";\n    Mi.exports = String(qi) === \"[object z]\";\n  });\n  var Nn = xe((Cy, $i) => {\n    var Qp = Ri(),\n      Zp = ot(),\n      xr = Vt(),\n      ef = bt(),\n      tf = ef(\"toStringTag\"),\n      rf = Object,\n      nf = xr(function () {\n        return arguments;\n      }()) == \"Arguments\",\n      uf = function (e, r) {\n        try {\n          return e[r];\n        } catch {}\n      };\n    $i.exports = Qp ? xr : function (e) {\n      var r, t, s;\n      return e === void 0 ? \"Undefined\" : e === null ? \"Null\" : typeof (t = uf(r = rf(e), tf)) == \"string\" ? t : nf ? xr(r) : (s = xr(r)) == \"Object\" && Zp(r.callee) ? \"Arguments\" : s;\n    };\n  });\n  var Ji = xe((Ey, Ui) => {\n    var sf = mt(),\n      af = Dt(),\n      Vi = ot(),\n      of = Nn(),\n      lf = Wt(),\n      cf = yn(),\n      Wi = function () {},\n      pf = [],\n      Hi = lf(\"Reflect\", \"construct\"),\n      wn = /^\\s*(?:class|function)\\b/,\n      ff = sf(wn.exec),\n      Df = !wn.exec(Wi),\n      zt = function (r) {\n        if (!Vi(r)) return !1;\n        try {\n          return Hi(Wi, pf, r), !0;\n        } catch {\n          return !1;\n        }\n      },\n      Gi = function (r) {\n        if (!Vi(r)) return !1;\n        switch (of(r)) {\n          case \"AsyncFunction\":\n          case \"GeneratorFunction\":\n          case \"AsyncGeneratorFunction\":\n            return !1;\n        }\n        try {\n          return Df || !!ff(wn, cf(r));\n        } catch {\n          return !0;\n        }\n      };\n    Gi.sham = !0;\n    Ui.exports = !Hi || af(function () {\n      var e;\n      return zt(zt.call) || !zt(Object) || !zt(function () {\n        e = !0;\n      }) || e;\n    }) ? Gi : zt;\n  });\n  var Yi = xe((Fy, Ki) => {\n    var zi = bn(),\n      mf = Ji(),\n      df = St(),\n      gf = bt(),\n      yf = gf(\"species\"),\n      Xi = Array;\n    Ki.exports = function (e) {\n      var r;\n      return zi(e) && (r = e.constructor, mf(r) && (r === Xi || zi(r.prototype)) ? r = void 0 : df(r) && (r = r[yf], r === null && (r = void 0))), r === void 0 ? Xi : r;\n    };\n  });\n  var _n = xe((Ay, Qi) => {\n    var hf = Yi();\n    Qi.exports = function (e, r) {\n      return new (hf(e))(r === 0 ? 0 : r);\n    };\n  });\n  var Zi = xe(() => {\n    \"use strict\";\n\n    var vf = Jt(),\n      Cf = Bn(),\n      Ef = Ht(),\n      Ff = yr(),\n      Af = Lt(),\n      Sf = _n();\n    vf({\n      target: \"Array\",\n      proto: !0\n    }, {\n      flatMap: function (r) {\n        var t = Ff(this),\n          s = Af(t),\n          a;\n        return Ef(r), a = Sf(t, 0), a.length = Cf(a, t, t, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a;\n      }\n    });\n  });\n  var Pn = xe((by, ea) => {\n    ea.exports = {};\n  });\n  var ra = xe((Ty, ta) => {\n    var xf = bt(),\n      bf = Pn(),\n      Tf = xf(\"iterator\"),\n      Bf = Array.prototype;\n    ta.exports = function (e) {\n      return e !== void 0 && (bf.Array === e || Bf[Tf] === e);\n    };\n  });\n  var In = xe((By, ua) => {\n    var Nf = Nn(),\n      na = mr(),\n      wf = cr(),\n      _f = Pn(),\n      Pf = bt(),\n      If = Pf(\"iterator\");\n    ua.exports = function (e) {\n      if (!wf(e)) return na(e, If) || na(e, \"@@iterator\") || _f[Nf(e)];\n    };\n  });\n  var ia = xe((Ny, sa) => {\n    var kf = At(),\n      Lf = Ht(),\n      Of = Tt(),\n      jf = Dr(),\n      qf = In(),\n      Mf = TypeError;\n    sa.exports = function (e, r) {\n      var t = arguments.length < 2 ? qf(e) : r;\n      if (Lf(t)) return Of(kf(t, e));\n      throw Mf(jf(e) + \" is not iterable\");\n    };\n  });\n  var la = xe((wy, oa) => {\n    var Rf = At(),\n      aa = Tt(),\n      $f = mr();\n    oa.exports = function (e, r, t) {\n      var s, a;\n      aa(e);\n      try {\n        if (s = $f(e, \"return\"), !s) {\n          if (r === \"throw\") throw t;\n          return t;\n        }\n        s = Rf(s, e);\n      } catch (n) {\n        a = !0, s = n;\n      }\n      if (r === \"throw\") throw t;\n      if (a) throw s;\n      return aa(s), t;\n    };\n  });\n  var ma = xe((_y, Da) => {\n    var Vf = Tn(),\n      Wf = At(),\n      Hf = Tt(),\n      Gf = Dr(),\n      Uf = ra(),\n      Jf = Lt(),\n      ca = Xr(),\n      zf = ia(),\n      Xf = In(),\n      pa = la(),\n      Kf = TypeError,\n      br = function (e, r) {\n        this.stopped = e, this.result = r;\n      },\n      fa = br.prototype;\n    Da.exports = function (e, r, t) {\n      var s = t && t.that,\n        a = !!(t && t.AS_ENTRIES),\n        n = !!(t && t.IS_RECORD),\n        u = !!(t && t.IS_ITERATOR),\n        i = !!(t && t.INTERRUPTED),\n        l = Vf(r, s),\n        p,\n        y,\n        h,\n        g,\n        c,\n        f,\n        F,\n        _ = function (E) {\n          return p && pa(p, \"normal\", E), new br(!0, E);\n        },\n        w = function (E) {\n          return a ? (Hf(E), i ? l(E[0], E[1], _) : l(E[0], E[1])) : i ? l(E, _) : l(E);\n        };\n      if (n) p = e.iterator;else if (u) p = e;else {\n        if (y = Xf(e), !y) throw Kf(Gf(e) + \" is not iterable\");\n        if (Uf(y)) {\n          for (h = 0, g = Jf(e); g > h; h++) if (c = w(e[h]), c && ca(fa, c)) return c;\n          return new br(!1);\n        }\n        p = zf(e, y);\n      }\n      for (f = n ? e.next : p.next; !(F = Wf(f, p)).done;) {\n        try {\n          c = w(F.value);\n        } catch (E) {\n          pa(p, \"throw\", E);\n        }\n        if (typeof c == \"object\" && c && ca(fa, c)) return c;\n      }\n      return new br(!1);\n    };\n  });\n  var ga = xe((Py, da) => {\n    \"use strict\";\n\n    var Yf = hr(),\n      Qf = kt(),\n      Zf = lr();\n    da.exports = function (e, r, t) {\n      var s = Yf(r);\n      s in e ? Qf.f(e, s, Zf(0, t)) : e[s] = t;\n    };\n  });\n  var ya = xe(() => {\n    var eD = Jt(),\n      tD = ma(),\n      rD = ga();\n    eD({\n      target: \"Object\",\n      stat: !0\n    }, {\n      fromEntries: function (r) {\n        var t = {};\n        return tD(r, function (s, a) {\n          rD(t, s, a);\n        }, {\n          AS_ENTRIES: !0\n        }), t;\n      }\n    });\n  });\n  var Ca = xe((Ly, va) => {\n    var ha = An(),\n      nD = kt();\n    va.exports = function (e, r, t) {\n      return t.get && ha(t.get, r, {\n        getter: !0\n      }), t.set && ha(t.set, r, {\n        setter: !0\n      }), nD.f(e, r, t);\n    };\n  });\n  var Fa = xe((Oy, Ea) => {\n    \"use strict\";\n\n    var uD = Tt();\n    Ea.exports = function () {\n      var e = uD(this),\n        r = \"\";\n      return e.hasIndices && (r += \"d\"), e.global && (r += \"g\"), e.ignoreCase && (r += \"i\"), e.multiline && (r += \"m\"), e.dotAll && (r += \"s\"), e.unicode && (r += \"u\"), e.unicodeSets && (r += \"v\"), e.sticky && (r += \"y\"), r;\n    };\n  });\n  var xa = xe(() => {\n    var sD = pt(),\n      iD = yt(),\n      aD = Ca(),\n      oD = Fa(),\n      lD = Dt(),\n      Aa = sD.RegExp,\n      Sa = Aa.prototype,\n      cD = iD && lD(function () {\n        var e = !0;\n        try {\n          Aa(\".\", \"d\");\n        } catch {\n          e = !1;\n        }\n        var r = {},\n          t = \"\",\n          s = e ? \"dgimsy\" : \"gimsy\",\n          a = function (l, p) {\n            Object.defineProperty(r, l, {\n              get: function () {\n                return t += p, !0;\n              }\n            });\n          },\n          n = {\n            dotAll: \"s\",\n            global: \"g\",\n            ignoreCase: \"i\",\n            multiline: \"m\",\n            sticky: \"y\"\n          };\n        e && (n.hasIndices = \"d\");\n        for (var u in n) a(u, n[u]);\n        var i = Object.getOwnPropertyDescriptor(Sa, \"flags\").get.call(r);\n        return i !== s || t !== s;\n      });\n    cD && aD(Sa, \"flags\", {\n      configurable: !0,\n      get: oD\n    });\n  });\n  var ba = xe(() => {\n    var pD = Jt(),\n      kn = pt();\n    pD({\n      global: !0,\n      forced: kn.globalThis !== kn\n    }, {\n      globalThis: kn\n    });\n  });\n  var Ta = xe(() => {\n    ba();\n  });\n  var Ba = xe(() => {\n    \"use strict\";\n\n    var fD = Jt(),\n      DD = Bn(),\n      mD = yr(),\n      dD = Lt(),\n      gD = Sr(),\n      yD = _n();\n    fD({\n      target: \"Array\",\n      proto: !0\n    }, {\n      flat: function () {\n        var r = arguments.length ? arguments[0] : void 0,\n          t = mD(this),\n          s = dD(t),\n          a = yD(t, 0);\n        return a.length = DD(a, t, t, s, 0, r === void 0 ? 1 : gD(r)), a;\n      }\n    });\n  });\n  var e0 = xe((Uy, jo) => {\n    var hD = [\"cliName\", \"cliCategory\", \"cliDescription\"],\n      vD = [\"_\"],\n      CD = [\"languageId\"];\n    function Hn(e, r) {\n      if (e == null) return {};\n      var t = ED(e, r),\n        s,\n        a;\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        for (a = 0; a < n.length; a++) s = n[a], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t[s] = e[s]);\n      }\n      return t;\n    }\n    function ED(e, r) {\n      if (e == null) return {};\n      var t = {},\n        s = Object.keys(e),\n        a,\n        n;\n      for (n = 0; n < s.length; n++) a = s[n], !(r.indexOf(a) >= 0) && (t[a] = e[a]);\n      return t;\n    }\n    Zi();\n    ya();\n    xa();\n    Ta();\n    Ba();\n    var FD = Object.create,\n      _r = Object.defineProperty,\n      AD = Object.getOwnPropertyDescriptor,\n      Gn = Object.getOwnPropertyNames,\n      SD = Object.getPrototypeOf,\n      xD = Object.prototype.hasOwnProperty,\n      ht = (e, r) => function () {\n        return e && (r = (0, e[Gn(e)[0]])(e = 0)), r;\n      },\n      te = (e, r) => function () {\n        return r || (0, e[Gn(e)[0]])((r = {\n          exports: {}\n        }).exports, r), r.exports;\n      },\n      Kt = (e, r) => {\n        for (var t in r) _r(e, t, {\n          get: r[t],\n          enumerable: !0\n        });\n      },\n      Pa = (e, r, t, s) => {\n        if (r && typeof r == \"object\" || typeof r == \"function\") for (let a of Gn(r)) !xD.call(e, a) && a !== t && _r(e, a, {\n          get: () => r[a],\n          enumerable: !(s = AD(r, a)) || s.enumerable\n        });\n        return e;\n      },\n      bD = (e, r, t) => (t = e != null ? FD(SD(e)) : {}, Pa(r || !e || !e.__esModule ? _r(t, \"default\", {\n        value: e,\n        enumerable: !0\n      }) : t, e)),\n      ft = e => Pa(_r({}, \"__esModule\", {\n        value: !0\n      }), e),\n      wt,\n      ne = ht({\n        \"<define:process>\"() {\n          wt = {\n            env: {},\n            argv: []\n          };\n        }\n      }),\n      Ia = te({\n        \"package.json\"(e, r) {\n          r.exports = {\n            version: \"2.8.8\"\n          };\n        }\n      }),\n      TD = te({\n        \"node_modules/diff/lib/diff/base.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.default = r;\n          function r() {}\n          r.prototype = {\n            diff: function (n, u) {\n              var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n                l = i.callback;\n              typeof i == \"function\" && (l = i, i = {}), this.options = i;\n              var p = this;\n              function y(N) {\n                return l ? (setTimeout(function () {\n                  l(void 0, N);\n                }, 0), !0) : N;\n              }\n              n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));\n              var h = u.length,\n                g = n.length,\n                c = 1,\n                f = h + g,\n                F = [{\n                  newPos: -1,\n                  components: []\n                }],\n                _ = this.extractCommon(F[0], u, n, 0);\n              if (F[0].newPos + 1 >= h && _ + 1 >= g) return y([{\n                value: this.join(u),\n                count: u.length\n              }]);\n              function w() {\n                for (var N = -1 * c; N <= c; N += 2) {\n                  var x = void 0,\n                    I = F[N - 1],\n                    P = F[N + 1],\n                    $ = (P ? P.newPos : 0) - N;\n                  I && (F[N - 1] = void 0);\n                  var D = I && I.newPos + 1 < h,\n                    T = P && 0 <= $ && $ < g;\n                  if (!D && !T) {\n                    F[N] = void 0;\n                    continue;\n                  }\n                  if (!D || T && I.newPos < P.newPos ? (x = s(P), p.pushComponent(x.components, void 0, !0)) : (x = I, x.newPos++, p.pushComponent(x.components, !0, void 0)), $ = p.extractCommon(x, u, n, N), x.newPos + 1 >= h && $ + 1 >= g) return y(t(p, x.components, u, n, p.useLongestToken));\n                  F[N] = x;\n                }\n                c++;\n              }\n              if (l) (function N() {\n                setTimeout(function () {\n                  if (c > f) return l();\n                  w() || N();\n                }, 0);\n              })();else for (; c <= f;) {\n                var E = w();\n                if (E) return E;\n              }\n            },\n            pushComponent: function (n, u, i) {\n              var l = n[n.length - 1];\n              l && l.added === u && l.removed === i ? n[n.length - 1] = {\n                count: l.count + 1,\n                added: u,\n                removed: i\n              } : n.push({\n                count: 1,\n                added: u,\n                removed: i\n              });\n            },\n            extractCommon: function (n, u, i, l) {\n              for (var p = u.length, y = i.length, h = n.newPos, g = h - l, c = 0; h + 1 < p && g + 1 < y && this.equals(u[h + 1], i[g + 1]);) h++, g++, c++;\n              return c && n.components.push({\n                count: c\n              }), n.newPos = h, g;\n            },\n            equals: function (n, u) {\n              return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();\n            },\n            removeEmpty: function (n) {\n              for (var u = [], i = 0; i < n.length; i++) n[i] && u.push(n[i]);\n              return u;\n            },\n            castInput: function (n) {\n              return n;\n            },\n            tokenize: function (n) {\n              return n.split(\"\");\n            },\n            join: function (n) {\n              return n.join(\"\");\n            }\n          };\n          function t(a, n, u, i, l) {\n            for (var p = 0, y = n.length, h = 0, g = 0; p < y; p++) {\n              var c = n[p];\n              if (c.removed) {\n                if (c.value = a.join(i.slice(g, g + c.count)), g += c.count, p && n[p - 1].added) {\n                  var F = n[p - 1];\n                  n[p - 1] = n[p], n[p] = F;\n                }\n              } else {\n                if (!c.added && l) {\n                  var f = u.slice(h, h + c.count);\n                  f = f.map(function (w, E) {\n                    var N = i[g + E];\n                    return N.length > w.length ? N : w;\n                  }), c.value = a.join(f);\n                } else c.value = a.join(u.slice(h, h + c.count));\n                h += c.count, c.added || (g += c.count);\n              }\n            }\n            var _ = n[y - 1];\n            return y > 1 && typeof _.value == \"string\" && (_.added || _.removed) && a.equals(\"\", _.value) && (n[y - 2].value += _.value, n.pop()), n;\n          }\n          function s(a) {\n            return {\n              newPos: a.newPos,\n              components: a.components.slice(0)\n            };\n          }\n        }\n      }),\n      BD = te({\n        \"node_modules/diff/lib/diff/array.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.diffArrays = a, e.arrayDiff = void 0;\n          var r = t(TD());\n          function t(n) {\n            return n && n.__esModule ? n : {\n              default: n\n            };\n          }\n          var s = new r.default();\n          e.arrayDiff = s, s.tokenize = function (n) {\n            return n.slice();\n          }, s.join = s.removeEmpty = function (n) {\n            return n;\n          };\n          function a(n, u, i) {\n            return s.diff(n, u, i);\n          }\n        }\n      }),\n      Un = te({\n        \"src/document/doc-builders.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(C) {\n            return {\n              type: \"concat\",\n              parts: C\n            };\n          }\n          function s(C) {\n            return {\n              type: \"indent\",\n              contents: C\n            };\n          }\n          function a(C, o) {\n            return {\n              type: \"align\",\n              contents: o,\n              n: C\n            };\n          }\n          function n(C) {\n            let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            return {\n              type: \"group\",\n              id: o.id,\n              contents: C,\n              break: Boolean(o.shouldBreak),\n              expandedStates: o.expandedStates\n            };\n          }\n          function u(C) {\n            return a(Number.NEGATIVE_INFINITY, C);\n          }\n          function i(C) {\n            return a({\n              type: \"root\"\n            }, C);\n          }\n          function l(C) {\n            return a(-1, C);\n          }\n          function p(C, o) {\n            return n(C[0], Object.assign(Object.assign({}, o), {}, {\n              expandedStates: C\n            }));\n          }\n          function y(C) {\n            return {\n              type: \"fill\",\n              parts: C\n            };\n          }\n          function h(C, o) {\n            let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            return {\n              type: \"if-break\",\n              breakContents: C,\n              flatContents: o,\n              groupId: d.groupId\n            };\n          }\n          function g(C, o) {\n            return {\n              type: \"indent-if-break\",\n              contents: C,\n              groupId: o.groupId,\n              negate: o.negate\n            };\n          }\n          function c(C) {\n            return {\n              type: \"line-suffix\",\n              contents: C\n            };\n          }\n          var f = {\n              type: \"line-suffix-boundary\"\n            },\n            F = {\n              type: \"break-parent\"\n            },\n            _ = {\n              type: \"trim\"\n            },\n            w = {\n              type: \"line\",\n              hard: !0\n            },\n            E = {\n              type: \"line\",\n              hard: !0,\n              literal: !0\n            },\n            N = {\n              type: \"line\"\n            },\n            x = {\n              type: \"line\",\n              soft: !0\n            },\n            I = t([w, F]),\n            P = t([E, F]),\n            $ = {\n              type: \"cursor\",\n              placeholder: Symbol(\"cursor\")\n            };\n          function D(C, o) {\n            let d = [];\n            for (let v = 0; v < o.length; v++) v !== 0 && d.push(C), d.push(o[v]);\n            return t(d);\n          }\n          function T(C, o, d) {\n            let v = C;\n            if (o > 0) {\n              for (let S = 0; S < Math.floor(o / d); ++S) v = s(v);\n              v = a(o % d, v), v = a(Number.NEGATIVE_INFINITY, v);\n            }\n            return v;\n          }\n          function m(C, o) {\n            return {\n              type: \"label\",\n              label: C,\n              contents: o\n            };\n          }\n          r.exports = {\n            concat: t,\n            join: D,\n            line: N,\n            softline: x,\n            hardline: I,\n            literalline: P,\n            group: n,\n            conditionalGroup: p,\n            fill: y,\n            lineSuffix: c,\n            lineSuffixBoundary: f,\n            cursor: $,\n            breakParent: F,\n            ifBreak: h,\n            trim: _,\n            indent: s,\n            indentIfBreak: g,\n            align: a,\n            addAlignmentToDoc: T,\n            markAsRoot: i,\n            dedentToRoot: u,\n            dedent: l,\n            hardlineWithoutBreakParent: w,\n            literallineWithoutBreakParent: E,\n            label: m\n          };\n        }\n      }),\n      Jn = te({\n        \"src/common/end-of-line.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(u) {\n            let i = u.indexOf(\"\\r\");\n            return i >= 0 ? u.charAt(i + 1) === `\n` ? \"crlf\" : \"cr\" : \"lf\";\n          }\n          function s(u) {\n            switch (u) {\n              case \"cr\":\n                return \"\\r\";\n              case \"crlf\":\n                return `\\r\n`;\n              default:\n                return `\n`;\n            }\n          }\n          function a(u, i) {\n            let l;\n            switch (i) {\n              case `\n`:\n                l = /\\n/g;\n                break;\n              case \"\\r\":\n                l = /\\r/g;\n                break;\n              case `\\r\n`:\n                l = /\\r\\n/g;\n                break;\n              default:\n                throw new Error(`Unexpected \"eol\" ${JSON.stringify(i)}.`);\n            }\n            let p = u.match(l);\n            return p ? p.length : 0;\n          }\n          function n(u) {\n            return u.replace(/\\r\\n?/g, `\n`);\n          }\n          r.exports = {\n            guessEndOfLine: t,\n            convertEndOfLineToChars: s,\n            countEndOfLineChars: a,\n            normalizeEndOfLine: n\n          };\n        }\n      }),\n      lt = te({\n        \"src/utils/get-last.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = s => s[s.length - 1];\n          r.exports = t;\n        }\n      });\n    function ND() {\n      let {\n          onlyFirst: e = !1\n        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n        r = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n      return new RegExp(r, e ? void 0 : \"g\");\n    }\n    var wD = ht({\n      \"node_modules/strip-ansi/node_modules/ansi-regex/index.js\"() {\n        ne();\n      }\n    });\n    function _D(e) {\n      if (typeof e != \"string\") throw new TypeError(`Expected a \\`string\\`, got \\`${typeof e}\\``);\n      return e.replace(ND(), \"\");\n    }\n    var PD = ht({\n      \"node_modules/strip-ansi/index.js\"() {\n        ne(), wD();\n      }\n    });\n    function ID(e) {\n      return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : !1;\n    }\n    var kD = ht({\n        \"node_modules/is-fullwidth-code-point/index.js\"() {\n          ne();\n        }\n      }),\n      LD = te({\n        \"node_modules/emoji-regex/index.js\"(e, r) {\n          \"use strict\";\n\n          ne(), r.exports = function () {\n            return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n          };\n        }\n      }),\n      ka = {};\n    Kt(ka, {\n      default: () => OD\n    });\n    function OD(e) {\n      if (typeof e != \"string\" || e.length === 0 || (e = _D(e), e.length === 0)) return 0;\n      e = e.replace((0, La.default)(), \"  \");\n      let r = 0;\n      for (let t = 0; t < e.length; t++) {\n        let s = e.codePointAt(t);\n        s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r += ID(s) ? 2 : 1);\n      }\n      return r;\n    }\n    var La,\n      jD = ht({\n        \"node_modules/string-width/index.js\"() {\n          ne(), PD(), kD(), La = bD(LD());\n        }\n      }),\n      Oa = te({\n        \"src/utils/get-string-width.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = (jD(), ft(ka)).default,\n            s = /[^\\x20-\\x7F]/;\n          function a(n) {\n            return n ? s.test(n) ? t(n) : n.length : 0;\n          }\n          r.exports = a;\n        }\n      }),\n      Yt = te({\n        \"src/document/doc-utils.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = lt(),\n            {\n              literalline: s,\n              join: a\n            } = Un(),\n            n = o => Array.isArray(o) || o && o.type === \"concat\",\n            u = o => {\n              if (Array.isArray(o)) return o;\n              if (o.type !== \"concat\" && o.type !== \"fill\") throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n              return o.parts;\n            },\n            i = {};\n          function l(o, d, v, S) {\n            let b = [o];\n            for (; b.length > 0;) {\n              let B = b.pop();\n              if (B === i) {\n                v(b.pop());\n                continue;\n              }\n              if (v && b.push(B, i), !d || d(B) !== !1) if (n(B) || B.type === \"fill\") {\n                let k = u(B);\n                for (let M = k.length, R = M - 1; R >= 0; --R) b.push(k[R]);\n              } else if (B.type === \"if-break\") B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);else if (B.type === \"group\" && B.expandedStates) {\n                if (S) for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M) b.push(B.expandedStates[M]);else b.push(B.contents);\n              } else B.contents && b.push(B.contents);\n            }\n          }\n          function p(o, d) {\n            let v = new Map();\n            return S(o);\n            function S(B) {\n              if (v.has(B)) return v.get(B);\n              let k = b(B);\n              return v.set(B, k), k;\n            }\n            function b(B) {\n              if (Array.isArray(B)) return d(B.map(S));\n              if (B.type === \"concat\" || B.type === \"fill\") {\n                let k = B.parts.map(S);\n                return d(Object.assign(Object.assign({}, B), {}, {\n                  parts: k\n                }));\n              }\n              if (B.type === \"if-break\") {\n                let k = B.breakContents && S(B.breakContents),\n                  M = B.flatContents && S(B.flatContents);\n                return d(Object.assign(Object.assign({}, B), {}, {\n                  breakContents: k,\n                  flatContents: M\n                }));\n              }\n              if (B.type === \"group\" && B.expandedStates) {\n                let k = B.expandedStates.map(S),\n                  M = k[0];\n                return d(Object.assign(Object.assign({}, B), {}, {\n                  contents: M,\n                  expandedStates: k\n                }));\n              }\n              if (B.contents) {\n                let k = S(B.contents);\n                return d(Object.assign(Object.assign({}, B), {}, {\n                  contents: k\n                }));\n              }\n              return d(B);\n            }\n          }\n          function y(o, d, v) {\n            let S = v,\n              b = !1;\n            function B(k) {\n              let M = d(k);\n              if (M !== void 0 && (b = !0, S = M), b) return !1;\n            }\n            return l(o, B), S;\n          }\n          function h(o) {\n            if (o.type === \"group\" && o.break || o.type === \"line\" && o.hard || o.type === \"break-parent\") return !0;\n          }\n          function g(o) {\n            return y(o, h, !1);\n          }\n          function c(o) {\n            if (o.length > 0) {\n              let d = t(o);\n              !d.expandedStates && !d.break && (d.break = \"propagated\");\n            }\n            return null;\n          }\n          function f(o) {\n            let d = new Set(),\n              v = [];\n            function S(B) {\n              if (B.type === \"break-parent\" && c(v), B.type === \"group\") {\n                if (v.push(B), d.has(B)) return !1;\n                d.add(B);\n              }\n            }\n            function b(B) {\n              B.type === \"group\" && v.pop().break && c(v);\n            }\n            l(o, S, b, !0);\n          }\n          function F(o) {\n            return o.type === \"line\" && !o.hard ? o.soft ? \"\" : \" \" : o.type === \"if-break\" ? o.flatContents || \"\" : o;\n          }\n          function _(o) {\n            return p(o, F);\n          }\n          var w = (o, d) => o && o.type === \"line\" && o.hard && d && d.type === \"break-parent\";\n          function E(o) {\n            if (!o) return o;\n            if (n(o) || o.type === \"fill\") {\n              let d = u(o);\n              for (; d.length > 1 && w(...d.slice(-2));) d.length -= 2;\n              if (d.length > 0) {\n                let v = E(t(d));\n                d[d.length - 1] = v;\n              }\n              return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, {\n                parts: d\n              });\n            }\n            switch (o.type) {\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"group\":\n              case \"line-suffix\":\n              case \"label\":\n                {\n                  let d = E(o.contents);\n                  return Object.assign(Object.assign({}, o), {}, {\n                    contents: d\n                  });\n                }\n              case \"if-break\":\n                {\n                  let d = E(o.breakContents),\n                    v = E(o.flatContents);\n                  return Object.assign(Object.assign({}, o), {}, {\n                    breakContents: d,\n                    flatContents: v\n                  });\n                }\n            }\n            return o;\n          }\n          function N(o) {\n            return E(I(o));\n          }\n          function x(o) {\n            switch (o.type) {\n              case \"fill\":\n                if (o.parts.every(v => v === \"\")) return \"\";\n                break;\n              case \"group\":\n                if (!o.contents && !o.id && !o.break && !o.expandedStates) return \"\";\n                if (o.contents.type === \"group\" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates) return o.contents;\n                break;\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"line-suffix\":\n                if (!o.contents) return \"\";\n                break;\n              case \"if-break\":\n                if (!o.flatContents && !o.breakContents) return \"\";\n                break;\n            }\n            if (!n(o)) return o;\n            let d = [];\n            for (let v of u(o)) {\n              if (!v) continue;\n              let [S, ...b] = n(v) ? u(v) : [v];\n              typeof S == \"string\" && typeof t(d) == \"string\" ? d[d.length - 1] += S : d.push(S), d.push(...b);\n            }\n            return d.length === 0 ? \"\" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, {\n              parts: d\n            });\n          }\n          function I(o) {\n            return p(o, d => x(d));\n          }\n          function P(o) {\n            let d = [],\n              v = o.filter(Boolean);\n            for (; v.length > 0;) {\n              let S = v.shift();\n              if (S) {\n                if (n(S)) {\n                  v.unshift(...u(S));\n                  continue;\n                }\n                if (d.length > 0 && typeof t(d) == \"string\" && typeof S == \"string\") {\n                  d[d.length - 1] += S;\n                  continue;\n                }\n                d.push(S);\n              }\n            }\n            return d;\n          }\n          function $(o) {\n            return p(o, d => Array.isArray(d) ? P(d) : d.parts ? Object.assign(Object.assign({}, d), {}, {\n              parts: P(d.parts)\n            }) : d);\n          }\n          function D(o) {\n            return p(o, d => typeof d == \"string\" && d.includes(`\n`) ? T(d) : d);\n          }\n          function T(o) {\n            let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;\n            return a(d, o.split(`\n`)).parts;\n          }\n          function m(o) {\n            if (o.type === \"line\") return !0;\n          }\n          function C(o) {\n            return y(o, m, !1);\n          }\n          r.exports = {\n            isConcat: n,\n            getDocParts: u,\n            willBreak: g,\n            traverseDoc: l,\n            findInDoc: y,\n            mapDoc: p,\n            propagateBreaks: f,\n            removeLines: _,\n            stripTrailingHardline: N,\n            normalizeParts: P,\n            normalizeDoc: $,\n            cleanDoc: I,\n            replaceTextEndOfLine: T,\n            replaceEndOfLine: D,\n            canBreak: C\n          };\n        }\n      }),\n      qD = te({\n        \"src/document/doc-printer.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              convertEndOfLineToChars: t\n            } = Jn(),\n            s = lt(),\n            a = Oa(),\n            {\n              fill: n,\n              cursor: u,\n              indent: i\n            } = Un(),\n            {\n              isConcat: l,\n              getDocParts: p\n            } = Yt(),\n            y,\n            h = 1,\n            g = 2;\n          function c() {\n            return {\n              value: \"\",\n              length: 0,\n              queue: []\n            };\n          }\n          function f(x, I) {\n            return _(x, {\n              type: \"indent\"\n            }, I);\n          }\n          function F(x, I, P) {\n            return I === Number.NEGATIVE_INFINITY ? x.root || c() : I < 0 ? _(x, {\n              type: \"dedent\"\n            }, P) : I ? I.type === \"root\" ? Object.assign(Object.assign({}, x), {}, {\n              root: x\n            }) : _(x, {\n              type: typeof I == \"string\" ? \"stringAlign\" : \"numberAlign\",\n              n: I\n            }, P) : x;\n          }\n          function _(x, I, P) {\n            let $ = I.type === \"dedent\" ? x.queue.slice(0, -1) : [...x.queue, I],\n              D = \"\",\n              T = 0,\n              m = 0,\n              C = 0;\n            for (let k of $) switch (k.type) {\n              case \"indent\":\n                v(), P.useTabs ? o(1) : d(P.tabWidth);\n                break;\n              case \"stringAlign\":\n                v(), D += k.n, T += k.n.length;\n                break;\n              case \"numberAlign\":\n                m += 1, C += k.n;\n                break;\n              default:\n                throw new Error(`Unexpected type '${k.type}'`);\n            }\n            return b(), Object.assign(Object.assign({}, x), {}, {\n              value: D,\n              length: T,\n              queue: $\n            });\n            function o(k) {\n              D += \"\t\".repeat(k), T += P.tabWidth * k;\n            }\n            function d(k) {\n              D += \" \".repeat(k), T += k;\n            }\n            function v() {\n              P.useTabs ? S() : b();\n            }\n            function S() {\n              m > 0 && o(m), B();\n            }\n            function b() {\n              C > 0 && d(C), B();\n            }\n            function B() {\n              m = 0, C = 0;\n            }\n          }\n          function w(x) {\n            if (x.length === 0) return 0;\n            let I = 0;\n            for (; x.length > 0 && typeof s(x) == \"string\" && /^[\\t ]*$/.test(s(x));) I += x.pop().length;\n            if (x.length > 0 && typeof s(x) == \"string\") {\n              let P = s(x).replace(/[\\t ]*$/, \"\");\n              I += s(x).length - P.length, x[x.length - 1] = P;\n            }\n            return I;\n          }\n          function E(x, I, P, $, D) {\n            let T = I.length,\n              m = [x],\n              C = [];\n            for (; P >= 0;) {\n              if (m.length === 0) {\n                if (T === 0) return !0;\n                m.push(I[--T]);\n                continue;\n              }\n              let {\n                mode: o,\n                doc: d\n              } = m.pop();\n              if (typeof d == \"string\") C.push(d), P -= a(d);else if (l(d) || d.type === \"fill\") {\n                let v = p(d);\n                for (let S = v.length - 1; S >= 0; S--) m.push({\n                  mode: o,\n                  doc: v[S]\n                });\n              } else switch (d.type) {\n                case \"indent\":\n                case \"align\":\n                case \"indent-if-break\":\n                case \"label\":\n                  m.push({\n                    mode: o,\n                    doc: d.contents\n                  });\n                  break;\n                case \"trim\":\n                  P += w(C);\n                  break;\n                case \"group\":\n                  {\n                    if (D && d.break) return !1;\n                    let v = d.break ? h : o,\n                      S = d.expandedStates && v === h ? s(d.expandedStates) : d.contents;\n                    m.push({\n                      mode: v,\n                      doc: S\n                    });\n                    break;\n                  }\n                case \"if-break\":\n                  {\n                    let S = (d.groupId ? y[d.groupId] || g : o) === h ? d.breakContents : d.flatContents;\n                    S && m.push({\n                      mode: o,\n                      doc: S\n                    });\n                    break;\n                  }\n                case \"line\":\n                  if (o === h || d.hard) return !0;\n                  d.soft || (C.push(\" \"), P--);\n                  break;\n                case \"line-suffix\":\n                  $ = !0;\n                  break;\n                case \"line-suffix-boundary\":\n                  if ($) return !1;\n                  break;\n              }\n            }\n            return !1;\n          }\n          function N(x, I) {\n            y = {};\n            let P = I.printWidth,\n              $ = t(I.endOfLine),\n              D = 0,\n              T = [{\n                ind: c(),\n                mode: h,\n                doc: x\n              }],\n              m = [],\n              C = !1,\n              o = [];\n            for (; T.length > 0;) {\n              let {\n                ind: v,\n                mode: S,\n                doc: b\n              } = T.pop();\n              if (typeof b == \"string\") {\n                let B = $ !== `\n` ? b.replace(/\\n/g, $) : b;\n                m.push(B), D += a(B);\n              } else if (l(b)) {\n                let B = p(b);\n                for (let k = B.length - 1; k >= 0; k--) T.push({\n                  ind: v,\n                  mode: S,\n                  doc: B[k]\n                });\n              } else switch (b.type) {\n                case \"cursor\":\n                  m.push(u.placeholder);\n                  break;\n                case \"indent\":\n                  T.push({\n                    ind: f(v, I),\n                    mode: S,\n                    doc: b.contents\n                  });\n                  break;\n                case \"align\":\n                  T.push({\n                    ind: F(v, b.n, I),\n                    mode: S,\n                    doc: b.contents\n                  });\n                  break;\n                case \"trim\":\n                  D -= w(m);\n                  break;\n                case \"group\":\n                  switch (S) {\n                    case g:\n                      if (!C) {\n                        T.push({\n                          ind: v,\n                          mode: b.break ? h : g,\n                          doc: b.contents\n                        });\n                        break;\n                      }\n                    case h:\n                      {\n                        C = !1;\n                        let B = {\n                            ind: v,\n                            mode: g,\n                            doc: b.contents\n                          },\n                          k = P - D,\n                          M = o.length > 0;\n                        if (!b.break && E(B, T, k, M)) T.push(B);else if (b.expandedStates) {\n                          let R = s(b.expandedStates);\n                          if (b.break) {\n                            T.push({\n                              ind: v,\n                              mode: h,\n                              doc: R\n                            });\n                            break;\n                          } else for (let q = 1; q < b.expandedStates.length + 1; q++) if (q >= b.expandedStates.length) {\n                            T.push({\n                              ind: v,\n                              mode: h,\n                              doc: R\n                            });\n                            break;\n                          } else {\n                            let J = b.expandedStates[q],\n                              L = {\n                                ind: v,\n                                mode: g,\n                                doc: J\n                              };\n                            if (E(L, T, k, M)) {\n                              T.push(L);\n                              break;\n                            }\n                          }\n                        } else T.push({\n                          ind: v,\n                          mode: h,\n                          doc: b.contents\n                        });\n                        break;\n                      }\n                  }\n                  b.id && (y[b.id] = s(T).mode);\n                  break;\n                case \"fill\":\n                  {\n                    let B = P - D,\n                      {\n                        parts: k\n                      } = b;\n                    if (k.length === 0) break;\n                    let [M, R] = k,\n                      q = {\n                        ind: v,\n                        mode: g,\n                        doc: M\n                      },\n                      J = {\n                        ind: v,\n                        mode: h,\n                        doc: M\n                      },\n                      L = E(q, [], B, o.length > 0, !0);\n                    if (k.length === 1) {\n                      L ? T.push(q) : T.push(J);\n                      break;\n                    }\n                    let Q = {\n                        ind: v,\n                        mode: g,\n                        doc: R\n                      },\n                      V = {\n                        ind: v,\n                        mode: h,\n                        doc: R\n                      };\n                    if (k.length === 2) {\n                      L ? T.push(Q, q) : T.push(V, J);\n                      break;\n                    }\n                    k.splice(0, 2);\n                    let j = {\n                        ind: v,\n                        mode: S,\n                        doc: n(k)\n                      },\n                      Y = k[0];\n                    E({\n                      ind: v,\n                      mode: g,\n                      doc: [M, R, Y]\n                    }, [], B, o.length > 0, !0) ? T.push(j, Q, q) : L ? T.push(j, V, q) : T.push(j, V, J);\n                    break;\n                  }\n                case \"if-break\":\n                case \"indent-if-break\":\n                  {\n                    let B = b.groupId ? y[b.groupId] : S;\n                    if (B === h) {\n                      let k = b.type === \"if-break\" ? b.breakContents : b.negate ? b.contents : i(b.contents);\n                      k && T.push({\n                        ind: v,\n                        mode: S,\n                        doc: k\n                      });\n                    }\n                    if (B === g) {\n                      let k = b.type === \"if-break\" ? b.flatContents : b.negate ? i(b.contents) : b.contents;\n                      k && T.push({\n                        ind: v,\n                        mode: S,\n                        doc: k\n                      });\n                    }\n                    break;\n                  }\n                case \"line-suffix\":\n                  o.push({\n                    ind: v,\n                    mode: S,\n                    doc: b.contents\n                  });\n                  break;\n                case \"line-suffix-boundary\":\n                  o.length > 0 && T.push({\n                    ind: v,\n                    mode: S,\n                    doc: {\n                      type: \"line\",\n                      hard: !0\n                    }\n                  });\n                  break;\n                case \"line\":\n                  switch (S) {\n                    case g:\n                      if (b.hard) C = !0;else {\n                        b.soft || (m.push(\" \"), D += 1);\n                        break;\n                      }\n                    case h:\n                      if (o.length > 0) {\n                        T.push({\n                          ind: v,\n                          mode: S,\n                          doc: b\n                        }, ...o.reverse()), o.length = 0;\n                        break;\n                      }\n                      b.literal ? v.root ? (m.push($, v.root.value), D = v.root.length) : (m.push($), D = 0) : (D -= w(m), m.push($ + v.value), D = v.length);\n                      break;\n                  }\n                  break;\n                case \"label\":\n                  T.push({\n                    ind: v,\n                    mode: S,\n                    doc: b.contents\n                  });\n                  break;\n                default:\n              }\n              T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);\n            }\n            let d = m.indexOf(u.placeholder);\n            if (d !== -1) {\n              let v = m.indexOf(u.placeholder, d + 1),\n                S = m.slice(0, d).join(\"\"),\n                b = m.slice(d + 1, v).join(\"\"),\n                B = m.slice(v + 1).join(\"\");\n              return {\n                formatted: S + b + B,\n                cursorNodeStart: S.length,\n                cursorNodeText: b\n              };\n            }\n            return {\n              formatted: m.join(\"\")\n            };\n          }\n          r.exports = {\n            printDocToString: N\n          };\n        }\n      }),\n      MD = te({\n        \"src/document/doc-debug.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            isConcat: t,\n            getDocParts: s\n          } = Yt();\n          function a(u) {\n            if (!u) return \"\";\n            if (t(u)) {\n              let i = [];\n              for (let l of s(u)) if (t(l)) i.push(...a(l).parts);else {\n                let p = a(l);\n                p !== \"\" && i.push(p);\n              }\n              return {\n                type: \"concat\",\n                parts: i\n              };\n            }\n            return u.type === \"if-break\" ? Object.assign(Object.assign({}, u), {}, {\n              breakContents: a(u.breakContents),\n              flatContents: a(u.flatContents)\n            }) : u.type === \"group\" ? Object.assign(Object.assign({}, u), {}, {\n              contents: a(u.contents),\n              expandedStates: u.expandedStates && u.expandedStates.map(a)\n            }) : u.type === \"fill\" ? {\n              type: \"fill\",\n              parts: u.parts.map(a)\n            } : u.contents ? Object.assign(Object.assign({}, u), {}, {\n              contents: a(u.contents)\n            }) : u;\n          }\n          function n(u) {\n            let i = Object.create(null),\n              l = new Set();\n            return p(a(u));\n            function p(h, g, c) {\n              if (typeof h == \"string\") return JSON.stringify(h);\n              if (t(h)) {\n                let f = s(h).map(p).filter(Boolean);\n                return f.length === 1 ? f[0] : `[${f.join(\", \")}]`;\n              }\n              if (h.type === \"line\") {\n                let f = Array.isArray(c) && c[g + 1] && c[g + 1].type === \"break-parent\";\n                return h.literal ? f ? \"literalline\" : \"literallineWithoutBreakParent\" : h.hard ? f ? \"hardline\" : \"hardlineWithoutBreakParent\" : h.soft ? \"softline\" : \"line\";\n              }\n              if (h.type === \"break-parent\") return Array.isArray(c) && c[g - 1] && c[g - 1].type === \"line\" && c[g - 1].hard ? void 0 : \"breakParent\";\n              if (h.type === \"trim\") return \"trim\";\n              if (h.type === \"indent\") return \"indent(\" + p(h.contents) + \")\";\n              if (h.type === \"align\") return h.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + p(h.contents) + \")\" : h.n < 0 ? \"dedent(\" + p(h.contents) + \")\" : h.n.type === \"root\" ? \"markAsRoot(\" + p(h.contents) + \")\" : \"align(\" + JSON.stringify(h.n) + \", \" + p(h.contents) + \")\";\n              if (h.type === \"if-break\") return \"ifBreak(\" + p(h.breakContents) + (h.flatContents ? \", \" + p(h.flatContents) : \"\") + (h.groupId ? (h.flatContents ? \"\" : ', \"\"') + `, { groupId: ${y(h.groupId)} }` : \"\") + \")\";\n              if (h.type === \"indent-if-break\") {\n                let f = [];\n                h.negate && f.push(\"negate: true\"), h.groupId && f.push(`groupId: ${y(h.groupId)}`);\n                let F = f.length > 0 ? `, { ${f.join(\", \")} }` : \"\";\n                return `indentIfBreak(${p(h.contents)}${F})`;\n              }\n              if (h.type === \"group\") {\n                let f = [];\n                h.break && h.break !== \"propagated\" && f.push(\"shouldBreak: true\"), h.id && f.push(`id: ${y(h.id)}`);\n                let F = f.length > 0 ? `, { ${f.join(\", \")} }` : \"\";\n                return h.expandedStates ? `conditionalGroup([${h.expandedStates.map(_ => p(_)).join(\",\")}]${F})` : `group(${p(h.contents)}${F})`;\n              }\n              if (h.type === \"fill\") return `fill([${h.parts.map(f => p(f)).join(\", \")}])`;\n              if (h.type === \"line-suffix\") return \"lineSuffix(\" + p(h.contents) + \")\";\n              if (h.type === \"line-suffix-boundary\") return \"lineSuffixBoundary\";\n              if (h.type === \"label\") return `label(${JSON.stringify(h.label)}, ${p(h.contents)})`;\n              throw new Error(\"Unknown doc type \" + h.type);\n            }\n            function y(h) {\n              if (typeof h != \"symbol\") return JSON.stringify(String(h));\n              if (h in i) return i[h];\n              let g = String(h).slice(7, -1) || \"symbol\";\n              for (let c = 0;; c++) {\n                let f = g + (c > 0 ? ` #${c}` : \"\");\n                if (!l.has(f)) return l.add(f), i[h] = `Symbol.for(${JSON.stringify(f)})`;\n              }\n            }\n          }\n          r.exports = {\n            printDocToDebug: n\n          };\n        }\n      }),\n      qe = te({\n        \"src/document/index.js\"(e, r) {\n          \"use strict\";\n\n          ne(), r.exports = {\n            builders: Un(),\n            printer: qD(),\n            utils: Yt(),\n            debug: MD()\n          };\n        }\n      }),\n      ja = {};\n    Kt(ja, {\n      default: () => RD\n    });\n    function RD(e) {\n      if (typeof e != \"string\") throw new TypeError(\"Expected a string\");\n      return e.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n    }\n    var $D = ht({\n        \"node_modules/escape-string-regexp/index.js\"() {\n          ne();\n        }\n      }),\n      qa = te({\n        \"node_modules/semver/internal/debug.js\"(e, r) {\n          ne();\n          var t = typeof wt == \"object\" && wt.env && wt.env.NODE_DEBUG && /\\bsemver\\b/i.test(wt.env.NODE_DEBUG) ? function () {\n            for (var s = arguments.length, a = new Array(s), n = 0; n < s; n++) a[n] = arguments[n];\n            return console.error(\"SEMVER\", ...a);\n          } : () => {};\n          r.exports = t;\n        }\n      }),\n      Ma = te({\n        \"node_modules/semver/internal/constants.js\"(e, r) {\n          ne();\n          var t = \"2.0.0\",\n            s = 256,\n            a = Number.MAX_SAFE_INTEGER || 9007199254740991,\n            n = 16;\n          r.exports = {\n            SEMVER_SPEC_VERSION: t,\n            MAX_LENGTH: s,\n            MAX_SAFE_INTEGER: a,\n            MAX_SAFE_COMPONENT_LENGTH: n\n          };\n        }\n      }),\n      VD = te({\n        \"node_modules/semver/internal/re.js\"(e, r) {\n          ne();\n          var {\n              MAX_SAFE_COMPONENT_LENGTH: t\n            } = Ma(),\n            s = qa();\n          e = r.exports = {};\n          var a = e.re = [],\n            n = e.src = [],\n            u = e.t = {},\n            i = 0,\n            l = (p, y, h) => {\n              let g = i++;\n              s(p, g, y), u[p] = g, n[g] = y, a[g] = new RegExp(y, h ? \"g\" : void 0);\n            };\n          l(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\"), l(\"NUMERICIDENTIFIERLOOSE\", \"[0-9]+\"), l(\"NONNUMERICIDENTIFIER\", \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\"), l(\"MAINVERSION\", `(${n[u.NUMERICIDENTIFIER]})\\\\.(${n[u.NUMERICIDENTIFIER]})\\\\.(${n[u.NUMERICIDENTIFIER]})`), l(\"MAINVERSIONLOOSE\", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l(\"PRERELEASEIDENTIFIER\", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l(\"PRERELEASE\", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l(\"PRERELEASELOOSE\", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l(\"BUILDIDENTIFIER\", \"[0-9A-Za-z-]+\"), l(\"BUILD\", `(?:\\\\+(${n[u.BUILDIDENTIFIER]}(?:\\\\.${n[u.BUILDIDENTIFIER]})*))`), l(\"FULLPLAIN\", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l(\"FULL\", `^${n[u.FULLPLAIN]}$`), l(\"LOOSEPLAIN\", `[v=\\\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l(\"LOOSE\", `^${n[u.LOOSEPLAIN]}$`), l(\"GTLT\", \"((?:<|>)?=?)\"), l(\"XRANGEIDENTIFIERLOOSE\", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`), l(\"XRANGEIDENTIFIER\", `${n[u.NUMERICIDENTIFIER]}|x|X|\\\\*`), l(\"XRANGEPLAIN\", `[v=\\\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\\\.(${n[u.XRANGEIDENTIFIER]})(?:\\\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l(\"XRANGE\", `^${n[u.GTLT]}\\\\s*${n[u.XRANGEPLAIN]}$`), l(\"XRANGELOOSE\", `^${n[u.GTLT]}\\\\s*${n[u.XRANGEPLAINLOOSE]}$`), l(\"COERCE\", `(^|[^\\\\d])(\\\\d{1,${t}})(?:\\\\.(\\\\d{1,${t}}))?(?:\\\\.(\\\\d{1,${t}}))?(?:$|[^\\\\d])`), l(\"COERCERTL\", n[u.COERCE], !0), l(\"LONETILDE\", \"(?:~>?)\"), l(\"TILDETRIM\", `(\\\\s*)${n[u.LONETILDE]}\\\\s+`, !0), e.tildeTrimReplace = \"$1~\", l(\"TILDE\", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l(\"TILDELOOSE\", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l(\"LONECARET\", \"(?:\\\\^)\"), l(\"CARETTRIM\", `(\\\\s*)${n[u.LONECARET]}\\\\s+`, !0), e.caretTrimReplace = \"$1^\", l(\"CARET\", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l(\"CARETLOOSE\", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l(\"COMPARATORLOOSE\", `^${n[u.GTLT]}\\\\s*(${n[u.LOOSEPLAIN]})$|^$`), l(\"COMPARATOR\", `^${n[u.GTLT]}\\\\s*(${n[u.FULLPLAIN]})$|^$`), l(\"COMPARATORTRIM\", `(\\\\s*)${n[u.GTLT]}\\\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = \"$1$2$3\", l(\"HYPHENRANGE\", `^\\\\s*(${n[u.XRANGEPLAIN]})\\\\s+-\\\\s+(${n[u.XRANGEPLAIN]})\\\\s*$`), l(\"HYPHENRANGELOOSE\", `^\\\\s*(${n[u.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${n[u.XRANGEPLAINLOOSE]})\\\\s*$`), l(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\"), l(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\"), l(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n        }\n      }),\n      WD = te({\n        \"node_modules/semver/internal/parse-options.js\"(e, r) {\n          ne();\n          var t = [\"includePrerelease\", \"loose\", \"rtl\"],\n            s = a => a ? typeof a != \"object\" ? {\n              loose: !0\n            } : t.filter(n => a[n]).reduce((n, u) => (n[u] = !0, n), {}) : {};\n          r.exports = s;\n        }\n      }),\n      HD = te({\n        \"node_modules/semver/internal/identifiers.js\"(e, r) {\n          ne();\n          var t = /^[0-9]+$/,\n            s = (n, u) => {\n              let i = t.test(n),\n                l = t.test(u);\n              return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;\n            },\n            a = (n, u) => s(u, n);\n          r.exports = {\n            compareIdentifiers: s,\n            rcompareIdentifiers: a\n          };\n        }\n      }),\n      GD = te({\n        \"node_modules/semver/classes/semver.js\"(e, r) {\n          ne();\n          var t = qa(),\n            {\n              MAX_LENGTH: s,\n              MAX_SAFE_INTEGER: a\n            } = Ma(),\n            {\n              re: n,\n              t: u\n            } = VD(),\n            i = WD(),\n            {\n              compareIdentifiers: l\n            } = HD(),\n            p = class {\n              constructor(y, h) {\n                if (h = i(h), y instanceof p) {\n                  if (y.loose === !!h.loose && y.includePrerelease === !!h.includePrerelease) return y;\n                  y = y.version;\n                } else if (typeof y != \"string\") throw new TypeError(`Invalid Version: ${y}`);\n                if (y.length > s) throw new TypeError(`version is longer than ${s} characters`);\n                t(\"SemVer\", y, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;\n                let g = y.trim().match(h.loose ? n[u.LOOSE] : n[u.FULL]);\n                if (!g) throw new TypeError(`Invalid Version: ${y}`);\n                if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a || this.major < 0) throw new TypeError(\"Invalid major version\");\n                if (this.minor > a || this.minor < 0) throw new TypeError(\"Invalid minor version\");\n                if (this.patch > a || this.patch < 0) throw new TypeError(\"Invalid patch version\");\n                g[4] ? this.prerelease = g[4].split(\".\").map(c => {\n                  if (/^[0-9]+$/.test(c)) {\n                    let f = +c;\n                    if (f >= 0 && f < a) return f;\n                  }\n                  return c;\n                }) : this.prerelease = [], this.build = g[5] ? g[5].split(\".\") : [], this.format();\n              }\n              format() {\n                return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(\".\")}`), this.version;\n              }\n              toString() {\n                return this.version;\n              }\n              compare(y) {\n                if (t(\"SemVer.compare\", this.version, this.options, y), !(y instanceof p)) {\n                  if (typeof y == \"string\" && y === this.version) return 0;\n                  y = new p(y, this.options);\n                }\n                return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);\n              }\n              compareMain(y) {\n                return y instanceof p || (y = new p(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);\n              }\n              comparePre(y) {\n                if (y instanceof p || (y = new p(y, this.options)), this.prerelease.length && !y.prerelease.length) return -1;\n                if (!this.prerelease.length && y.prerelease.length) return 1;\n                if (!this.prerelease.length && !y.prerelease.length) return 0;\n                let h = 0;\n                do {\n                  let g = this.prerelease[h],\n                    c = y.prerelease[h];\n                  if (t(\"prerelease compare\", h, g, c), g === void 0 && c === void 0) return 0;\n                  if (c === void 0) return 1;\n                  if (g === void 0) return -1;\n                  if (g === c) continue;\n                  return l(g, c);\n                } while (++h);\n              }\n              compareBuild(y) {\n                y instanceof p || (y = new p(y, this.options));\n                let h = 0;\n                do {\n                  let g = this.build[h],\n                    c = y.build[h];\n                  if (t(\"prerelease compare\", h, g, c), g === void 0 && c === void 0) return 0;\n                  if (c === void 0) return 1;\n                  if (g === void 0) return -1;\n                  if (g === c) continue;\n                  return l(g, c);\n                } while (++h);\n              }\n              inc(y, h) {\n                switch (y) {\n                  case \"premajor\":\n                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc(\"pre\", h);\n                    break;\n                  case \"preminor\":\n                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc(\"pre\", h);\n                    break;\n                  case \"prepatch\":\n                    this.prerelease.length = 0, this.inc(\"patch\", h), this.inc(\"pre\", h);\n                    break;\n                  case \"prerelease\":\n                    this.prerelease.length === 0 && this.inc(\"patch\", h), this.inc(\"pre\", h);\n                    break;\n                  case \"major\":\n                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];\n                    break;\n                  case \"minor\":\n                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];\n                    break;\n                  case \"patch\":\n                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];\n                    break;\n                  case \"pre\":\n                    if (this.prerelease.length === 0) this.prerelease = [0];else {\n                      let g = this.prerelease.length;\n                      for (; --g >= 0;) typeof this.prerelease[g] == \"number\" && (this.prerelease[g]++, g = -2);\n                      g === -1 && this.prerelease.push(0);\n                    }\n                    h && (l(this.prerelease[0], h) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);\n                    break;\n                  default:\n                    throw new Error(`invalid increment argument: ${y}`);\n                }\n                return this.format(), this.raw = this.version, this;\n              }\n            };\n          r.exports = p;\n        }\n      }),\n      zn = te({\n        \"node_modules/semver/functions/compare.js\"(e, r) {\n          ne();\n          var t = GD(),\n            s = (a, n, u) => new t(a, u).compare(new t(n, u));\n          r.exports = s;\n        }\n      }),\n      UD = te({\n        \"node_modules/semver/functions/lt.js\"(e, r) {\n          ne();\n          var t = zn(),\n            s = (a, n, u) => t(a, n, u) < 0;\n          r.exports = s;\n        }\n      }),\n      JD = te({\n        \"node_modules/semver/functions/gte.js\"(e, r) {\n          ne();\n          var t = zn(),\n            s = (a, n, u) => t(a, n, u) >= 0;\n          r.exports = s;\n        }\n      }),\n      zD = te({\n        \"src/utils/arrayify.js\"(e, r) {\n          \"use strict\";\n\n          ne(), r.exports = (t, s) => Object.entries(t).map(a => {\n            let [n, u] = a;\n            return Object.assign({\n              [s]: n\n            }, u);\n          });\n        }\n      }),\n      XD = te({\n        \"node_modules/outdent/lib/index.js\"(e, r) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.outdent = void 0;\n          function t() {\n            for (var E = [], N = 0; N < arguments.length; N++) E[N] = arguments[N];\n          }\n          function s() {\n            return typeof WeakMap < \"u\" ? new WeakMap() : a();\n          }\n          function a() {\n            return {\n              add: t,\n              delete: t,\n              get: t,\n              set: t,\n              has: function (E) {\n                return !1;\n              }\n            };\n          }\n          var n = Object.prototype.hasOwnProperty,\n            u = function (E, N) {\n              return n.call(E, N);\n            };\n          function i(E, N) {\n            for (var x in N) u(N, x) && (E[x] = N[x]);\n            return E;\n          }\n          var l = /^[ \\t]*(?:\\r\\n|\\r|\\n)/,\n            p = /(?:\\r\\n|\\r|\\n)[ \\t]*$/,\n            y = /^(?:[\\r\\n]|$)/,\n            h = /(?:\\r\\n|\\r|\\n)([ \\t]*)(?:[^ \\t\\r\\n]|$)/,\n            g = /^[ \\t]*[\\r\\n][ \\t\\r\\n]*$/;\n          function c(E, N, x) {\n            var I = 0,\n              P = E[0].match(h);\n            P && (I = P[1].length);\n            var $ = \"(\\\\r\\\\n|\\\\r|\\\\n).{0,\" + I + \"}\",\n              D = new RegExp($, \"g\");\n            N && (E = E.slice(1));\n            var T = x.newline,\n              m = x.trimLeadingNewline,\n              C = x.trimTrailingNewline,\n              o = typeof T == \"string\",\n              d = E.length,\n              v = E.map(function (S, b) {\n                return S = S.replace(D, \"$1\"), b === 0 && m && (S = S.replace(l, \"\")), b === d - 1 && C && (S = S.replace(p, \"\")), o && (S = S.replace(/\\r\\n|\\n|\\r/g, function (B) {\n                  return T;\n                })), S;\n              });\n            return v;\n          }\n          function f(E, N) {\n            for (var x = \"\", I = 0, P = E.length; I < P; I++) x += E[I], I < P - 1 && (x += N[I]);\n            return x;\n          }\n          function F(E) {\n            return u(E, \"raw\") && u(E, \"length\");\n          }\n          function _(E) {\n            var N = s(),\n              x = s();\n            function I($) {\n              for (var D = [], T = 1; T < arguments.length; T++) D[T - 1] = arguments[T];\n              if (F($)) {\n                var m = $,\n                  C = (D[0] === I || D[0] === w) && g.test(m[0]) && y.test(m[1]),\n                  o = C ? x : N,\n                  d = o.get(m);\n                if (d || (d = c(m, C, E), o.set(m, d)), D.length === 0) return d[0];\n                var v = f(d, C ? D.slice(1) : D);\n                return v;\n              } else return _(i(i({}, E), $ || {}));\n            }\n            var P = i(I, {\n              string: function ($) {\n                return c([$], !1, E)[0];\n              }\n            });\n            return P;\n          }\n          var w = _({\n            trimLeadingNewline: !0,\n            trimTrailingNewline: !0\n          });\n          if (e.outdent = w, e.default = w, typeof r < \"u\") try {\n            r.exports = w, Object.defineProperty(w, \"__esModule\", {\n              value: !0\n            }), w.default = w, w.outdent = w;\n          } catch {}\n        }\n      }),\n      KD = te({\n        \"src/main/core-options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              outdent: t\n            } = XD(),\n            s = \"Config\",\n            a = \"Editor\",\n            n = \"Format\",\n            u = \"Other\",\n            i = \"Output\",\n            l = \"Global\",\n            p = \"Special\",\n            y = {\n              cursorOffset: {\n                since: \"1.4.0\",\n                category: p,\n                type: \"int\",\n                default: -1,\n                range: {\n                  start: -1,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                },\n                description: t`\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    `,\n                cliCategory: a\n              },\n              endOfLine: {\n                since: \"1.15.0\",\n                category: l,\n                type: \"choice\",\n                default: [{\n                  since: \"1.15.0\",\n                  value: \"auto\"\n                }, {\n                  since: \"2.0.0\",\n                  value: \"lf\"\n                }],\n                description: \"Which end of line characters to apply.\",\n                choices: [{\n                  value: \"lf\",\n                  description: \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\"\n                }, {\n                  value: \"crlf\",\n                  description: \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\"\n                }, {\n                  value: \"cr\",\n                  description: \"Carriage Return character only (\\\\r), used very rarely\"\n                }, {\n                  value: \"auto\",\n                  description: t`\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        `\n                }]\n              },\n              filepath: {\n                since: \"1.4.0\",\n                category: p,\n                type: \"path\",\n                description: \"Specify the input filepath. This will be used to do parser inference.\",\n                cliName: \"stdin-filepath\",\n                cliCategory: u,\n                cliDescription: \"Path to the file to pretend that stdin comes from.\"\n              },\n              insertPragma: {\n                since: \"1.8.0\",\n                category: p,\n                type: \"boolean\",\n                default: !1,\n                description: \"Insert @format pragma into file's first docblock comment.\",\n                cliCategory: u\n              },\n              parser: {\n                since: \"0.0.10\",\n                category: l,\n                type: \"choice\",\n                default: [{\n                  since: \"0.0.10\",\n                  value: \"babylon\"\n                }, {\n                  since: \"1.13.0\",\n                  value: void 0\n                }],\n                description: \"Which parser to use.\",\n                exception: h => typeof h == \"string\" || typeof h == \"function\",\n                choices: [{\n                  value: \"flow\",\n                  description: \"Flow\"\n                }, {\n                  value: \"babel\",\n                  since: \"1.16.0\",\n                  description: \"JavaScript\"\n                }, {\n                  value: \"babel-flow\",\n                  since: \"1.16.0\",\n                  description: \"Flow\"\n                }, {\n                  value: \"babel-ts\",\n                  since: \"2.0.0\",\n                  description: \"TypeScript\"\n                }, {\n                  value: \"typescript\",\n                  since: \"1.4.0\",\n                  description: \"TypeScript\"\n                }, {\n                  value: \"acorn\",\n                  since: \"2.6.0\",\n                  description: \"JavaScript\"\n                }, {\n                  value: \"espree\",\n                  since: \"2.2.0\",\n                  description: \"JavaScript\"\n                }, {\n                  value: \"meriyah\",\n                  since: \"2.2.0\",\n                  description: \"JavaScript\"\n                }, {\n                  value: \"css\",\n                  since: \"1.7.1\",\n                  description: \"CSS\"\n                }, {\n                  value: \"less\",\n                  since: \"1.7.1\",\n                  description: \"Less\"\n                }, {\n                  value: \"scss\",\n                  since: \"1.7.1\",\n                  description: \"SCSS\"\n                }, {\n                  value: \"json\",\n                  since: \"1.5.0\",\n                  description: \"JSON\"\n                }, {\n                  value: \"json5\",\n                  since: \"1.13.0\",\n                  description: \"JSON5\"\n                }, {\n                  value: \"json-stringify\",\n                  since: \"1.13.0\",\n                  description: \"JSON.stringify\"\n                }, {\n                  value: \"graphql\",\n                  since: \"1.5.0\",\n                  description: \"GraphQL\"\n                }, {\n                  value: \"markdown\",\n                  since: \"1.8.0\",\n                  description: \"Markdown\"\n                }, {\n                  value: \"mdx\",\n                  since: \"1.15.0\",\n                  description: \"MDX\"\n                }, {\n                  value: \"vue\",\n                  since: \"1.10.0\",\n                  description: \"Vue\"\n                }, {\n                  value: \"yaml\",\n                  since: \"1.14.0\",\n                  description: \"YAML\"\n                }, {\n                  value: \"glimmer\",\n                  since: \"2.3.0\",\n                  description: \"Ember / Handlebars\"\n                }, {\n                  value: \"html\",\n                  since: \"1.15.0\",\n                  description: \"HTML\"\n                }, {\n                  value: \"angular\",\n                  since: \"1.15.0\",\n                  description: \"Angular\"\n                }, {\n                  value: \"lwc\",\n                  since: \"1.17.0\",\n                  description: \"Lightning Web Components\"\n                }]\n              },\n              plugins: {\n                since: \"1.10.0\",\n                type: \"path\",\n                array: !0,\n                default: [{\n                  value: []\n                }],\n                category: l,\n                description: \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",\n                exception: h => typeof h == \"string\" || typeof h == \"object\",\n                cliName: \"plugin\",\n                cliCategory: s\n              },\n              pluginSearchDirs: {\n                since: \"1.13.0\",\n                type: \"path\",\n                array: !0,\n                default: [{\n                  value: []\n                }],\n                category: l,\n                description: t`\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    `,\n                exception: h => typeof h == \"string\" || typeof h == \"object\",\n                cliName: \"plugin-search-dir\",\n                cliCategory: s\n              },\n              printWidth: {\n                since: \"0.0.0\",\n                category: l,\n                type: \"int\",\n                default: 80,\n                description: \"The line length where Prettier will try wrap.\",\n                range: {\n                  start: 0,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                }\n              },\n              rangeEnd: {\n                since: \"1.4.0\",\n                category: p,\n                type: \"int\",\n                default: Number.POSITIVE_INFINITY,\n                range: {\n                  start: 0,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                },\n                description: t`\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    `,\n                cliCategory: a\n              },\n              rangeStart: {\n                since: \"1.4.0\",\n                category: p,\n                type: \"int\",\n                default: 0,\n                range: {\n                  start: 0,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                },\n                description: t`\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    `,\n                cliCategory: a\n              },\n              requirePragma: {\n                since: \"1.7.0\",\n                category: p,\n                type: \"boolean\",\n                default: !1,\n                description: t`\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    `,\n                cliCategory: u\n              },\n              tabWidth: {\n                type: \"int\",\n                category: l,\n                default: 2,\n                description: \"Number of spaces per indentation level.\",\n                range: {\n                  start: 0,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                }\n              },\n              useTabs: {\n                since: \"1.0.0\",\n                category: l,\n                type: \"boolean\",\n                default: !1,\n                description: \"Indent with tabs instead of spaces.\"\n              },\n              embeddedLanguageFormatting: {\n                since: \"2.1.0\",\n                category: l,\n                type: \"choice\",\n                default: [{\n                  since: \"2.1.0\",\n                  value: \"auto\"\n                }],\n                description: \"Control how Prettier formats quoted code embedded in the file.\",\n                choices: [{\n                  value: \"auto\",\n                  description: \"Format embedded code if Prettier can automatically identify it.\"\n                }, {\n                  value: \"off\",\n                  description: \"Never automatically format embedded code.\"\n                }]\n              }\n            };\n          r.exports = {\n            CATEGORY_CONFIG: s,\n            CATEGORY_EDITOR: a,\n            CATEGORY_FORMAT: n,\n            CATEGORY_OTHER: u,\n            CATEGORY_OUTPUT: i,\n            CATEGORY_GLOBAL: l,\n            CATEGORY_SPECIAL: p,\n            options: y\n          };\n        }\n      }),\n      Xn = te({\n        \"src/main/support.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = {\n              compare: zn(),\n              lt: UD(),\n              gte: JD()\n            },\n            s = zD(),\n            a = Ia().version,\n            n = KD().options;\n          function u() {\n            let {\n                plugins: l = [],\n                showUnreleased: p = !1,\n                showDeprecated: y = !1,\n                showInternal: h = !1\n              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n              g = a.split(\"-\", 1)[0],\n              c = l.flatMap(E => E.languages || []).filter(F),\n              f = s(Object.assign({}, ...l.map(E => {\n                let {\n                  options: N\n                } = E;\n                return N;\n              }), n), \"name\").filter(E => F(E) && _(E)).sort((E, N) => E.name === N.name ? 0 : E.name < N.name ? -1 : 1).map(w).map(E => {\n                E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F).sort((x, I) => t.compare(I.since, x.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter(x => F(x) && _(x)), E.name === \"parser\" && i(E, c, l));\n                let N = Object.fromEntries(l.filter(x => x.defaultOptions && x.defaultOptions[E.name] !== void 0).map(x => [x.name, x.defaultOptions[E.name]]));\n                return Object.assign(Object.assign({}, E), {}, {\n                  pluginDefaults: N\n                });\n              });\n            return {\n              languages: c,\n              options: f\n            };\n            function F(E) {\n              return p || !(\"since\" in E) || E.since && t.gte(g, E.since);\n            }\n            function _(E) {\n              return y || !(\"deprecated\" in E) || E.deprecated && t.lt(g, E.deprecated);\n            }\n            function w(E) {\n              if (h) return E;\n              let {\n                cliName: N,\n                cliCategory: x,\n                cliDescription: I\n              } = E;\n              return Hn(E, hD);\n            }\n          }\n          function i(l, p, y) {\n            let h = new Set(l.choices.map(g => g.value));\n            for (let g of p) if (g.parsers) {\n              for (let c of g.parsers) if (!h.has(c)) {\n                h.add(c);\n                let f = y.find(_ => _.parsers && _.parsers[c]),\n                  F = g.name;\n                f && f.name && (F += ` (plugin: ${f.name})`), l.choices.push({\n                  value: c,\n                  description: F\n                });\n              }\n            }\n          }\n          r.exports = {\n            getSupportInfo: u\n          };\n        }\n      }),\n      Kn = te({\n        \"src/utils/is-non-empty-array.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s) {\n            return Array.isArray(s) && s.length > 0;\n          }\n          r.exports = t;\n        }\n      }),\n      Pr = te({\n        \"src/utils/text/skip.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(i) {\n            return (l, p, y) => {\n              let h = y && y.backwards;\n              if (p === !1) return !1;\n              let {\n                  length: g\n                } = l,\n                c = p;\n              for (; c >= 0 && c < g;) {\n                let f = l.charAt(c);\n                if (i instanceof RegExp) {\n                  if (!i.test(f)) return c;\n                } else if (!i.includes(f)) return c;\n                h ? c-- : c++;\n              }\n              return c === -1 || c === g ? c : !1;\n            };\n          }\n          var s = t(/\\s/),\n            a = t(\" \t\"),\n            n = t(\",; \t\"),\n            u = t(/[^\\n\\r]/);\n          r.exports = {\n            skipWhitespace: s,\n            skipSpaces: a,\n            skipToLineEnd: n,\n            skipEverythingButNewLine: u\n          };\n        }\n      }),\n      Ra = te({\n        \"src/utils/text/skip-inline-comment.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s, a) {\n            if (a === !1) return !1;\n            if (s.charAt(a) === \"/\" && s.charAt(a + 1) === \"*\") {\n              for (let n = a + 2; n < s.length; ++n) if (s.charAt(n) === \"*\" && s.charAt(n + 1) === \"/\") return n + 2;\n            }\n            return a;\n          }\n          r.exports = t;\n        }\n      }),\n      $a = te({\n        \"src/utils/text/skip-trailing-comment.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            skipEverythingButNewLine: t\n          } = Pr();\n          function s(a, n) {\n            return n === !1 ? !1 : a.charAt(n) === \"/\" && a.charAt(n + 1) === \"/\" ? t(a, n) : n;\n          }\n          r.exports = s;\n        }\n      }),\n      Va = te({\n        \"src/utils/text/skip-newline.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s, a, n) {\n            let u = n && n.backwards;\n            if (a === !1) return !1;\n            let i = s.charAt(a);\n            if (u) {\n              if (s.charAt(a - 1) === \"\\r\" && i === `\n`) return a - 2;\n              if (i === `\n` || i === \"\\r\" || i === \"\\u2028\" || i === \"\\u2029\") return a - 1;\n            } else {\n              if (i === \"\\r\" && s.charAt(a + 1) === `\n`) return a + 2;\n              if (i === `\n` || i === \"\\r\" || i === \"\\u2028\" || i === \"\\u2029\") return a + 1;\n            }\n            return a;\n          }\n          r.exports = t;\n        }\n      }),\n      YD = te({\n        \"src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Ra(),\n            s = Va(),\n            a = $a(),\n            {\n              skipSpaces: n\n            } = Pr();\n          function u(i, l) {\n            let p = null,\n              y = l;\n            for (; y !== p;) p = y, y = n(i, y), y = t(i, y), y = a(i, y), y = s(i, y);\n            return y;\n          }\n          r.exports = u;\n        }\n      }),\n      Ue = te({\n        \"src/common/util.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              default: t\n            } = ($D(), ft(ja)),\n            s = lt(),\n            {\n              getSupportInfo: a\n            } = Xn(),\n            n = Kn(),\n            u = Oa(),\n            {\n              skipWhitespace: i,\n              skipSpaces: l,\n              skipToLineEnd: p,\n              skipEverythingButNewLine: y\n            } = Pr(),\n            h = Ra(),\n            g = $a(),\n            c = Va(),\n            f = YD(),\n            F = V => V[V.length - 2];\n          function _(V) {\n            return (j, Y, ie) => {\n              let ee = ie && ie.backwards;\n              if (Y === !1) return !1;\n              let {\n                  length: ce\n                } = j,\n                W = Y;\n              for (; W >= 0 && W < ce;) {\n                let K = j.charAt(W);\n                if (V instanceof RegExp) {\n                  if (!V.test(K)) return W;\n                } else if (!V.includes(K)) return W;\n                ee ? W-- : W++;\n              }\n              return W === -1 || W === ce ? W : !1;\n            };\n          }\n          function w(V, j) {\n            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              ie = l(V, Y.backwards ? j - 1 : j, Y),\n              ee = c(V, ie, Y);\n            return ie !== ee;\n          }\n          function E(V, j, Y) {\n            for (let ie = j; ie < Y; ++ie) if (V.charAt(ie) === `\n`) return !0;\n            return !1;\n          }\n          function N(V, j, Y) {\n            let ie = Y(j) - 1;\n            ie = l(V, ie, {\n              backwards: !0\n            }), ie = c(V, ie, {\n              backwards: !0\n            }), ie = l(V, ie, {\n              backwards: !0\n            });\n            let ee = c(V, ie, {\n              backwards: !0\n            });\n            return ie !== ee;\n          }\n          function x(V, j) {\n            let Y = null,\n              ie = j;\n            for (; ie !== Y;) Y = ie, ie = p(V, ie), ie = h(V, ie), ie = l(V, ie);\n            return ie = g(V, ie), ie = c(V, ie), ie !== !1 && w(V, ie);\n          }\n          function I(V, j, Y) {\n            return x(V, Y(j));\n          }\n          function P(V, j, Y) {\n            return f(V, Y(j));\n          }\n          function $(V, j, Y) {\n            return V.charAt(P(V, j, Y));\n          }\n          function D(V, j) {\n            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            return l(V, Y.backwards ? j - 1 : j, Y) !== j;\n          }\n          function T(V, j) {\n            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n              ie = 0;\n            for (let ee = Y; ee < V.length; ++ee) V[ee] === \"\t\" ? ie = ie + j - ie % j : ie++;\n            return ie;\n          }\n          function m(V, j) {\n            let Y = V.lastIndexOf(`\n`);\n            return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\\t ]*/)[0], j);\n          }\n          function C(V, j) {\n            let Y = {\n                quote: '\"',\n                regex: /\"/g,\n                escaped: \"&quot;\"\n              },\n              ie = {\n                quote: \"'\",\n                regex: /'/g,\n                escaped: \"&apos;\"\n              },\n              ee = j === \"'\" ? ie : Y,\n              ce = ee === ie ? Y : ie,\n              W = ee;\n            if (V.includes(ee.quote) || V.includes(ce.quote)) {\n              let K = (V.match(ee.regex) || []).length,\n                de = (V.match(ce.regex) || []).length;\n              W = K > de ? ce : ee;\n            }\n            return W;\n          }\n          function o(V, j) {\n            let Y = V.slice(1, -1),\n              ie = j.parser === \"json\" || j.parser === \"json5\" && j.quoteProps === \"preserve\" && !j.singleQuote ? '\"' : j.__isInHtmlAttribute ? \"'\" : C(Y, j.singleQuote ? \"'\" : '\"').quote;\n            return d(Y, ie, !(j.parser === \"css\" || j.parser === \"less\" || j.parser === \"scss\" || j.__embeddedInHtml));\n          }\n          function d(V, j, Y) {\n            let ie = j === '\"' ? \"'\" : '\"',\n              ee = /\\\\(.)|([\"'])/gs,\n              ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? \"\\\\\" + de : de || (Y && /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(K) ? K : \"\\\\\" + K));\n            return j + ce + j;\n          }\n          function v(V) {\n            return V.toLowerCase().replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\").replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\").replace(/^([+-])?\\./, \"$10.\").replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\").replace(/\\.(?=e|$)/, \"\");\n          }\n          function S(V, j) {\n            let Y = V.match(new RegExp(`(${t(j)})+`, \"g\"));\n            return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);\n          }\n          function b(V, j) {\n            let Y = V.match(new RegExp(`(${t(j)})+`, \"g\"));\n            if (Y === null) return 0;\n            let ie = new Map(),\n              ee = 0;\n            for (let ce of Y) {\n              let W = ce.length / j.length;\n              ie.set(W, !0), W > ee && (ee = W);\n            }\n            for (let ce = 1; ce < ee; ce++) if (!ie.get(ce)) return ce;\n            return ee + 1;\n          }\n          function B(V, j) {\n            (V.comments || (V.comments = [])).push(j), j.printed = !1, j.nodeDescription = Q(V);\n          }\n          function k(V, j) {\n            j.leading = !0, j.trailing = !1, B(V, j);\n          }\n          function M(V, j, Y) {\n            j.leading = !1, j.trailing = !1, Y && (j.marker = Y), B(V, j);\n          }\n          function R(V, j) {\n            j.leading = !1, j.trailing = !0, B(V, j);\n          }\n          function q(V, j) {\n            let {\n                languages: Y\n              } = a({\n                plugins: j.plugins\n              }),\n              ie = Y.find(ee => {\n                let {\n                  name: ce\n                } = ee;\n                return ce.toLowerCase() === V;\n              }) || Y.find(ee => {\n                let {\n                  aliases: ce\n                } = ee;\n                return Array.isArray(ce) && ce.includes(V);\n              }) || Y.find(ee => {\n                let {\n                  extensions: ce\n                } = ee;\n                return Array.isArray(ce) && ce.includes(`.${V}`);\n              });\n            return ie && ie.parsers[0];\n          }\n          function J(V) {\n            return V && V.type === \"front-matter\";\n          }\n          function L(V) {\n            let j = new WeakMap();\n            return function (Y) {\n              return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);\n            };\n          }\n          function Q(V) {\n            let j = V.type || V.kind || \"(unknown type)\",\n              Y = String(V.name || V.id && (typeof V.id == \"object\" ? V.id.name : V.id) || V.key && (typeof V.key == \"object\" ? V.key.name : V.key) || V.value && (typeof V.value == \"object\" ? \"\" : String(V.value)) || V.operator || \"\");\n            return Y.length > 20 && (Y = Y.slice(0, 19) + \"\\u2026\"), j + (Y ? \" \" + Y : \"\");\n          }\n          r.exports = {\n            inferParserByLanguage: q,\n            getStringWidth: u,\n            getMaxContinuousCount: S,\n            getMinNotPresentContinuousCount: b,\n            getPenultimate: F,\n            getLast: s,\n            getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f,\n            getNextNonSpaceNonCommentCharacterIndex: P,\n            getNextNonSpaceNonCommentCharacter: $,\n            skip: _,\n            skipWhitespace: i,\n            skipSpaces: l,\n            skipToLineEnd: p,\n            skipEverythingButNewLine: y,\n            skipInlineComment: h,\n            skipTrailingComment: g,\n            skipNewline: c,\n            isNextLineEmptyAfterIndex: x,\n            isNextLineEmpty: I,\n            isPreviousLineEmpty: N,\n            hasNewline: w,\n            hasNewlineInRange: E,\n            hasSpaces: D,\n            getAlignmentSize: T,\n            getIndentSize: m,\n            getPreferredQuote: C,\n            printString: o,\n            printNumber: v,\n            makeString: d,\n            addLeadingComment: k,\n            addDanglingComment: M,\n            addTrailingComment: R,\n            isFrontMatterNode: J,\n            isNonEmptyArray: n,\n            createGroupIdMapper: L\n          };\n        }\n      }),\n      Wa = {};\n    Kt(Wa, {\n      basename: () => za,\n      default: () => Ka,\n      delimiter: () => Mn,\n      dirname: () => Ja,\n      extname: () => Xa,\n      isAbsolute: () => Qn,\n      join: () => Ga,\n      normalize: () => Yn,\n      relative: () => Ua,\n      resolve: () => wr,\n      sep: () => qn\n    });\n    function Ha(e, r) {\n      for (var t = 0, s = e.length - 1; s >= 0; s--) {\n        var a = e[s];\n        a === \".\" ? e.splice(s, 1) : a === \"..\" ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);\n      }\n      if (r) for (; t--; t) e.unshift(\"..\");\n      return e;\n    }\n    function wr() {\n      for (var e = \"\", r = !1, t = arguments.length - 1; t >= -1 && !r; t--) {\n        var s = t >= 0 ? arguments[t] : \"/\";\n        if (typeof s != \"string\") throw new TypeError(\"Arguments to path.resolve must be strings\");\n        if (!s) continue;\n        e = s + \"/\" + e, r = s.charAt(0) === \"/\";\n      }\n      return e = Ha(Zn(e.split(\"/\"), function (a) {\n        return !!a;\n      }), !r).join(\"/\"), (r ? \"/\" : \"\") + e || \".\";\n    }\n    function Yn(e) {\n      var r = Qn(e),\n        t = Ya(e, -1) === \"/\";\n      return e = Ha(Zn(e.split(\"/\"), function (s) {\n        return !!s;\n      }), !r).join(\"/\"), !e && !r && (e = \".\"), e && t && (e += \"/\"), (r ? \"/\" : \"\") + e;\n    }\n    function Qn(e) {\n      return e.charAt(0) === \"/\";\n    }\n    function Ga() {\n      var e = Array.prototype.slice.call(arguments, 0);\n      return Yn(Zn(e, function (r, t) {\n        if (typeof r != \"string\") throw new TypeError(\"Arguments to path.join must be strings\");\n        return r;\n      }).join(\"/\"));\n    }\n    function Ua(e, r) {\n      e = wr(e).substr(1), r = wr(r).substr(1);\n      function t(p) {\n        for (var y = 0; y < p.length && p[y] === \"\"; y++);\n        for (var h = p.length - 1; h >= 0 && p[h] === \"\"; h--);\n        return y > h ? [] : p.slice(y, h - y + 1);\n      }\n      for (var s = t(e.split(\"/\")), a = t(r.split(\"/\")), n = Math.min(s.length, a.length), u = n, i = 0; i < n; i++) if (s[i] !== a[i]) {\n        u = i;\n        break;\n      }\n      for (var l = [], i = u; i < s.length; i++) l.push(\"..\");\n      return l = l.concat(a.slice(u)), l.join(\"/\");\n    }\n    function Ja(e) {\n      var r = Ir(e),\n        t = r[0],\n        s = r[1];\n      return !t && !s ? \".\" : (s && (s = s.substr(0, s.length - 1)), t + s);\n    }\n    function za(e, r) {\n      var t = Ir(e)[2];\n      return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;\n    }\n    function Xa(e) {\n      return Ir(e)[3];\n    }\n    function Zn(e, r) {\n      if (e.filter) return e.filter(r);\n      for (var t = [], s = 0; s < e.length; s++) r(e[s], s, e) && t.push(e[s]);\n      return t;\n    }\n    var Na,\n      Ir,\n      qn,\n      Mn,\n      Ka,\n      Ya,\n      QD = ht({\n        \"node-modules-polyfills:path\"() {\n          ne(), Na = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/, Ir = function (e) {\n            return Na.exec(e).slice(1);\n          }, qn = \"/\", Mn = \":\", Ka = {\n            extname: Xa,\n            basename: za,\n            dirname: Ja,\n            sep: qn,\n            delimiter: Mn,\n            relative: Ua,\n            join: Ga,\n            isAbsolute: Qn,\n            normalize: Yn,\n            resolve: wr\n          }, Ya =  true ? function (e, r, t) {\n            return e.substr(r, t);\n          } : 0;\n        }\n      }),\n      ZD = te({\n        \"node-modules-polyfills-commonjs:path\"(e, r) {\n          ne();\n          var t = (QD(), ft(Wa));\n          if (t && t.default) {\n            r.exports = t.default;\n            for (let s in t) r.exports[s] = t[s];\n          } else t && (r.exports = t);\n        }\n      }),\n      Qt = te({\n        \"src/common/errors.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = class extends Error {},\n            s = class extends Error {},\n            a = class extends Error {},\n            n = class extends Error {};\n          r.exports = {\n            ConfigError: t,\n            DebugError: s,\n            UndefinedParserError: a,\n            ArgExpansionBailout: n\n          };\n        }\n      }),\n      vt = {};\n    Kt(vt, {\n      __assign: () => Nr,\n      __asyncDelegator: () => fm,\n      __asyncGenerator: () => pm,\n      __asyncValues: () => Dm,\n      __await: () => Xt,\n      __awaiter: () => sm,\n      __classPrivateFieldGet: () => ym,\n      __classPrivateFieldSet: () => hm,\n      __createBinding: () => am,\n      __decorate: () => rm,\n      __exportStar: () => om,\n      __extends: () => em,\n      __generator: () => im,\n      __importDefault: () => gm,\n      __importStar: () => dm,\n      __makeTemplateObject: () => mm,\n      __metadata: () => um,\n      __param: () => nm,\n      __read: () => Qa,\n      __rest: () => tm,\n      __spread: () => lm,\n      __spreadArrays: () => cm,\n      __values: () => Rn\n    });\n    function em(e, r) {\n      Br(e, r);\n      function t() {\n        this.constructor = e;\n      }\n      e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());\n    }\n    function tm(e, r) {\n      var t = {};\n      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (t[s] = e[s]);\n      if (e != null && typeof Object.getOwnPropertySymbols == \"function\") for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++) r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);\n      return t;\n    }\n    function rm(e, r, t, s) {\n      var a = arguments.length,\n        n = a < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t) : s,\n        u;\n      if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\") n = Reflect.decorate(e, r, t, s);else for (var i = e.length - 1; i >= 0; i--) (u = e[i]) && (n = (a < 3 ? u(n) : a > 3 ? u(r, t, n) : u(r, t)) || n);\n      return a > 3 && n && Object.defineProperty(r, t, n), n;\n    }\n    function nm(e, r) {\n      return function (t, s) {\n        r(t, s, e);\n      };\n    }\n    function um(e, r) {\n      if (typeof Reflect == \"object\" && typeof Reflect.metadata == \"function\") return Reflect.metadata(e, r);\n    }\n    function sm(e, r, t, s) {\n      function a(n) {\n        return n instanceof t ? n : new t(function (u) {\n          u(n);\n        });\n      }\n      return new (t || (t = Promise))(function (n, u) {\n        function i(y) {\n          try {\n            p(s.next(y));\n          } catch (h) {\n            u(h);\n          }\n        }\n        function l(y) {\n          try {\n            p(s.throw(y));\n          } catch (h) {\n            u(h);\n          }\n        }\n        function p(y) {\n          y.done ? n(y.value) : a(y.value).then(i, l);\n        }\n        p((s = s.apply(e, r || [])).next());\n      });\n    }\n    function im(e, r) {\n      var t = {\n          label: 0,\n          sent: function () {\n            if (n[0] & 1) throw n[1];\n            return n[1];\n          },\n          trys: [],\n          ops: []\n        },\n        s,\n        a,\n        n,\n        u;\n      return u = {\n        next: i(0),\n        throw: i(1),\n        return: i(2)\n      }, typeof Symbol == \"function\" && (u[Symbol.iterator] = function () {\n        return this;\n      }), u;\n      function i(p) {\n        return function (y) {\n          return l([p, y]);\n        };\n      }\n      function l(p) {\n        if (s) throw new TypeError(\"Generator is already executing.\");\n        for (; t;) try {\n          if (s = 1, a && (n = p[0] & 2 ? a.return : p[0] ? a.throw || ((n = a.return) && n.call(a), 0) : a.next) && !(n = n.call(a, p[1])).done) return n;\n          switch (a = 0, n && (p = [p[0] & 2, n.value]), p[0]) {\n            case 0:\n            case 1:\n              n = p;\n              break;\n            case 4:\n              return t.label++, {\n                value: p[1],\n                done: !1\n              };\n            case 5:\n              t.label++, a = p[1], p = [0];\n              continue;\n            case 7:\n              p = t.ops.pop(), t.trys.pop();\n              continue;\n            default:\n              if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p[0] === 6 || p[0] === 2)) {\n                t = 0;\n                continue;\n              }\n              if (p[0] === 3 && (!n || p[1] > n[0] && p[1] < n[3])) {\n                t.label = p[1];\n                break;\n              }\n              if (p[0] === 6 && t.label < n[1]) {\n                t.label = n[1], n = p;\n                break;\n              }\n              if (n && t.label < n[2]) {\n                t.label = n[2], t.ops.push(p);\n                break;\n              }\n              n[2] && t.ops.pop(), t.trys.pop();\n              continue;\n          }\n          p = r.call(e, t);\n        } catch (y) {\n          p = [6, y], a = 0;\n        } finally {\n          s = n = 0;\n        }\n        if (p[0] & 5) throw p[1];\n        return {\n          value: p[0] ? p[1] : void 0,\n          done: !0\n        };\n      }\n    }\n    function am(e, r, t, s) {\n      s === void 0 && (s = t), e[s] = r[t];\n    }\n    function om(e, r) {\n      for (var t in e) t !== \"default\" && !r.hasOwnProperty(t) && (r[t] = e[t]);\n    }\n    function Rn(e) {\n      var r = typeof Symbol == \"function\" && Symbol.iterator,\n        t = r && e[r],\n        s = 0;\n      if (t) return t.call(e);\n      if (e && typeof e.length == \"number\") return {\n        next: function () {\n          return e && s >= e.length && (e = void 0), {\n            value: e && e[s++],\n            done: !e\n          };\n        }\n      };\n      throw new TypeError(r ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    }\n    function Qa(e, r) {\n      var t = typeof Symbol == \"function\" && e[Symbol.iterator];\n      if (!t) return e;\n      var s = t.call(e),\n        a,\n        n = [],\n        u;\n      try {\n        for (; (r === void 0 || r-- > 0) && !(a = s.next()).done;) n.push(a.value);\n      } catch (i) {\n        u = {\n          error: i\n        };\n      } finally {\n        try {\n          a && !a.done && (t = s.return) && t.call(s);\n        } finally {\n          if (u) throw u.error;\n        }\n      }\n      return n;\n    }\n    function lm() {\n      for (var e = [], r = 0; r < arguments.length; r++) e = e.concat(Qa(arguments[r]));\n      return e;\n    }\n    function cm() {\n      for (var e = 0, r = 0, t = arguments.length; r < t; r++) e += arguments[r].length;\n      for (var s = Array(e), a = 0, r = 0; r < t; r++) for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a++) s[a] = n[u];\n      return s;\n    }\n    function Xt(e) {\n      return this instanceof Xt ? (this.v = e, this) : new Xt(e);\n    }\n    function pm(e, r, t) {\n      if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var s = t.apply(e, r || []),\n        a,\n        n = [];\n      return a = {}, u(\"next\"), u(\"throw\"), u(\"return\"), a[Symbol.asyncIterator] = function () {\n        return this;\n      }, a;\n      function u(g) {\n        s[g] && (a[g] = function (c) {\n          return new Promise(function (f, F) {\n            n.push([g, c, f, F]) > 1 || i(g, c);\n          });\n        });\n      }\n      function i(g, c) {\n        try {\n          l(s[g](c));\n        } catch (f) {\n          h(n[0][3], f);\n        }\n      }\n      function l(g) {\n        g.value instanceof Xt ? Promise.resolve(g.value.v).then(p, y) : h(n[0][2], g);\n      }\n      function p(g) {\n        i(\"next\", g);\n      }\n      function y(g) {\n        i(\"throw\", g);\n      }\n      function h(g, c) {\n        g(c), n.shift(), n.length && i(n[0][0], n[0][1]);\n      }\n    }\n    function fm(e) {\n      var r, t;\n      return r = {}, s(\"next\"), s(\"throw\", function (a) {\n        throw a;\n      }), s(\"return\"), r[Symbol.iterator] = function () {\n        return this;\n      }, r;\n      function s(a, n) {\n        r[a] = e[a] ? function (u) {\n          return (t = !t) ? {\n            value: Xt(e[a](u)),\n            done: a === \"return\"\n          } : n ? n(u) : u;\n        } : n;\n      }\n    }\n    function Dm(e) {\n      if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var r = e[Symbol.asyncIterator],\n        t;\n      return r ? r.call(e) : (e = typeof Rn == \"function\" ? Rn(e) : e[Symbol.iterator](), t = {}, s(\"next\"), s(\"throw\"), s(\"return\"), t[Symbol.asyncIterator] = function () {\n        return this;\n      }, t);\n      function s(n) {\n        t[n] = e[n] && function (u) {\n          return new Promise(function (i, l) {\n            u = e[n](u), a(i, l, u.done, u.value);\n          });\n        };\n      }\n      function a(n, u, i, l) {\n        Promise.resolve(l).then(function (p) {\n          n({\n            value: p,\n            done: i\n          });\n        }, u);\n      }\n    }\n    function mm(e, r) {\n      return Object.defineProperty ? Object.defineProperty(e, \"raw\", {\n        value: r\n      }) : e.raw = r, e;\n    }\n    function dm(e) {\n      if (e && e.__esModule) return e;\n      var r = {};\n      if (e != null) for (var t in e) Object.hasOwnProperty.call(e, t) && (r[t] = e[t]);\n      return r.default = e, r;\n    }\n    function gm(e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    }\n    function ym(e, r) {\n      if (!r.has(e)) throw new TypeError(\"attempted to get private field on non-instance\");\n      return r.get(e);\n    }\n    function hm(e, r, t) {\n      if (!r.has(e)) throw new TypeError(\"attempted to set private field on non-instance\");\n      return r.set(e, t), t;\n    }\n    var Br,\n      Nr,\n      Et = ht({\n        \"node_modules/tslib/tslib.es6.js\"() {\n          ne(), Br = function (e, r) {\n            return Br = Object.setPrototypeOf || {\n              __proto__: []\n            } instanceof Array && function (t, s) {\n              t.__proto__ = s;\n            } || function (t, s) {\n              for (var a in s) s.hasOwnProperty(a) && (t[a] = s[a]);\n            }, Br(e, r);\n          }, Nr = function () {\n            return Nr = Object.assign || function (r) {\n              for (var t, s = 1, a = arguments.length; s < a; s++) {\n                t = arguments[s];\n                for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);\n              }\n              return r;\n            }, Nr.apply(this, arguments);\n          };\n        }\n      }),\n      Za = te({\n        \"node_modules/vnopts/lib/descriptors/api.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.apiDescriptor = {\n            key: r => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r),\n            value(r) {\n              if (r === null || typeof r != \"object\") return JSON.stringify(r);\n              if (Array.isArray(r)) return `[${r.map(s => e.apiDescriptor.value(s)).join(\", \")}]`;\n              let t = Object.keys(r);\n              return t.length === 0 ? \"{}\" : `{ ${t.map(s => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(\", \")} }`;\n            },\n            pair: r => {\n              let {\n                key: t,\n                value: s\n              } = r;\n              return e.apiDescriptor.value({\n                [t]: s\n              });\n            }\n          };\n        }\n      }),\n      vm = te({\n        \"node_modules/vnopts/lib/descriptors/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = (Et(), ft(vt));\n          r.__exportStar(Za(), e);\n        }\n      }),\n      kr = te({\n        \"scripts/build/shims/chalk.cjs\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = s => s;\n          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;\n        }\n      }),\n      eo = te({\n        \"node_modules/vnopts/lib/handlers/deprecated/common.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = kr();\n          e.commonDeprecatedHandler = (t, s, a) => {\n            let {\n                descriptor: n\n              } = a,\n              u = [`${r.default.yellow(typeof t == \"string\" ? n.key(t) : n.pair(t))} is deprecated`];\n            return s && u.push(`we now treat it as ${r.default.blue(typeof s == \"string\" ? n.key(s) : n.pair(s))}`), u.join(\"; \") + \".\";\n          };\n        }\n      }),\n      Cm = te({\n        \"node_modules/vnopts/lib/handlers/deprecated/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = (Et(), ft(vt));\n          r.__exportStar(eo(), e);\n        }\n      }),\n      Em = te({\n        \"node_modules/vnopts/lib/handlers/invalid/common.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = kr();\n          e.commonInvalidHandler = (t, s, a) => [`Invalid ${r.default.red(a.descriptor.key(t))} value.`, `Expected ${r.default.blue(a.schemas[t].expected(a))},`, `but received ${r.default.red(a.descriptor.value(s))}.`].join(\" \");\n        }\n      }),\n      to = te({\n        \"node_modules/vnopts/lib/handlers/invalid/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = (Et(), ft(vt));\n          r.__exportStar(Em(), e);\n        }\n      }),\n      Fm = te({\n        \"node_modules/vnopts/node_modules/leven/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = [],\n            s = [];\n          r.exports = function (a, n) {\n            if (a === n) return 0;\n            var u = a;\n            a.length > n.length && (a = n, n = u);\n            var i = a.length,\n              l = n.length;\n            if (i === 0) return l;\n            if (l === 0) return i;\n            for (; i > 0 && a.charCodeAt(~-i) === n.charCodeAt(~-l);) i--, l--;\n            if (i === 0) return l;\n            for (var p = 0; p < i && a.charCodeAt(p) === n.charCodeAt(p);) p++;\n            if (i -= p, l -= p, i === 0) return l;\n            for (var y, h, g, c, f = 0, F = 0; f < i;) s[p + f] = a.charCodeAt(p + f), t[f] = ++f;\n            for (; F < l;) for (y = n.charCodeAt(p + F), g = F++, h = F, f = 0; f < i; f++) c = y === s[p + f] ? g : g + 1, g = t[f], h = t[f] = g > h ? c > h ? h + 1 : c : c > g ? g + 1 : c;\n            return h;\n          };\n        }\n      }),\n      ro = te({\n        \"node_modules/vnopts/lib/handlers/unknown/leven.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = kr(),\n            t = Fm();\n          e.levenUnknownHandler = (s, a, n) => {\n            let {\n                descriptor: u,\n                logger: i,\n                schemas: l\n              } = n,\n              p = [`Ignored unknown option ${r.default.yellow(u.pair({\n                key: s,\n                value: a\n              }))}.`],\n              y = Object.keys(l).sort().find(h => t(s, h) < 3);\n            y && p.push(`Did you mean ${r.default.blue(u.key(y))}?`), i.warn(p.join(\" \"));\n          };\n        }\n      }),\n      Am = te({\n        \"node_modules/vnopts/lib/handlers/unknown/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = (Et(), ft(vt));\n          r.__exportStar(ro(), e);\n        }\n      }),\n      Sm = te({\n        \"node_modules/vnopts/lib/handlers/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = (Et(), ft(vt));\n          r.__exportStar(Cm(), e), r.__exportStar(to(), e), r.__exportStar(Am(), e);\n        }\n      }),\n      Ft = te({\n        \"node_modules/vnopts/lib/schema.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = [\"default\", \"expected\", \"validate\", \"deprecated\", \"forward\", \"redirect\", \"overlap\", \"preprocess\", \"postprocess\"];\n          function t(n, u) {\n            let i = new n(u),\n              l = Object.create(i);\n            for (let p of r) p in u && (l[p] = a(u[p], i, s.prototype[p].length));\n            return l;\n          }\n          e.createSchema = t;\n          var s = class {\n            constructor(n) {\n              this.name = n.name;\n            }\n            static create(n) {\n              return t(this, n);\n            }\n            default(n) {}\n            expected(n) {\n              return \"nothing\";\n            }\n            validate(n, u) {\n              return !1;\n            }\n            deprecated(n, u) {\n              return !1;\n            }\n            forward(n, u) {}\n            redirect(n, u) {}\n            overlap(n, u, i) {\n              return n;\n            }\n            preprocess(n, u) {\n              return n;\n            }\n            postprocess(n, u) {\n              return n;\n            }\n          };\n          e.Schema = s;\n          function a(n, u, i) {\n            return typeof n == \"function\" ? function () {\n              for (var l = arguments.length, p = new Array(l), y = 0; y < l; y++) p[y] = arguments[y];\n              return n(...p.slice(0, i - 1), u, ...p.slice(i - 1));\n            } : () => n;\n          }\n        }\n      }),\n      xm = te({\n        \"node_modules/vnopts/lib/schemas/alias.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Ft(),\n            t = class extends r.Schema {\n              constructor(s) {\n                super(s), this._sourceName = s.sourceName;\n              }\n              expected(s) {\n                return s.schemas[this._sourceName].expected(s);\n              }\n              validate(s, a) {\n                return a.schemas[this._sourceName].validate(s, a);\n              }\n              redirect(s, a) {\n                return this._sourceName;\n              }\n            };\n          e.AliasSchema = t;\n        }\n      }),\n      bm = te({\n        \"node_modules/vnopts/lib/schemas/any.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Ft(),\n            t = class extends r.Schema {\n              expected() {\n                return \"anything\";\n              }\n              validate() {\n                return !0;\n              }\n            };\n          e.AnySchema = t;\n        }\n      }),\n      Tm = te({\n        \"node_modules/vnopts/lib/schemas/array.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = (Et(), ft(vt)),\n            t = Ft(),\n            s = class extends t.Schema {\n              constructor(n) {\n                var {\n                    valueSchema: u,\n                    name: i = u.name\n                  } = n,\n                  l = r.__rest(n, [\"valueSchema\", \"name\"]);\n                super(Object.assign({}, l, {\n                  name: i\n                })), this._valueSchema = u;\n              }\n              expected(n) {\n                return `an array of ${this._valueSchema.expected(n)}`;\n              }\n              validate(n, u) {\n                if (!Array.isArray(n)) return !1;\n                let i = [];\n                for (let l of n) {\n                  let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);\n                  p !== !0 && i.push(p.value);\n                }\n                return i.length === 0 ? !0 : {\n                  value: i\n                };\n              }\n              deprecated(n, u) {\n                let i = [];\n                for (let l of n) {\n                  let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);\n                  p !== !1 && i.push(...p.map(y => {\n                    let {\n                      value: h\n                    } = y;\n                    return {\n                      value: [h]\n                    };\n                  }));\n                }\n                return i;\n              }\n              forward(n, u) {\n                let i = [];\n                for (let l of n) {\n                  let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);\n                  i.push(...p.map(a));\n                }\n                return i;\n              }\n              redirect(n, u) {\n                let i = [],\n                  l = [];\n                for (let p of n) {\n                  let y = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);\n                  \"remain\" in y && i.push(y.remain), l.push(...y.redirect.map(a));\n                }\n                return i.length === 0 ? {\n                  redirect: l\n                } : {\n                  redirect: l,\n                  remain: i\n                };\n              }\n              overlap(n, u) {\n                return n.concat(u);\n              }\n            };\n          e.ArraySchema = s;\n          function a(n) {\n            let {\n              from: u,\n              to: i\n            } = n;\n            return {\n              from: [u],\n              to: i\n            };\n          }\n        }\n      }),\n      Bm = te({\n        \"node_modules/vnopts/lib/schemas/boolean.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Ft(),\n            t = class extends r.Schema {\n              expected() {\n                return \"true or false\";\n              }\n              validate(s) {\n                return typeof s == \"boolean\";\n              }\n            };\n          e.BooleanSchema = t;\n        }\n      }),\n      eu = te({\n        \"node_modules/vnopts/lib/utils.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          function r(c, f) {\n            let F = Object.create(null);\n            for (let _ of c) {\n              let w = _[f];\n              if (F[w]) throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);\n              F[w] = _;\n            }\n            return F;\n          }\n          e.recordFromArray = r;\n          function t(c, f) {\n            let F = new Map();\n            for (let _ of c) {\n              let w = _[f];\n              if (F.has(w)) throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);\n              F.set(w, _);\n            }\n            return F;\n          }\n          e.mapFromArray = t;\n          function s() {\n            let c = Object.create(null);\n            return f => {\n              let F = JSON.stringify(f);\n              return c[F] ? !0 : (c[F] = !0, !1);\n            };\n          }\n          e.createAutoChecklist = s;\n          function a(c, f) {\n            let F = [],\n              _ = [];\n            for (let w of c) f(w) ? F.push(w) : _.push(w);\n            return [F, _];\n          }\n          e.partition = a;\n          function n(c) {\n            return c === Math.floor(c);\n          }\n          e.isInt = n;\n          function u(c, f) {\n            if (c === f) return 0;\n            let F = typeof c,\n              _ = typeof f,\n              w = [\"undefined\", \"object\", \"boolean\", \"number\", \"string\"];\n            return F !== _ ? w.indexOf(F) - w.indexOf(_) : F !== \"string\" ? Number(c) - Number(f) : c.localeCompare(f);\n          }\n          e.comparePrimitive = u;\n          function i(c) {\n            return c === void 0 ? {} : c;\n          }\n          e.normalizeDefaultResult = i;\n          function l(c, f) {\n            return c === !0 ? !0 : c === !1 ? {\n              value: f\n            } : c;\n          }\n          e.normalizeValidateResult = l;\n          function p(c, f) {\n            let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n            return c === !1 ? !1 : c === !0 ? F ? !0 : [{\n              value: f\n            }] : \"value\" in c ? [c] : c.length === 0 ? !1 : c;\n          }\n          e.normalizeDeprecatedResult = p;\n          function y(c, f) {\n            return typeof c == \"string\" || \"key\" in c ? {\n              from: f,\n              to: c\n            } : \"from\" in c ? {\n              from: c.from,\n              to: c.to\n            } : {\n              from: f,\n              to: c.to\n            };\n          }\n          e.normalizeTransferResult = y;\n          function h(c, f) {\n            return c === void 0 ? [] : Array.isArray(c) ? c.map(F => y(F, f)) : [y(c, f)];\n          }\n          e.normalizeForwardResult = h;\n          function g(c, f) {\n            let F = h(typeof c == \"object\" && \"redirect\" in c ? c.redirect : c, f);\n            return F.length === 0 ? {\n              remain: f,\n              redirect: F\n            } : typeof c == \"object\" && \"remain\" in c ? {\n              remain: c.remain,\n              redirect: F\n            } : {\n              redirect: F\n            };\n          }\n          e.normalizeRedirectResult = g;\n        }\n      }),\n      Nm = te({\n        \"node_modules/vnopts/lib/schemas/choice.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Ft(),\n            t = eu(),\n            s = class extends r.Schema {\n              constructor(a) {\n                super(a), this._choices = t.mapFromArray(a.choices.map(n => n && typeof n == \"object\" ? n : {\n                  value: n\n                }), \"value\");\n              }\n              expected(a) {\n                let {\n                    descriptor: n\n                  } = a,\n                  u = Array.from(this._choices.keys()).map(p => this._choices.get(p)).filter(p => !p.deprecated).map(p => p.value).sort(t.comparePrimitive).map(n.value),\n                  i = u.slice(0, -2),\n                  l = u.slice(-2);\n                return i.concat(l.join(\" or \")).join(\", \");\n              }\n              validate(a) {\n                return this._choices.has(a);\n              }\n              deprecated(a) {\n                let n = this._choices.get(a);\n                return n && n.deprecated ? {\n                  value: a\n                } : !1;\n              }\n              forward(a) {\n                let n = this._choices.get(a);\n                return n ? n.forward : void 0;\n              }\n              redirect(a) {\n                let n = this._choices.get(a);\n                return n ? n.redirect : void 0;\n              }\n            };\n          e.ChoiceSchema = s;\n        }\n      }),\n      no = te({\n        \"node_modules/vnopts/lib/schemas/number.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Ft(),\n            t = class extends r.Schema {\n              expected() {\n                return \"a number\";\n              }\n              validate(s, a) {\n                return typeof s == \"number\";\n              }\n            };\n          e.NumberSchema = t;\n        }\n      }),\n      wm = te({\n        \"node_modules/vnopts/lib/schemas/integer.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = eu(),\n            t = no(),\n            s = class extends t.NumberSchema {\n              expected() {\n                return \"an integer\";\n              }\n              validate(a, n) {\n                return n.normalizeValidateResult(super.validate(a, n), a) === !0 && r.isInt(a);\n              }\n            };\n          e.IntegerSchema = s;\n        }\n      }),\n      _m = te({\n        \"node_modules/vnopts/lib/schemas/string.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Ft(),\n            t = class extends r.Schema {\n              expected() {\n                return \"a string\";\n              }\n              validate(s) {\n                return typeof s == \"string\";\n              }\n            };\n          e.StringSchema = t;\n        }\n      }),\n      Pm = te({\n        \"node_modules/vnopts/lib/schemas/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = (Et(), ft(vt));\n          r.__exportStar(xm(), e), r.__exportStar(bm(), e), r.__exportStar(Tm(), e), r.__exportStar(Bm(), e), r.__exportStar(Nm(), e), r.__exportStar(wm(), e), r.__exportStar(no(), e), r.__exportStar(_m(), e);\n        }\n      }),\n      Im = te({\n        \"node_modules/vnopts/lib/defaults.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Za(),\n            t = eo(),\n            s = to(),\n            a = ro();\n          e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;\n        }\n      }),\n      km = te({\n        \"node_modules/vnopts/lib/normalize.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Im(),\n            t = eu();\n          e.normalize = (a, n, u) => new s(n, u).normalize(a);\n          var s = class {\n            constructor(a, n) {\n              let {\n                logger: u = console,\n                descriptor: i = r.defaultDescriptor,\n                unknown: l = r.defaultUnknownHandler,\n                invalid: p = r.defaultInvalidHandler,\n                deprecated: y = r.defaultDeprecatedHandler\n              } = n || {};\n              this._utils = {\n                descriptor: i,\n                logger: u || {\n                  warn: () => {}\n                },\n                schemas: t.recordFromArray(a, \"name\"),\n                normalizeDefaultResult: t.normalizeDefaultResult,\n                normalizeDeprecatedResult: t.normalizeDeprecatedResult,\n                normalizeForwardResult: t.normalizeForwardResult,\n                normalizeRedirectResult: t.normalizeRedirectResult,\n                normalizeValidateResult: t.normalizeValidateResult\n              }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = y, this.cleanHistory();\n            }\n            cleanHistory() {\n              this._hasDeprecationWarned = t.createAutoChecklist();\n            }\n            normalize(a) {\n              let n = {},\n                u = [a],\n                i = () => {\n                  for (; u.length !== 0;) {\n                    let l = u.shift(),\n                      p = this._applyNormalization(l, n);\n                    u.push(...p);\n                  }\n                };\n              i();\n              for (let l of Object.keys(this._utils.schemas)) {\n                let p = this._utils.schemas[l];\n                if (!(l in n)) {\n                  let y = t.normalizeDefaultResult(p.default(this._utils));\n                  \"value\" in y && u.push({\n                    [l]: y.value\n                  });\n                }\n              }\n              i();\n              for (let l of Object.keys(this._utils.schemas)) {\n                let p = this._utils.schemas[l];\n                l in n && (n[l] = p.postprocess(n[l], this._utils));\n              }\n              return n;\n            }\n            _applyNormalization(a, n) {\n              let u = [],\n                [i, l] = t.partition(Object.keys(a), p => p in this._utils.schemas);\n              for (let p of i) {\n                let y = this._utils.schemas[p],\n                  h = y.preprocess(a[p], this._utils),\n                  g = t.normalizeValidateResult(y.validate(h, this._utils), h);\n                if (g !== !0) {\n                  let {\n                      value: w\n                    } = g,\n                    E = this._invalidHandler(p, w, this._utils);\n                  throw typeof E == \"string\" ? new Error(E) : E;\n                }\n                let c = w => {\n                    let {\n                      from: E,\n                      to: N\n                    } = w;\n                    u.push(typeof N == \"string\" ? {\n                      [N]: E\n                    } : {\n                      [N.key]: N.value\n                    });\n                  },\n                  f = w => {\n                    let {\n                        value: E,\n                        redirectTo: N\n                      } = w,\n                      x = t.normalizeDeprecatedResult(y.deprecated(E, this._utils), h, !0);\n                    if (x !== !1) if (x === !0) this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N, this._utils));else for (let {\n                      value: I\n                    } of x) {\n                      let P = {\n                        key: p,\n                        value: I\n                      };\n                      if (!this._hasDeprecationWarned(P)) {\n                        let $ = typeof N == \"string\" ? {\n                          key: N,\n                          value: I\n                        } : N;\n                        this._utils.logger.warn(this._deprecatedHandler(P, $, this._utils));\n                      }\n                    }\n                  };\n                t.normalizeForwardResult(y.forward(h, this._utils), h).forEach(c);\n                let _ = t.normalizeRedirectResult(y.redirect(h, this._utils), h);\n                if (_.redirect.forEach(c), \"remain\" in _) {\n                  let w = _.remain;\n                  n[p] = p in n ? y.overlap(n[p], w, this._utils) : w, f({\n                    value: w\n                  });\n                }\n                for (let {\n                  from: w,\n                  to: E\n                } of _.redirect) f({\n                  value: w,\n                  redirectTo: E\n                });\n              }\n              for (let p of l) {\n                let y = a[p],\n                  h = this._unknownHandler(p, y, this._utils);\n                if (h) for (let g of Object.keys(h)) {\n                  let c = {\n                    [g]: h[g]\n                  };\n                  g in this._utils.schemas ? u.push(c) : Object.assign(n, c);\n                }\n              }\n              return u;\n            }\n          };\n          e.Normalizer = s;\n        }\n      }),\n      Lm = te({\n        \"node_modules/vnopts/lib/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = (Et(), ft(vt));\n          r.__exportStar(vm(), e), r.__exportStar(Sm(), e), r.__exportStar(Pm(), e), r.__exportStar(km(), e), r.__exportStar(Ft(), e);\n        }\n      }),\n      Om = te({\n        \"src/main/options-normalizer.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Lm(),\n            s = lt(),\n            a = {\n              key: g => g.length === 1 ? `-${g}` : `--${g}`,\n              value: g => t.apiDescriptor.value(g),\n              pair: g => {\n                let {\n                  key: c,\n                  value: f\n                } = g;\n                return f === !1 ? `--no-${c}` : f === !0 ? a.key(c) : f === \"\" ? `${a.key(c)} without an argument` : `${a.key(c)}=${f}`;\n              }\n            },\n            n = g => {\n              let {\n                colorsModule: c,\n                levenshteinDistance: f\n              } = g;\n              return class extends t.ChoiceSchema {\n                constructor(_) {\n                  let {\n                    name: w,\n                    flags: E\n                  } = _;\n                  super({\n                    name: w,\n                    choices: E\n                  }), this._flags = [...E].sort();\n                }\n                preprocess(_, w) {\n                  if (typeof _ == \"string\" && _.length > 0 && !this._flags.includes(_)) {\n                    let E = this._flags.find(N => f(N, _) < 3);\n                    if (E) return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`, `did you mean ${c.blue(w.descriptor.value(E))}?`].join(\" \")), E;\n                  }\n                  return _;\n                }\n                expected() {\n                  return \"a flag\";\n                }\n              };\n            },\n            u;\n          function i(g, c) {\n            let {\n                logger: f = !1,\n                isCLI: F = !1,\n                passThrough: _ = !1,\n                colorsModule: w = null,\n                levenshteinDistance: E = null\n              } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              N = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? {\n                [T]: m\n              } : void 0 : (T, m) => ({\n                [T]: m\n              }) : (T, m, C) => {\n                let o = C.schemas,\n                  {\n                    _: d\n                  } = o,\n                  v = Hn(o, vD);\n                return t.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, {\n                  schemas: v\n                }));\n              },\n              x = F ? a : t.apiDescriptor,\n              I = l(c, {\n                isCLI: F,\n                colorsModule: w,\n                levenshteinDistance: E\n              }),\n              P = new t.Normalizer(I, {\n                logger: f,\n                unknown: N,\n                descriptor: x\n              }),\n              $ = f !== !1;\n            $ && u && (P._hasDeprecationWarned = u);\n            let D = P.normalize(g);\n            return $ && (u = P._hasDeprecationWarned), F && D[\"plugin-search\"] === !1 && (D[\"plugin-search-dir\"] = !1), D;\n          }\n          function l(g, c) {\n            let {\n                isCLI: f,\n                colorsModule: F,\n                levenshteinDistance: _\n              } = c,\n              w = [];\n            f && w.push(t.AnySchema.create({\n              name: \"_\"\n            }));\n            for (let E of g) w.push(p(E, {\n              isCLI: f,\n              optionInfos: g,\n              colorsModule: F,\n              levenshteinDistance: _\n            })), E.alias && f && w.push(t.AliasSchema.create({\n              name: E.alias,\n              sourceName: E.name\n            }));\n            return w;\n          }\n          function p(g, c) {\n            let {\n                isCLI: f,\n                optionInfos: F,\n                colorsModule: _,\n                levenshteinDistance: w\n              } = c,\n              {\n                name: E\n              } = g;\n            if (E === \"plugin-search-dir\" || E === \"pluginSearchDirs\") return t.AnySchema.create({\n              name: E,\n              preprocess(P) {\n                return P === !1 || (P = Array.isArray(P) ? P : [P]), P;\n              },\n              validate(P) {\n                return P === !1 ? !0 : P.every($ => typeof $ == \"string\");\n              },\n              expected() {\n                return \"false or paths to plugin search dir\";\n              }\n            });\n            let N = {\n                name: E\n              },\n              x,\n              I = {};\n            switch (g.type) {\n              case \"int\":\n                x = t.IntegerSchema, f && (N.preprocess = Number);\n                break;\n              case \"string\":\n                x = t.StringSchema;\n                break;\n              case \"choice\":\n                x = t.ChoiceSchema, N.choices = g.choices.map(P => typeof P == \"object\" && P.redirect ? Object.assign(Object.assign({}, P), {}, {\n                  redirect: {\n                    to: {\n                      key: g.name,\n                      value: P.redirect\n                    }\n                  }\n                }) : P);\n                break;\n              case \"boolean\":\n                x = t.BooleanSchema;\n                break;\n              case \"flag\":\n                x = n({\n                  colorsModule: _,\n                  levenshteinDistance: w\n                }), N.flags = F.flatMap(P => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));\n                break;\n              case \"path\":\n                x = t.StringSchema;\n                break;\n              default:\n                throw new Error(`Unexpected type ${g.type}`);\n            }\n            if (g.exception ? N.validate = (P, $, D) => g.exception(P) || $.validate(P, D) : N.validate = (P, $, D) => P === void 0 || $.validate(P, D), g.redirect && (I.redirect = P => P ? {\n              to: {\n                key: g.redirect.option,\n                value: g.redirect.value\n              }\n            } : void 0), g.deprecated && (I.deprecated = !0), f && !g.array) {\n              let P = N.preprocess || ($ => $);\n              N.preprocess = ($, D, T) => D.preprocess(P(Array.isArray($) ? s($) : $), T);\n            }\n            return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? {\n              preprocess: P => Array.isArray(P) ? P : [P]\n            } : {}), I), {}, {\n              valueSchema: x.create(N)\n            })) : x.create(Object.assign(Object.assign({}, N), I));\n          }\n          function y(g, c, f) {\n            return i(g, c, f);\n          }\n          function h(g, c, f) {\n            return i(g, c, Object.assign({\n              isCLI: !0\n            }, f));\n          }\n          r.exports = {\n            normalizeApiOptions: y,\n            normalizeCliOptions: h\n          };\n        }\n      }),\n      ut = te({\n        \"src/language-js/loc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Kn();\n          function s(l) {\n            var p, y;\n            let h = l.range ? l.range[0] : l.start,\n              g = (p = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && p !== void 0 ? p : l.decorators;\n            return t(g) ? Math.min(s(g[0]), h) : h;\n          }\n          function a(l) {\n            return l.range ? l.range[1] : l.end;\n          }\n          function n(l, p) {\n            let y = s(l);\n            return Number.isInteger(y) && y === s(p);\n          }\n          function u(l, p) {\n            let y = a(l);\n            return Number.isInteger(y) && y === a(p);\n          }\n          function i(l, p) {\n            return n(l, p) && u(l, p);\n          }\n          r.exports = {\n            locStart: s,\n            locEnd: a,\n            hasSameLocStart: n,\n            hasSameLoc: i\n          };\n        }\n      }),\n      jm = te({\n        \"src/main/load-parser.js\"(e, r) {\n          ne(), r.exports = () => {};\n        }\n      }),\n      qm = te({\n        \"scripts/build/shims/babel-highlight.cjs\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = kr(),\n            s = {\n              shouldHighlight: () => !1,\n              getChalk: () => t\n            };\n          r.exports = s;\n        }\n      }),\n      Mm = te({\n        \"node_modules/@babel/code-frame/lib/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.codeFrameColumns = u, e.default = i;\n          var r = qm(),\n            t = !1;\n          function s(l) {\n            return {\n              gutter: l.grey,\n              marker: l.red.bold,\n              message: l.red.bold\n            };\n          }\n          var a = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n          function n(l, p, y) {\n            let h = Object.assign({\n                column: 0,\n                line: -1\n              }, l.start),\n              g = Object.assign({}, h, l.end),\n              {\n                linesAbove: c = 2,\n                linesBelow: f = 3\n              } = y || {},\n              F = h.line,\n              _ = h.column,\n              w = g.line,\n              E = g.column,\n              N = Math.max(F - (c + 1), 0),\n              x = Math.min(p.length, w + f);\n            F === -1 && (N = 0), w === -1 && (x = p.length);\n            let I = w - F,\n              P = {};\n            if (I) for (let $ = 0; $ <= I; $++) {\n              let D = $ + F;\n              if (!_) P[D] = !0;else if ($ === 0) {\n                let T = p[D - 1].length;\n                P[D] = [_, T - _ + 1];\n              } else if ($ === I) P[D] = [0, E];else {\n                let T = p[D - $].length;\n                P[D] = [0, T];\n              }\n            } else _ === E ? _ ? P[F] = [_, 0] : P[F] = !0 : P[F] = [_, E - _];\n            return {\n              start: N,\n              end: x,\n              markerLines: P\n            };\n          }\n          function u(l, p) {\n            let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              h = (y.highlightCode || y.forceColor) && (0, r.shouldHighlight)(y),\n              g = (0, r.getChalk)(y),\n              c = s(g),\n              f = ($, D) => h ? $(D) : D,\n              F = l.split(a),\n              {\n                start: _,\n                end: w,\n                markerLines: E\n              } = n(p, F, y),\n              N = p.start && typeof p.start.column == \"number\",\n              x = String(w).length,\n              P = (h ? (0, r.default)(l, y) : l).split(a, w).slice(_, w).map(($, D) => {\n                let T = _ + 1 + D,\n                  C = ` ${` ${T}`.slice(-x)} |`,\n                  o = E[T],\n                  d = !E[T + 1];\n                if (o) {\n                  let v = \"\";\n                  if (Array.isArray(o)) {\n                    let S = $.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\\t]/g, \" \"),\n                      b = o[1] || 1;\n                    v = [`\n `, f(c.gutter, C.replace(/\\d/g, \" \")), \" \", S, f(c.marker, \"^\").repeat(b)].join(\"\"), d && y.message && (v += \" \" + f(c.message, y.message));\n                  }\n                  return [f(c.marker, \">\"), f(c.gutter, C), $.length > 0 ? ` ${$}` : \"\", v].join(\"\");\n                } else return ` ${f(c.gutter, C)}${$.length > 0 ? ` ${$}` : \"\"}`;\n              }).join(`\n`);\n            return y.message && !N && (P = `${\" \".repeat(x + 1)}${y.message}\n${P}`), h ? g.reset(P) : P;\n          }\n          function i(l, p, y) {\n            let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n            if (!t) {\n              t = !0;\n              let c = \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n              if (wt.emitWarning) wt.emitWarning(c, \"DeprecationWarning\");else {\n                let f = new Error(c);\n                f.name = \"DeprecationWarning\", console.warn(new Error(c));\n              }\n            }\n            return y = Math.max(y, 0), u(l, {\n              start: {\n                column: y,\n                line: p\n              }\n            }, h);\n          }\n        }\n      }),\n      tu = te({\n        \"src/main/parser.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              ConfigError: t\n            } = Qt(),\n            s = ut(),\n            a = jm(),\n            {\n              locStart: n,\n              locEnd: u\n            } = s,\n            i = Object.getOwnPropertyNames,\n            l = Object.getOwnPropertyDescriptor;\n          function p(g) {\n            let c = {};\n            for (let f of g.plugins) if (f.parsers) for (let F of i(f.parsers)) Object.defineProperty(c, F, l(f.parsers, F));\n            return c;\n          }\n          function y(g) {\n            let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g);\n            if (typeof g.parser == \"function\") return {\n              parse: g.parser,\n              astFormat: \"estree\",\n              locStart: n,\n              locEnd: u\n            };\n            if (typeof g.parser == \"string\") {\n              if (Object.prototype.hasOwnProperty.call(c, g.parser)) return c[g.parser];\n              throw new t(`Couldn't resolve parser \"${g.parser}\". Parsers must be explicitly added to the standalone bundle.`);\n            }\n          }\n          function h(g, c) {\n            let f = p(c),\n              F = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map(w => [w, {\n                enumerable: !0,\n                get() {\n                  return f[w].parse;\n                }\n              }]))),\n              _ = y(c, f);\n            try {\n              return _.preprocess && (g = _.preprocess(g, c)), {\n                text: g,\n                ast: _.parse(g, F, c)\n              };\n            } catch (w) {\n              let {\n                loc: E\n              } = w;\n              if (E) {\n                let {\n                  codeFrameColumns: N\n                } = Mm();\n                throw w.codeFrame = N(g, E, {\n                  highlightCode: !0\n                }), w.message += `\n` + w.codeFrame, w;\n              }\n              throw w;\n            }\n          }\n          r.exports = {\n            parse: h,\n            resolveParser: y\n          };\n        }\n      }),\n      uo = te({\n        \"src/main/options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = ZD(),\n            {\n              UndefinedParserError: s\n            } = Qt(),\n            {\n              getSupportInfo: a\n            } = Xn(),\n            n = Om(),\n            {\n              resolveParser: u\n            } = tu(),\n            i = {\n              astFormat: \"estree\",\n              printer: {},\n              originalText: void 0,\n              locStart: null,\n              locEnd: null\n            };\n          function l(h) {\n            let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n              c = Object.assign({}, h),\n              f = a({\n                plugins: h.plugins,\n                showUnreleased: !0,\n                showDeprecated: !0\n              }).options,\n              F = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter(x => x.default !== void 0).map(x => [x.name, x.default])));\n            if (!c.parser) {\n              if (!c.filepath) (g.logger || console).warn(\"No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.\"), c.parser = \"babel\";else if (c.parser = y(c.filepath, c.plugins), !c.parser) throw new s(`No parser could be inferred for file: ${c.filepath}`);\n            }\n            let _ = u(n.normalizeApiOptions(c, [f.find(x => x.name === \"parser\")], {\n              passThrough: !0,\n              logger: !1\n            }));\n            c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;\n            let w = p(c);\n            c.printer = w.printers[c.astFormat];\n            let E = Object.fromEntries(f.filter(x => x.pluginDefaults && x.pluginDefaults[w.name] !== void 0).map(x => [x.name, x.pluginDefaults[w.name]])),\n              N = Object.assign(Object.assign({}, F), E);\n            for (let [x, I] of Object.entries(N)) (c[x] === null || c[x] === void 0) && (c[x] = I);\n            return c.parser === \"json\" && (c.trailingComma = \"none\"), n.normalizeApiOptions(c, f, Object.assign({\n              passThrough: Object.keys(i)\n            }, g));\n          }\n          function p(h) {\n            let {\n              astFormat: g\n            } = h;\n            if (!g) throw new Error(\"getPlugin() requires astFormat to be set\");\n            let c = h.plugins.find(f => f.printers && f.printers[g]);\n            if (!c) throw new Error(`Couldn't find plugin for AST format \"${g}\"`);\n            return c;\n          }\n          function y(h, g) {\n            let c = t.basename(h).toLowerCase(),\n              F = a({\n                plugins: g\n              }).languages.filter(_ => _.since !== null).find(_ => _.extensions && _.extensions.some(w => c.endsWith(w)) || _.filenames && _.filenames.some(w => w.toLowerCase() === c));\n            return F && F.parsers[0];\n          }\n          r.exports = {\n            normalize: l,\n            hiddenDefaults: i,\n            inferParser: y\n          };\n        }\n      }),\n      Rm = te({\n        \"src/main/massage-ast.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s, a, n) {\n            if (Array.isArray(s)) return s.map(p => t(p, a, n)).filter(Boolean);\n            if (!s || typeof s != \"object\") return s;\n            let u = a.printer.massageAstNode,\n              i;\n            u && u.ignoredProperties ? i = u.ignoredProperties : i = new Set();\n            let l = {};\n            for (let [p, y] of Object.entries(s)) !i.has(p) && typeof y != \"function\" && (l[p] = t(y, a, s));\n            if (u) {\n              let p = u(s, l, n);\n              if (p === null) return;\n              if (p) return p;\n            }\n            return l;\n          }\n          r.exports = t;\n        }\n      }),\n      Zt = te({\n        \"scripts/build/shims/assert.cjs\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = () => {};\n          t.ok = t, t.strictEqual = t, r.exports = t;\n        }\n      }),\n      et = te({\n        \"src/main/comments.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Zt(),\n            {\n              builders: {\n                line: s,\n                hardline: a,\n                breakParent: n,\n                indent: u,\n                lineSuffix: i,\n                join: l,\n                cursor: p\n              }\n            } = qe(),\n            {\n              hasNewline: y,\n              skipNewline: h,\n              skipSpaces: g,\n              isPreviousLineEmpty: c,\n              addLeadingComment: f,\n              addDanglingComment: F,\n              addTrailingComment: _\n            } = Ue(),\n            w = new WeakMap();\n          function E(k, M, R) {\n            if (!k) return;\n            let {\n              printer: q,\n              locStart: J,\n              locEnd: L\n            } = M;\n            if (R) {\n              if (q.canAttachComment && q.canAttachComment(k)) {\n                let V;\n                for (V = R.length - 1; V >= 0 && !(J(R[V]) <= J(k) && L(R[V]) <= L(k)); --V);\n                R.splice(V + 1, 0, k);\n                return;\n              }\n            } else if (w.has(k)) return w.get(k);\n            let Q = q.getCommentChildNodes && q.getCommentChildNodes(k, M) || typeof k == \"object\" && Object.entries(k).filter(V => {\n              let [j] = V;\n              return j !== \"enclosingNode\" && j !== \"precedingNode\" && j !== \"followingNode\" && j !== \"tokens\" && j !== \"comments\" && j !== \"parent\";\n            }).map(V => {\n              let [, j] = V;\n              return j;\n            });\n            if (Q) {\n              R || (R = [], w.set(k, R));\n              for (let V of Q) E(V, M, R);\n              return R;\n            }\n          }\n          function N(k, M, R, q) {\n            let {\n                locStart: J,\n                locEnd: L\n              } = R,\n              Q = J(M),\n              V = L(M),\n              j = E(k, R),\n              Y,\n              ie,\n              ee = 0,\n              ce = j.length;\n            for (; ee < ce;) {\n              let W = ee + ce >> 1,\n                K = j[W],\n                de = J(K),\n                ue = L(K);\n              if (de <= Q && V <= ue) return N(K, M, R, K);\n              if (ue <= Q) {\n                Y = K, ee = W + 1;\n                continue;\n              }\n              if (V <= de) {\n                ie = K, ce = W;\n                continue;\n              }\n              throw new Error(\"Comment location overlaps with node location\");\n            }\n            if (q && q.type === \"TemplateLiteral\") {\n              let {\n                  quasis: W\n                } = q,\n                K = C(W, M, R);\n              Y && C(W, Y, R) !== K && (Y = null), ie && C(W, ie, R) !== K && (ie = null);\n            }\n            return {\n              enclosingNode: q,\n              precedingNode: Y,\n              followingNode: ie\n            };\n          }\n          var x = () => !1;\n          function I(k, M, R, q) {\n            if (!Array.isArray(k)) return;\n            let J = [],\n              {\n                locStart: L,\n                locEnd: Q,\n                printer: {\n                  handleComments: V = {}\n                }\n              } = q,\n              {\n                avoidAstMutation: j,\n                ownLine: Y = x,\n                endOfLine: ie = x,\n                remaining: ee = x\n              } = V,\n              ce = k.map((W, K) => Object.assign(Object.assign({}, N(M, W, q)), {}, {\n                comment: W,\n                text: R,\n                options: q,\n                ast: M,\n                isLastComment: k.length - 1 === K\n              }));\n            for (let [W, K] of ce.entries()) {\n              let {\n                comment: de,\n                precedingNode: ue,\n                enclosingNode: Fe,\n                followingNode: z,\n                text: U,\n                options: Z,\n                ast: se,\n                isLastComment: fe\n              } = K;\n              if (Z.parser === \"json\" || Z.parser === \"json5\" || Z.parser === \"__js_expression\" || Z.parser === \"__vue_expression\" || Z.parser === \"__vue_ts_expression\") {\n                if (L(de) - L(se) <= 0) {\n                  f(se, de);\n                  continue;\n                }\n                if (Q(de) - Q(se) >= 0) {\n                  _(se, de);\n                  continue;\n                }\n              }\n              let ge;\n              if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U, Z, se, fe]), $(U, Z, ce, W)) de.placement = \"ownLine\", Y(...ge) || (z ? f(z, de) : ue ? _(ue, de) : F(Fe || se, de));else if (D(U, Z, ce, W)) de.placement = \"endOfLine\", ie(...ge) || (ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de));else if (de.placement = \"remaining\", !ee(...ge)) if (ue && z) {\n                let he = J.length;\n                he > 0 && J[he - 1].followingNode !== z && T(J, U, Z), J.push(K);\n              } else ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de);\n            }\n            if (T(J, R, q), !j) for (let W of k) delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;\n          }\n          var P = k => !/[\\S\\n\\u2028\\u2029]/.test(k);\n          function $(k, M, R, q) {\n            let {\n                comment: J,\n                precedingNode: L\n              } = R[q],\n              {\n                locStart: Q,\n                locEnd: V\n              } = M,\n              j = Q(J);\n            if (L) for (let Y = q - 1; Y >= 0; Y--) {\n              let {\n                comment: ie,\n                precedingNode: ee\n              } = R[Y];\n              if (ee !== L || !P(k.slice(V(ie), j))) break;\n              j = Q(ie);\n            }\n            return y(k, j, {\n              backwards: !0\n            });\n          }\n          function D(k, M, R, q) {\n            let {\n                comment: J,\n                followingNode: L\n              } = R[q],\n              {\n                locStart: Q,\n                locEnd: V\n              } = M,\n              j = V(J);\n            if (L) for (let Y = q + 1; Y < R.length; Y++) {\n              let {\n                comment: ie,\n                followingNode: ee\n              } = R[Y];\n              if (ee !== L || !P(k.slice(j, Q(ie)))) break;\n              j = V(ie);\n            }\n            return y(k, j);\n          }\n          function T(k, M, R) {\n            let q = k.length;\n            if (q === 0) return;\n            let {\n                precedingNode: J,\n                followingNode: L,\n                enclosingNode: Q\n              } = k[0],\n              V = R.printer.getGapRegex && R.printer.getGapRegex(Q) || /^[\\s(]*$/,\n              j = R.locStart(L),\n              Y;\n            for (Y = q; Y > 0; --Y) {\n              let {\n                comment: ie,\n                precedingNode: ee,\n                followingNode: ce\n              } = k[Y - 1];\n              t.strictEqual(ee, J), t.strictEqual(ce, L);\n              let W = M.slice(R.locEnd(ie), j);\n              if (V.test(W)) j = R.locStart(ie);else break;\n            }\n            for (let [ie, {\n              comment: ee\n            }] of k.entries()) ie < Y ? _(J, ee) : f(L, ee);\n            for (let ie of [J, L]) ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R.locStart(ee) - R.locStart(ce));\n            k.length = 0;\n          }\n          function m(k, M) {\n            let R = k.getValue();\n            return R.printed = !0, M.printer.printComment(k, M);\n          }\n          function C(k, M, R) {\n            let q = R.locStart(M) - 1;\n            for (let J = 1; J < k.length; ++J) if (q < R.locStart(k[J])) return J - 1;\n            return 0;\n          }\n          function o(k, M) {\n            let R = k.getValue(),\n              q = [m(k, M)],\n              {\n                printer: J,\n                originalText: L,\n                locStart: Q,\n                locEnd: V\n              } = M;\n            if (J.isBlockComment && J.isBlockComment(R)) {\n              let ie = y(L, V(R)) ? y(L, Q(R), {\n                backwards: !0\n              }) ? a : s : \" \";\n              q.push(ie);\n            } else q.push(a);\n            let Y = h(L, g(L, V(R)));\n            return Y !== !1 && y(L, Y) && q.push(a), q;\n          }\n          function d(k, M) {\n            let R = k.getValue(),\n              q = m(k, M),\n              {\n                printer: J,\n                originalText: L,\n                locStart: Q\n              } = M,\n              V = J.isBlockComment && J.isBlockComment(R);\n            if (y(L, Q(R), {\n              backwards: !0\n            })) {\n              let Y = c(L, R, Q);\n              return i([a, Y ? a : \"\", q]);\n            }\n            let j = [\" \", q];\n            return V || (j = [i(j), n]), j;\n          }\n          function v(k, M, R, q) {\n            let J = [],\n              L = k.getValue();\n            return !L || !L.comments || (k.each(() => {\n              let Q = k.getValue();\n              !Q.leading && !Q.trailing && (!q || q(Q)) && J.push(m(k, M));\n            }, \"comments\"), J.length === 0) ? \"\" : R ? l(a, J) : u([a, l(a, J)]);\n          }\n          function S(k, M, R) {\n            let q = k.getValue();\n            if (!q) return {};\n            let J = q.comments || [];\n            R && (J = J.filter(j => !R.has(j)));\n            let L = q === M.cursorNode;\n            if (J.length === 0) {\n              let j = L ? p : \"\";\n              return {\n                leading: j,\n                trailing: j\n              };\n            }\n            let Q = [],\n              V = [];\n            return k.each(() => {\n              let j = k.getValue();\n              if (R && R.has(j)) return;\n              let {\n                leading: Y,\n                trailing: ie\n              } = j;\n              Y ? Q.push(o(k, M)) : ie && V.push(d(k, M));\n            }, \"comments\"), L && (Q.unshift(p), V.push(p)), {\n              leading: Q,\n              trailing: V\n            };\n          }\n          function b(k, M, R, q) {\n            let {\n              leading: J,\n              trailing: L\n            } = S(k, R, q);\n            return !J && !L ? M : [J, M, L];\n          }\n          function B(k) {\n            if (k) for (let M of k) {\n              if (!M.printed) throw new Error('Comment \"' + M.value.trim() + '\" was not printed. Please report this error!');\n              delete M.printed;\n            }\n          }\n          r.exports = {\n            attach: I,\n            printComments: b,\n            printCommentsSeparately: S,\n            printDanglingComments: v,\n            getSortedChildNodes: E,\n            ensureAllCommentsPrinted: B\n          };\n        }\n      }),\n      $m = te({\n        \"src/common/ast-path.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = lt();\n          function s(u, i) {\n            let l = a(u.stack, i);\n            return l === -1 ? null : u.stack[l];\n          }\n          function a(u, i) {\n            for (let l = u.length - 1; l >= 0; l -= 2) {\n              let p = u[l];\n              if (p && !Array.isArray(p) && --i < 0) return l;\n            }\n            return -1;\n          }\n          var n = class {\n            constructor(u) {\n              this.stack = [u];\n            }\n            getName() {\n              let {\n                  stack: u\n                } = this,\n                {\n                  length: i\n                } = u;\n              return i > 1 ? u[i - 2] : null;\n            }\n            getValue() {\n              return t(this.stack);\n            }\n            getNode() {\n              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n              return s(this, u);\n            }\n            getParentNode() {\n              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n              return s(this, u + 1);\n            }\n            call(u) {\n              let {\n                  stack: i\n                } = this,\n                {\n                  length: l\n                } = i,\n                p = t(i);\n              for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++) h[g - 1] = arguments[g];\n              for (let f of h) p = p[f], i.push(f, p);\n              let c = u(this);\n              return i.length = l, c;\n            }\n            callParent(u) {\n              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n                l = a(this.stack, i + 1),\n                p = this.stack.splice(l + 1),\n                y = u(this);\n              return this.stack.push(...p), y;\n            }\n            each(u) {\n              let {\n                  stack: i\n                } = this,\n                {\n                  length: l\n                } = i,\n                p = t(i);\n              for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++) h[g - 1] = arguments[g];\n              for (let c of h) p = p[c], i.push(c, p);\n              for (let c = 0; c < p.length; ++c) i.push(c, p[c]), u(this, c, p), i.length -= 2;\n              i.length = l;\n            }\n            map(u) {\n              let i = [];\n              for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++) p[y - 1] = arguments[y];\n              return this.each((h, g, c) => {\n                i[g] = u(h, g, c);\n              }, ...p), i;\n            }\n            try(u) {\n              let {\n                  stack: i\n                } = this,\n                l = [...i];\n              try {\n                return u();\n              } finally {\n                i.length = 0, i.push(...l);\n              }\n            }\n            match() {\n              let u = this.stack.length - 1,\n                i = null,\n                l = this.stack[u--];\n              for (var p = arguments.length, y = new Array(p), h = 0; h < p; h++) y[h] = arguments[h];\n              for (let g of y) {\n                if (l === void 0) return !1;\n                let c = null;\n                if (typeof i == \"number\" && (c = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c)) return !1;\n                i = this.stack[u--], l = this.stack[u--];\n              }\n              return !0;\n            }\n            findAncestor(u) {\n              let i = this.stack.length - 1,\n                l = null,\n                p = this.stack[i--];\n              for (; p;) {\n                let y = null;\n                if (typeof l == \"number\" && (y = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, y)) return p;\n                l = this.stack[i--], p = this.stack[i--];\n              }\n            }\n          };\n          r.exports = n;\n        }\n      }),\n      Vm = te({\n        \"src/main/multiparser.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              utils: {\n                stripTrailingHardline: t\n              }\n            } = qe(),\n            {\n              normalize: s\n            } = uo(),\n            a = et();\n          function n(i, l, p, y) {\n            if (p.printer.embed && p.embeddedLanguageFormatting === \"auto\") return p.printer.embed(i, l, (h, g, c) => u(h, g, p, y, c), p);\n          }\n          function u(i, l, p, y) {\n            let {\n                stripTrailingHardline: h = !1\n              } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {},\n              g = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, {\n                parentParser: p.parser,\n                originalText: i\n              }), {\n                passThrough: !0\n              }),\n              c = tu().parse(i, g),\n              {\n                ast: f\n              } = c;\n            i = c.text;\n            let F = f.comments;\n            delete f.comments, a.attach(F, f, i, g), g[Symbol.for(\"comments\")] = F || [], g[Symbol.for(\"tokens\")] = f.tokens || [];\n            let _ = y(f, g);\n            return a.ensureAllCommentsPrinted(F), h ? typeof _ == \"string\" ? _.replace(/(?:\\r?\\n)*$/, \"\") : t(_) : _;\n          }\n          r.exports = {\n            printSubtree: n\n          };\n        }\n      }),\n      Wm = te({\n        \"src/main/ast-to-doc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = $m(),\n            {\n              builders: {\n                hardline: s,\n                addAlignmentToDoc: a\n              },\n              utils: {\n                propagateBreaks: n\n              }\n            } = qe(),\n            {\n              printComments: u\n            } = et(),\n            i = Vm();\n          function l(h, g) {\n            let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n              {\n                printer: f\n              } = g;\n            f.preprocess && (h = f.preprocess(h, g));\n            let F = new Map(),\n              _ = new t(h),\n              w = E();\n            return c > 0 && (w = a([s, w], c, g.tabWidth)), n(w), w;\n            function E(x, I) {\n              return x === void 0 || x === _ ? N(I) : Array.isArray(x) ? _.call(() => N(I), ...x) : _.call(() => N(I), x);\n            }\n            function N(x) {\n              let I = _.getValue(),\n                P = I && typeof I == \"object\" && x === void 0;\n              if (P && F.has(I)) return F.get(I);\n              let $ = y(_, g, E, x);\n              return P && F.set(I, $), $;\n            }\n          }\n          function p(h, g) {\n            let {\n                originalText: c,\n                [Symbol.for(\"comments\")]: f,\n                locStart: F,\n                locEnd: _\n              } = g,\n              w = F(h),\n              E = _(h),\n              N = new Set();\n            for (let x of f) F(x) >= w && _(x) <= E && (x.printed = !0, N.add(x));\n            return {\n              doc: c.slice(w, E),\n              printedComments: N\n            };\n          }\n          function y(h, g, c, f) {\n            let F = h.getValue(),\n              {\n                printer: _\n              } = g,\n              w,\n              E;\n            if (_.hasPrettierIgnore && _.hasPrettierIgnore(h)) ({\n              doc: w,\n              printedComments: E\n            } = p(F, g));else {\n              if (F) try {\n                w = i.printSubtree(h, c, g, l);\n              } catch (N) {\n                if (globalThis.PRETTIER_DEBUG) throw N;\n              }\n              w || (w = _.print(h, g, c, f));\n            }\n            return (!_.willPrintOwnComments || !_.willPrintOwnComments(h, g)) && (w = u(h, w, g, E)), w;\n          }\n          r.exports = l;\n        }\n      }),\n      Hm = te({\n        \"src/main/range-util.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Zt(),\n            s = et(),\n            a = f => {\n              let {\n                parser: F\n              } = f;\n              return F === \"json\" || F === \"json5\" || F === \"json-stringify\";\n            };\n          function n(f, F) {\n            let _ = [f.node, ...f.parentNodes],\n              w = new Set([F.node, ...F.parentNodes]);\n            return _.find(E => y.has(E.type) && w.has(E));\n          }\n          function u(f) {\n            let F = f.length - 1;\n            for (;;) {\n              let _ = f[F];\n              if (_ && (_.type === \"Program\" || _.type === \"File\")) F--;else break;\n            }\n            return f.slice(0, F + 1);\n          }\n          function i(f, F, _) {\n            let {\n                locStart: w,\n                locEnd: E\n              } = _,\n              N = f.node,\n              x = F.node;\n            if (N === x) return {\n              startNode: N,\n              endNode: x\n            };\n            let I = w(f.node);\n            for (let $ of u(F.parentNodes)) if (w($) >= I) x = $;else break;\n            let P = E(F.node);\n            for (let $ of u(f.parentNodes)) {\n              if (E($) <= P) N = $;else break;\n              if (N === x) break;\n            }\n            return {\n              startNode: N,\n              endNode: x\n            };\n          }\n          function l(f, F, _, w) {\n            let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [],\n              N = arguments.length > 5 ? arguments[5] : void 0,\n              {\n                locStart: x,\n                locEnd: I\n              } = _,\n              P = x(f),\n              $ = I(f);\n            if (!(F > $ || F < P || N === \"rangeEnd\" && F === P || N === \"rangeStart\" && F === $)) {\n              for (let D of s.getSortedChildNodes(f, _)) {\n                let T = l(D, F, _, w, [f, ...E], N);\n                if (T) return T;\n              }\n              if (!w || w(f, E[0])) return {\n                node: f,\n                parentNodes: E\n              };\n            }\n          }\n          function p(f, F) {\n            return F !== \"DeclareExportDeclaration\" && f !== \"TypeParameterDeclaration\" && (f === \"Directive\" || f === \"TypeAlias\" || f === \"TSExportAssignment\" || f.startsWith(\"Declare\") || f.startsWith(\"TSDeclare\") || f.endsWith(\"Statement\") || f.endsWith(\"Declaration\"));\n          }\n          var y = new Set([\"ObjectExpression\", \"ArrayExpression\", \"StringLiteral\", \"NumericLiteral\", \"BooleanLiteral\", \"NullLiteral\", \"UnaryExpression\", \"TemplateLiteral\"]),\n            h = new Set([\"OperationDefinition\", \"FragmentDefinition\", \"VariableDefinition\", \"TypeExtensionDefinition\", \"ObjectTypeDefinition\", \"FieldDefinition\", \"DirectiveDefinition\", \"EnumTypeDefinition\", \"EnumValueDefinition\", \"InputValueDefinition\", \"InputObjectTypeDefinition\", \"SchemaDefinition\", \"OperationTypeDefinition\", \"InterfaceTypeDefinition\", \"UnionTypeDefinition\", \"ScalarTypeDefinition\"]);\n          function g(f, F, _) {\n            if (!F) return !1;\n            switch (f.parser) {\n              case \"flow\":\n              case \"babel\":\n              case \"babel-flow\":\n              case \"babel-ts\":\n              case \"typescript\":\n              case \"acorn\":\n              case \"espree\":\n              case \"meriyah\":\n              case \"__babel_estree\":\n                return p(F.type, _ && _.type);\n              case \"json\":\n              case \"json5\":\n              case \"json-stringify\":\n                return y.has(F.type);\n              case \"graphql\":\n                return h.has(F.kind);\n              case \"vue\":\n                return F.tag !== \"root\";\n            }\n            return !1;\n          }\n          function c(f, F, _) {\n            let {\n              rangeStart: w,\n              rangeEnd: E,\n              locStart: N,\n              locEnd: x\n            } = F;\n            t.ok(E > w);\n            let I = f.slice(w, E).search(/\\S/),\n              P = I === -1;\n            if (!P) for (w += I; E > w && !/\\S/.test(f[E - 1]); --E);\n            let $ = l(_, w, F, (C, o) => g(F, C, o), [], \"rangeStart\"),\n              D = P ? $ : l(_, E, F, C => g(F, C), [], \"rangeEnd\");\n            if (!$ || !D) return {\n              rangeStart: 0,\n              rangeEnd: 0\n            };\n            let T, m;\n            if (a(F)) {\n              let C = n($, D);\n              T = C, m = C;\n            } else ({\n              startNode: T,\n              endNode: m\n            } = i($, D, F));\n            return {\n              rangeStart: Math.min(N(T), N(m)),\n              rangeEnd: Math.max(x(T), x(m))\n            };\n          }\n          r.exports = {\n            calculateRange: c,\n            findNodeAtOffset: l\n          };\n        }\n      }),\n      Gm = te({\n        \"src/main/core.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              diffArrays: t\n            } = BD(),\n            {\n              printer: {\n                printDocToString: s\n              },\n              debug: {\n                printDocToDebug: a\n              }\n            } = qe(),\n            {\n              getAlignmentSize: n\n            } = Ue(),\n            {\n              guessEndOfLine: u,\n              convertEndOfLineToChars: i,\n              countEndOfLineChars: l,\n              normalizeEndOfLine: p\n            } = Jn(),\n            y = uo().normalize,\n            h = Rm(),\n            g = et(),\n            c = tu(),\n            f = Wm(),\n            F = Hm(),\n            _ = \"\\uFEFF\",\n            w = Symbol(\"cursor\");\n          function E(m, C, o) {\n            let d = C.comments;\n            return d && (delete C.comments, g.attach(d, C, m, o)), o[Symbol.for(\"comments\")] = d || [], o[Symbol.for(\"tokens\")] = C.tokens || [], o.originalText = m, d;\n          }\n          function N(m, C) {\n            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n            if (!m || m.trim().length === 0) return {\n              formatted: \"\",\n              cursorOffset: -1,\n              comments: []\n            };\n            let {\n              ast: d,\n              text: v\n            } = c.parse(m, C);\n            if (C.cursorOffset >= 0) {\n              let k = F.findNodeAtOffset(d, C.cursorOffset, C);\n              k && k.node && (C.cursorNode = k.node);\n            }\n            let S = E(v, d, C),\n              b = f(d, C, o),\n              B = s(b, C);\n            if (g.ensureAllCommentsPrinted(S), o > 0) {\n              let k = B.formatted.trim();\n              B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);\n            }\n            if (C.cursorOffset >= 0) {\n              let k, M, R, q, J;\n              if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R = C.cursorOffset - k, q = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M = v, R = C.cursorOffset, q = 0, J = B.formatted), M === J) return {\n                formatted: B.formatted,\n                cursorOffset: q + R,\n                comments: S\n              };\n              let L = [...M];\n              L.splice(R, 0, w);\n              let Q = [...J],\n                V = t(L, Q),\n                j = q;\n              for (let Y of V) if (Y.removed) {\n                if (Y.value.includes(w)) break;\n              } else j += Y.count;\n              return {\n                formatted: B.formatted,\n                cursorOffset: j,\n                comments: S\n              };\n            }\n            return {\n              formatted: B.formatted,\n              cursorOffset: -1,\n              comments: S\n            };\n          }\n          function x(m, C) {\n            let {\n                ast: o,\n                text: d\n              } = c.parse(m, C),\n              {\n                rangeStart: v,\n                rangeEnd: S\n              } = F.calculateRange(d, C, o),\n              b = d.slice(v, S),\n              B = Math.min(v, d.lastIndexOf(`\n`, v) + 1),\n              k = d.slice(B, v).match(/^\\s*/)[0],\n              M = n(k, C.tabWidth),\n              R = N(b, Object.assign(Object.assign({}, C), {}, {\n                rangeStart: 0,\n                rangeEnd: Number.POSITIVE_INFINITY,\n                cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1,\n                endOfLine: \"lf\"\n              }), M),\n              q = R.formatted.trimEnd(),\n              {\n                cursorOffset: J\n              } = C;\n            J > S ? J += q.length - b.length : R.cursorOffset >= 0 && (J = R.cursorOffset + v);\n            let L = d.slice(0, v) + q + d.slice(S);\n            if (C.endOfLine !== \"lf\") {\n              let Q = i(C.endOfLine);\n              J >= 0 && Q === `\\r\n` && (J += l(L.slice(0, J), `\n`)), L = L.replace(/\\n/g, Q);\n            }\n            return {\n              formatted: L,\n              cursorOffset: J,\n              comments: R.comments\n            };\n          }\n          function I(m, C, o) {\n            return typeof C != \"number\" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;\n          }\n          function P(m, C) {\n            let {\n              cursorOffset: o,\n              rangeStart: d,\n              rangeEnd: v\n            } = C;\n            return o = I(m, o, -1), d = I(m, d, 0), v = I(m, v, m.length), Object.assign(Object.assign({}, C), {}, {\n              cursorOffset: o,\n              rangeStart: d,\n              rangeEnd: v\n            });\n          }\n          function $(m, C) {\n            let {\n                cursorOffset: o,\n                rangeStart: d,\n                rangeEnd: v,\n                endOfLine: S\n              } = P(m, C),\n              b = m.charAt(0) === _;\n            if (b && (m = m.slice(1), o--, d--, v--), S === \"auto\" && (S = u(m)), m.includes(\"\\r\")) {\n              let B = k => l(m.slice(0, Math.max(k, 0)), `\\r\n`);\n              o -= B(o), d -= B(d), v -= B(v), m = p(m);\n            }\n            return {\n              hasBOM: b,\n              text: m,\n              options: P(m, Object.assign(Object.assign({}, C), {}, {\n                cursorOffset: o,\n                rangeStart: d,\n                rangeEnd: v,\n                endOfLine: S\n              }))\n            };\n          }\n          function D(m, C) {\n            let o = c.resolveParser(C);\n            return !o.hasPragma || o.hasPragma(m);\n          }\n          function T(m, C) {\n            let {\n              hasBOM: o,\n              text: d,\n              options: v\n            } = $(m, y(C));\n            if (v.rangeStart >= v.rangeEnd && d !== \"\" || v.requirePragma && !D(d, v)) return {\n              formatted: m,\n              cursorOffset: C.cursorOffset,\n              comments: []\n            };\n            let S;\n            return v.rangeStart > 0 || v.rangeEnd < d.length ? S = x(d, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(d, v) && (d = v.printer.insertPragma(d)), S = N(d, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;\n          }\n          r.exports = {\n            formatWithCursor: T,\n            parse(m, C, o) {\n              let {\n                  text: d,\n                  options: v\n                } = $(m, y(C)),\n                S = c.parse(d, v);\n              return o && (S.ast = h(S.ast, v)), S;\n            },\n            formatAST(m, C) {\n              C = y(C);\n              let o = f(m, C);\n              return s(o, C);\n            },\n            formatDoc(m, C) {\n              return T(a(m), Object.assign(Object.assign({}, C), {}, {\n                parser: \"__js_expression\"\n              })).formatted;\n            },\n            printToDoc(m, C) {\n              C = y(C);\n              let {\n                ast: o,\n                text: d\n              } = c.parse(m, C);\n              return E(d, o, C), f(o, C);\n            },\n            printDocToString(m, C) {\n              return s(m, y(C));\n            }\n          };\n        }\n      }),\n      Um = te({\n        \"src/common/util-shared.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            getMaxContinuousCount: t,\n            getStringWidth: s,\n            getAlignmentSize: a,\n            getIndentSize: n,\n            skip: u,\n            skipWhitespace: i,\n            skipSpaces: l,\n            skipNewline: p,\n            skipToLineEnd: y,\n            skipEverythingButNewLine: h,\n            skipInlineComment: g,\n            skipTrailingComment: c,\n            hasNewline: f,\n            hasNewlineInRange: F,\n            hasSpaces: _,\n            isNextLineEmpty: w,\n            isNextLineEmptyAfterIndex: E,\n            isPreviousLineEmpty: N,\n            getNextNonSpaceNonCommentCharacterIndex: x,\n            makeString: I,\n            addLeadingComment: P,\n            addDanglingComment: $,\n            addTrailingComment: D\n          } = Ue();\n          r.exports = {\n            getMaxContinuousCount: t,\n            getStringWidth: s,\n            getAlignmentSize: a,\n            getIndentSize: n,\n            skip: u,\n            skipWhitespace: i,\n            skipSpaces: l,\n            skipNewline: p,\n            skipToLineEnd: y,\n            skipEverythingButNewLine: h,\n            skipInlineComment: g,\n            skipTrailingComment: c,\n            hasNewline: f,\n            hasNewlineInRange: F,\n            hasSpaces: _,\n            isNextLineEmpty: w,\n            isNextLineEmptyAfterIndex: E,\n            isPreviousLineEmpty: N,\n            getNextNonSpaceNonCommentCharacterIndex: x,\n            makeString: I,\n            addLeadingComment: P,\n            addDanglingComment: $,\n            addTrailingComment: D\n          };\n        }\n      }),\n      _t = te({\n        \"src/utils/create-language.js\"(e, r) {\n          \"use strict\";\n\n          ne(), r.exports = function (t, s) {\n            let {\n                languageId: a\n              } = t,\n              n = Hn(t, CD);\n            return Object.assign(Object.assign({\n              linguistLanguageId: a\n            }, n), s(t));\n          };\n        }\n      }),\n      Jm = te({\n        \"node_modules/esutils/lib/ast.js\"(e, r) {\n          ne(), function () {\n            \"use strict\";\n\n            function t(l) {\n              if (l == null) return !1;\n              switch (l.type) {\n                case \"ArrayExpression\":\n                case \"AssignmentExpression\":\n                case \"BinaryExpression\":\n                case \"CallExpression\":\n                case \"ConditionalExpression\":\n                case \"FunctionExpression\":\n                case \"Identifier\":\n                case \"Literal\":\n                case \"LogicalExpression\":\n                case \"MemberExpression\":\n                case \"NewExpression\":\n                case \"ObjectExpression\":\n                case \"SequenceExpression\":\n                case \"ThisExpression\":\n                case \"UnaryExpression\":\n                case \"UpdateExpression\":\n                  return !0;\n              }\n              return !1;\n            }\n            function s(l) {\n              if (l == null) return !1;\n              switch (l.type) {\n                case \"DoWhileStatement\":\n                case \"ForInStatement\":\n                case \"ForStatement\":\n                case \"WhileStatement\":\n                  return !0;\n              }\n              return !1;\n            }\n            function a(l) {\n              if (l == null) return !1;\n              switch (l.type) {\n                case \"BlockStatement\":\n                case \"BreakStatement\":\n                case \"ContinueStatement\":\n                case \"DebuggerStatement\":\n                case \"DoWhileStatement\":\n                case \"EmptyStatement\":\n                case \"ExpressionStatement\":\n                case \"ForInStatement\":\n                case \"ForStatement\":\n                case \"IfStatement\":\n                case \"LabeledStatement\":\n                case \"ReturnStatement\":\n                case \"SwitchStatement\":\n                case \"ThrowStatement\":\n                case \"TryStatement\":\n                case \"VariableDeclaration\":\n                case \"WhileStatement\":\n                case \"WithStatement\":\n                  return !0;\n              }\n              return !1;\n            }\n            function n(l) {\n              return a(l) || l != null && l.type === \"FunctionDeclaration\";\n            }\n            function u(l) {\n              switch (l.type) {\n                case \"IfStatement\":\n                  return l.alternate != null ? l.alternate : l.consequent;\n                case \"LabeledStatement\":\n                case \"ForStatement\":\n                case \"ForInStatement\":\n                case \"WhileStatement\":\n                case \"WithStatement\":\n                  return l.body;\n              }\n              return null;\n            }\n            function i(l) {\n              var p;\n              if (l.type !== \"IfStatement\" || l.alternate == null) return !1;\n              p = l.consequent;\n              do {\n                if (p.type === \"IfStatement\" && p.alternate == null) return !0;\n                p = u(p);\n              } while (p);\n              return !1;\n            }\n            r.exports = {\n              isExpression: t,\n              isStatement: a,\n              isIterationStatement: s,\n              isSourceElement: n,\n              isProblematicIfStatement: i,\n              trailingStatement: u\n            };\n          }();\n        }\n      }),\n      so = te({\n        \"node_modules/esutils/lib/code.js\"(e, r) {\n          ne(), function () {\n            \"use strict\";\n\n            var t, s, a, n, u, i;\n            s = {\n              NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n              NonAsciiIdentifierPart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/\n            }, t = {\n              NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n              NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n            };\n            function l(E) {\n              return 48 <= E && E <= 57;\n            }\n            function p(E) {\n              return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;\n            }\n            function y(E) {\n              return E >= 48 && E <= 55;\n            }\n            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];\n            function h(E) {\n              return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a.indexOf(E) >= 0;\n            }\n            function g(E) {\n              return E === 10 || E === 13 || E === 8232 || E === 8233;\n            }\n            function c(E) {\n              if (E <= 65535) return String.fromCharCode(E);\n              var N = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296),\n                x = String.fromCharCode((E - 65536) % 1024 + 56320);\n              return N + x;\n            }\n            for (n = new Array(128), i = 0; i < 128; ++i) n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;\n            for (u = new Array(128), i = 0; i < 128; ++i) u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;\n            function f(E) {\n              return E < 128 ? n[E] : s.NonAsciiIdentifierStart.test(c(E));\n            }\n            function F(E) {\n              return E < 128 ? u[E] : s.NonAsciiIdentifierPart.test(c(E));\n            }\n            function _(E) {\n              return E < 128 ? n[E] : t.NonAsciiIdentifierStart.test(c(E));\n            }\n            function w(E) {\n              return E < 128 ? u[E] : t.NonAsciiIdentifierPart.test(c(E));\n            }\n            r.exports = {\n              isDecimalDigit: l,\n              isHexDigit: p,\n              isOctalDigit: y,\n              isWhiteSpace: h,\n              isLineTerminator: g,\n              isIdentifierStartES5: f,\n              isIdentifierPartES5: F,\n              isIdentifierStartES6: _,\n              isIdentifierPartES6: w\n            };\n          }();\n        }\n      }),\n      zm = te({\n        \"node_modules/esutils/lib/keyword.js\"(e, r) {\n          ne(), function () {\n            \"use strict\";\n\n            var t = so();\n            function s(f) {\n              switch (f) {\n                case \"implements\":\n                case \"interface\":\n                case \"package\":\n                case \"private\":\n                case \"protected\":\n                case \"public\":\n                case \"static\":\n                case \"let\":\n                  return !0;\n                default:\n                  return !1;\n              }\n            }\n            function a(f, F) {\n              return !F && f === \"yield\" ? !1 : n(f, F);\n            }\n            function n(f, F) {\n              if (F && s(f)) return !0;\n              switch (f.length) {\n                case 2:\n                  return f === \"if\" || f === \"in\" || f === \"do\";\n                case 3:\n                  return f === \"var\" || f === \"for\" || f === \"new\" || f === \"try\";\n                case 4:\n                  return f === \"this\" || f === \"else\" || f === \"case\" || f === \"void\" || f === \"with\" || f === \"enum\";\n                case 5:\n                  return f === \"while\" || f === \"break\" || f === \"catch\" || f === \"throw\" || f === \"const\" || f === \"yield\" || f === \"class\" || f === \"super\";\n                case 6:\n                  return f === \"return\" || f === \"typeof\" || f === \"delete\" || f === \"switch\" || f === \"export\" || f === \"import\";\n                case 7:\n                  return f === \"default\" || f === \"finally\" || f === \"extends\";\n                case 8:\n                  return f === \"function\" || f === \"continue\" || f === \"debugger\";\n                case 10:\n                  return f === \"instanceof\";\n                default:\n                  return !1;\n              }\n            }\n            function u(f, F) {\n              return f === \"null\" || f === \"true\" || f === \"false\" || a(f, F);\n            }\n            function i(f, F) {\n              return f === \"null\" || f === \"true\" || f === \"false\" || n(f, F);\n            }\n            function l(f) {\n              return f === \"eval\" || f === \"arguments\";\n            }\n            function p(f) {\n              var F, _, w;\n              if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w))) return !1;\n              for (F = 1, _ = f.length; F < _; ++F) if (w = f.charCodeAt(F), !t.isIdentifierPartES5(w)) return !1;\n              return !0;\n            }\n            function y(f, F) {\n              return (f - 55296) * 1024 + (F - 56320) + 65536;\n            }\n            function h(f) {\n              var F, _, w, E, N;\n              if (f.length === 0) return !1;\n              for (N = t.isIdentifierStartES6, F = 0, _ = f.length; F < _; ++F) {\n                if (w = f.charCodeAt(F), 55296 <= w && w <= 56319) {\n                  if (++F, F >= _ || (E = f.charCodeAt(F), !(56320 <= E && E <= 57343))) return !1;\n                  w = y(w, E);\n                }\n                if (!N(w)) return !1;\n                N = t.isIdentifierPartES6;\n              }\n              return !0;\n            }\n            function g(f, F) {\n              return p(f) && !u(f, F);\n            }\n            function c(f, F) {\n              return h(f) && !i(f, F);\n            }\n            r.exports = {\n              isKeywordES5: a,\n              isKeywordES6: n,\n              isReservedWordES5: u,\n              isReservedWordES6: i,\n              isRestrictedWord: l,\n              isIdentifierNameES5: p,\n              isIdentifierNameES6: h,\n              isIdentifierES5: g,\n              isIdentifierES6: c\n            };\n          }();\n        }\n      }),\n      Xm = te({\n        \"node_modules/esutils/lib/utils.js\"(e) {\n          ne(), function () {\n            \"use strict\";\n\n            e.ast = Jm(), e.code = so(), e.keyword = zm();\n          }();\n        }\n      }),\n      Pt = te({\n        \"src/language-js/utils/is-block-comment.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = new Set([\"Block\", \"CommentBlock\", \"MultiLine\"]),\n            s = a => t.has(a == null ? void 0 : a.type);\n          r.exports = s;\n        }\n      }),\n      Km = te({\n        \"src/language-js/utils/is-node-matches.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(a, n) {\n            let u = n.split(\".\");\n            for (let i = u.length - 1; i >= 0; i--) {\n              let l = u[i];\n              if (i === 0) return a.type === \"Identifier\" && a.name === l;\n              if (a.type !== \"MemberExpression\" || a.optional || a.computed || a.property.type !== \"Identifier\" || a.property.name !== l) return !1;\n              a = a.object;\n            }\n          }\n          function s(a, n) {\n            return n.some(u => t(a, u));\n          }\n          r.exports = s;\n        }\n      }),\n      Ke = te({\n        \"src/language-js/utils/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Xm().keyword.isIdentifierNameES5,\n            {\n              getLast: s,\n              hasNewline: a,\n              skipWhitespace: n,\n              isNonEmptyArray: u,\n              isNextLineEmptyAfterIndex: i,\n              getStringWidth: l\n            } = Ue(),\n            {\n              locStart: p,\n              locEnd: y,\n              hasSameLocStart: h\n            } = ut(),\n            g = Pt(),\n            c = Km(),\n            f = \"(?:(?=.)\\\\s)\",\n            F = new RegExp(`^${f}*:`),\n            _ = new RegExp(`^${f}*::`);\n          function w(O) {\n            var me, _e;\n            return ((me = O.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && F.test(O.trailingComments[0].value);\n          }\n          function E(O) {\n            let me = O == null ? void 0 : O[0];\n            return g(me) && _.test(me.value);\n          }\n          function N(O, me) {\n            if (!O || typeof O != \"object\") return !1;\n            if (Array.isArray(O)) return O.some(He => N(He, me));\n            let _e = me(O);\n            return typeof _e == \"boolean\" ? _e : Object.values(O).some(He => N(He, me));\n          }\n          function x(O) {\n            return O.type === \"AssignmentExpression\" || O.type === \"BinaryExpression\" || O.type === \"LogicalExpression\" || O.type === \"NGPipeExpression\" || O.type === \"ConditionalExpression\" || de(O) || ue(O) || O.type === \"SequenceExpression\" || O.type === \"TaggedTemplateExpression\" || O.type === \"BindExpression\" || O.type === \"UpdateExpression\" && !O.prefix || st(O) || O.type === \"TSNonNullExpression\";\n          }\n          function I(O) {\n            var me, _e, He, Ge, it, Qe;\n            return O.expressions ? O.expressions[0] : (me = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me !== void 0 ? me : O.expression;\n          }\n          function P(O, me) {\n            if (me.expressions) return [\"expressions\", 0];\n            if (me.left) return [\"left\"];\n            if (me.test) return [\"test\"];\n            if (me.object) return [\"object\"];\n            if (me.callee) return [\"callee\"];\n            if (me.tag) return [\"tag\"];\n            if (me.argument) return [\"argument\"];\n            if (me.expression) return [\"expression\"];\n            throw new Error(\"Unexpected node has no left side.\");\n          }\n          function $(O) {\n            return O = new Set(O), me => O.has(me == null ? void 0 : me.type);\n          }\n          var D = $([\"Line\", \"CommentLine\", \"SingleLine\", \"HashbangComment\", \"HTMLOpen\", \"HTMLClose\"]),\n            T = $([\"ExportDefaultDeclaration\", \"ExportDefaultSpecifier\", \"DeclareExportDeclaration\", \"ExportNamedDeclaration\", \"ExportAllDeclaration\"]);\n          function m(O) {\n            let me = O.getParentNode();\n            return O.getName() === \"declaration\" && T(me) ? me : null;\n          }\n          var C = $([\"BooleanLiteral\", \"DirectiveLiteral\", \"Literal\", \"NullLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"RegExpLiteral\", \"StringLiteral\", \"TemplateLiteral\", \"TSTypeLiteral\", \"JSXText\"]);\n          function o(O) {\n            return O.type === \"NumericLiteral\" || O.type === \"Literal\" && typeof O.value == \"number\";\n          }\n          function d(O) {\n            return O.type === \"UnaryExpression\" && (O.operator === \"+\" || O.operator === \"-\") && o(O.argument);\n          }\n          function v(O) {\n            return O.type === \"StringLiteral\" || O.type === \"Literal\" && typeof O.value == \"string\";\n          }\n          var S = $([\"ObjectTypeAnnotation\", \"TSTypeLiteral\", \"TSMappedType\"]),\n            b = $([\"FunctionExpression\", \"ArrowFunctionExpression\"]);\n          function B(O) {\n            return O.type === \"FunctionExpression\" || O.type === \"ArrowFunctionExpression\" && O.body.type === \"BlockStatement\";\n          }\n          function k(O) {\n            return de(O) && O.callee.type === \"Identifier\" && [\"async\", \"inject\", \"fakeAsync\", \"waitForAsync\"].includes(O.callee.name);\n          }\n          var M = $([\"JSXElement\", \"JSXFragment\"]);\n          function R(O, me) {\n            if (O.parentParser !== \"markdown\" && O.parentParser !== \"mdx\") return !1;\n            let _e = me.getNode();\n            if (!_e.expression || !M(_e.expression)) return !1;\n            let He = me.getParentNode();\n            return He.type === \"Program\" && He.body.length === 1;\n          }\n          function q(O) {\n            return O.kind === \"get\" || O.kind === \"set\";\n          }\n          function J(O) {\n            return q(O) || h(O, O.value);\n          }\n          function L(O) {\n            return (O.type === \"ObjectTypeProperty\" || O.type === \"ObjectTypeInternalSlot\") && O.value.type === \"FunctionTypeAnnotation\" && !O.static && !J(O);\n          }\n          function Q(O) {\n            return (O.type === \"TypeAnnotation\" || O.type === \"TSTypeAnnotation\") && O.typeAnnotation.type === \"FunctionTypeAnnotation\" && !O.static && !h(O, O.typeAnnotation);\n          }\n          var V = $([\"BinaryExpression\", \"LogicalExpression\", \"NGPipeExpression\"]);\n          function j(O) {\n            return ue(O) || O.type === \"BindExpression\" && Boolean(O.object);\n          }\n          var Y = new Set([\"AnyTypeAnnotation\", \"TSAnyKeyword\", \"NullLiteralTypeAnnotation\", \"TSNullKeyword\", \"ThisTypeAnnotation\", \"TSThisType\", \"NumberTypeAnnotation\", \"TSNumberKeyword\", \"VoidTypeAnnotation\", \"TSVoidKeyword\", \"BooleanTypeAnnotation\", \"TSBooleanKeyword\", \"BigIntTypeAnnotation\", \"TSBigIntKeyword\", \"SymbolTypeAnnotation\", \"TSSymbolKeyword\", \"StringTypeAnnotation\", \"TSStringKeyword\", \"BooleanLiteralTypeAnnotation\", \"StringLiteralTypeAnnotation\", \"BigIntLiteralTypeAnnotation\", \"NumberLiteralTypeAnnotation\", \"TSLiteralType\", \"TSTemplateLiteralType\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"TSNeverKeyword\", \"TSObjectKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\"]);\n          function ie(O) {\n            return O ? !!((O.type === \"GenericTypeAnnotation\" || O.type === \"TSTypeReference\") && !O.typeParameters || Y.has(O.type)) : !1;\n          }\n          function ee(O) {\n            let me = /^(?:before|after)(?:Each|All)$/;\n            return O.callee.type === \"Identifier\" && me.test(O.callee.name) && O.arguments.length === 1;\n          }\n          var ce = [\"it\", \"it.only\", \"it.skip\", \"describe\", \"describe.only\", \"describe.skip\", \"test\", \"test.only\", \"test.skip\", \"test.step\", \"test.describe\", \"test.describe.only\", \"test.describe.parallel\", \"test.describe.parallel.only\", \"test.describe.serial\", \"test.describe.serial.only\", \"skip\", \"xit\", \"xdescribe\", \"xtest\", \"fit\", \"fdescribe\", \"ftest\"];\n          function W(O) {\n            return c(O, ce);\n          }\n          function K(O, me) {\n            if (O.type !== \"CallExpression\") return !1;\n            if (O.arguments.length === 1) {\n              if (k(O) && me && K(me)) return b(O.arguments[0]);\n              if (ee(O)) return k(O.arguments[0]);\n            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === \"TemplateLiteral\" || v(O.arguments[0])) && W(O.callee)) return O.arguments[2] && !o(O.arguments[2]) ? !1 : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);\n            return !1;\n          }\n          var de = $([\"CallExpression\", \"OptionalCallExpression\"]),\n            ue = $([\"MemberExpression\", \"OptionalMemberExpression\"]);\n          function Fe(O) {\n            let me = \"expressions\";\n            O.type === \"TSTemplateLiteralType\" && (me = \"types\");\n            let _e = O[me];\n            return _e.length === 0 ? !1 : _e.every(He => {\n              if (Me(He)) return !1;\n              if (He.type === \"Identifier\" || He.type === \"ThisExpression\") return !0;\n              if (ue(He)) {\n                let Ge = He;\n                for (; ue(Ge);) if (Ge.property.type !== \"Identifier\" && Ge.property.type !== \"Literal\" && Ge.property.type !== \"StringLiteral\" && Ge.property.type !== \"NumericLiteral\" || (Ge = Ge.object, Me(Ge))) return !1;\n                return Ge.type === \"Identifier\" || Ge.type === \"ThisExpression\";\n              }\n              return !1;\n            });\n          }\n          function z(O, me) {\n            return O === \"+\" || O === \"-\" ? O + me : me;\n          }\n          function U(O, me) {\n            let _e = p(me),\n              He = n(O, y(me));\n            return He !== !1 && O.slice(_e, _e + 2) === \"/*\" && O.slice(He, He + 2) === \"*/\";\n          }\n          function Z(O, me) {\n            return M(me) ? Oe(me) : Me(me, Te.Leading, _e => a(O, y(_e)));\n          }\n          function se(O, me) {\n            return me.parser !== \"json\" && v(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me.parser === \"babel-ts\" && O.type === \"ClassProperty\" || me.parser === \"typescript\" && O.type === \"PropertyDefinition\") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me.parser === \"babel\" || me.parser === \"acorn\" || me.parser === \"espree\" || me.parser === \"meriyah\" || me.parser === \"__babel_estree\"));\n          }\n          function fe(O) {\n            return /^(?:\\d+|\\d+\\.\\d+)$/.test(O);\n          }\n          function ge(O, me) {\n            let _e = /^[fx]?(?:describe|it|test)$/;\n            return me.type === \"TaggedTemplateExpression\" && me.quasi === O && me.tag.type === \"MemberExpression\" && me.tag.property.type === \"Identifier\" && me.tag.property.name === \"each\" && (me.tag.object.type === \"Identifier\" && _e.test(me.tag.object.name) || me.tag.object.type === \"MemberExpression\" && me.tag.object.property.type === \"Identifier\" && (me.tag.object.property.name === \"only\" || me.tag.object.property.name === \"skip\") && me.tag.object.object.type === \"Identifier\" && _e.test(me.tag.object.object.name));\n          }\n          function he(O) {\n            return O.quasis.some(me => me.value.raw.includes(`\n`));\n          }\n          function we(O, me) {\n            return (O.type === \"TemplateLiteral\" && he(O) || O.type === \"TaggedTemplateExpression\" && he(O.quasi)) && !a(me, p(O), {\n              backwards: !0\n            });\n          }\n          function ke(O) {\n            if (!Me(O)) return !1;\n            let me = s(ae(O, Te.Dangling));\n            return me && !g(me);\n          }\n          function Re(O) {\n            if (O.length <= 1) return !1;\n            let me = 0;\n            for (let _e of O) if (b(_e)) {\n              if (me += 1, me > 1) return !0;\n            } else if (de(_e)) {\n              for (let He of _e.arguments) if (b(He)) return !0;\n            }\n            return !1;\n          }\n          function Ne(O) {\n            let me = O.getValue(),\n              _e = O.getParentNode();\n            return de(me) && de(_e) && _e.callee === me && me.arguments.length > _e.arguments.length && _e.arguments.length > 0;\n          }\n          function Pe(O, me) {\n            if (me >= 2) return !1;\n            let _e = Qe => Pe(Qe, me + 1),\n              He = O.type === \"Literal\" && \"regex\" in O && O.regex.pattern || O.type === \"RegExpLiteral\" && O.pattern;\n            if (He && l(He) > 5) return !1;\n            if (O.type === \"Literal\" || O.type === \"BigIntLiteral\" || O.type === \"DecimalLiteral\" || O.type === \"BooleanLiteral\" || O.type === \"NullLiteral\" || O.type === \"NumericLiteral\" || O.type === \"RegExpLiteral\" || O.type === \"StringLiteral\" || O.type === \"Identifier\" || O.type === \"ThisExpression\" || O.type === \"Super\" || O.type === \"PrivateName\" || O.type === \"PrivateIdentifier\" || O.type === \"ArgumentPlaceholder\" || O.type === \"Import\") return !0;\n            if (O.type === \"TemplateLiteral\") return O.quasis.every(Qe => !Qe.value.raw.includes(`\n`)) && O.expressions.every(_e);\n            if (O.type === \"ObjectExpression\") return O.properties.every(Qe => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));\n            if (O.type === \"ArrayExpression\") return O.elements.every(Qe => Qe === null || _e(Qe));\n            if (tt(O)) return (O.type === \"ImportExpression\" || Pe(O.callee, me)) && Ye(O).every(_e);\n            if (ue(O)) return Pe(O.object, me) && Pe(O.property, me);\n            let Ge = {\n              \"!\": !0,\n              \"-\": !0,\n              \"+\": !0,\n              \"~\": !0\n            };\n            if (O.type === \"UnaryExpression\" && Ge[O.operator]) return Pe(O.argument, me);\n            let it = {\n              \"++\": !0,\n              \"--\": !0\n            };\n            return O.type === \"UpdateExpression\" && it[O.operator] ? Pe(O.argument, me) : O.type === \"TSNonNullExpression\" ? Pe(O.expression, me) : !1;\n          }\n          function oe(O) {\n            var me, _e;\n            return (me = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me !== void 0 ? me : O.raw;\n          }\n          function H(O) {\n            return O;\n          }\n          function pe(O) {\n            return O.filepath && /\\.tsx$/i.test(O.filepath);\n          }\n          function X(O) {\n            let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"es5\";\n            return O.trailingComma === \"es5\" && me === \"es5\" || O.trailingComma === \"all\" && (me === \"all\" || me === \"es5\");\n          }\n          function le(O, me) {\n            switch (O.type) {\n              case \"BinaryExpression\":\n              case \"LogicalExpression\":\n              case \"AssignmentExpression\":\n              case \"NGPipeExpression\":\n                return le(O.left, me);\n              case \"MemberExpression\":\n              case \"OptionalMemberExpression\":\n                return le(O.object, me);\n              case \"TaggedTemplateExpression\":\n                return O.tag.type === \"FunctionExpression\" ? !1 : le(O.tag, me);\n              case \"CallExpression\":\n              case \"OptionalCallExpression\":\n                return O.callee.type === \"FunctionExpression\" ? !1 : le(O.callee, me);\n              case \"ConditionalExpression\":\n                return le(O.test, me);\n              case \"UpdateExpression\":\n                return !O.prefix && le(O.argument, me);\n              case \"BindExpression\":\n                return O.object && le(O.object, me);\n              case \"SequenceExpression\":\n                return le(O.expressions[0], me);\n              case \"TSSatisfiesExpression\":\n              case \"TSAsExpression\":\n              case \"TSNonNullExpression\":\n                return le(O.expression, me);\n              default:\n                return me(O);\n            }\n          }\n          var Ae = {\n              \"==\": !0,\n              \"!=\": !0,\n              \"===\": !0,\n              \"!==\": !0\n            },\n            Ee = {\n              \"*\": !0,\n              \"/\": !0,\n              \"%\": !0\n            },\n            De = {\n              \">>\": !0,\n              \">>>\": !0,\n              \"<<\": !0\n            };\n          function A(O, me) {\n            return !(re(me) !== re(O) || O === \"**\" || Ae[O] && Ae[me] || me === \"%\" && Ee[O] || O === \"%\" && Ee[me] || me !== O && Ee[me] && Ee[O] || De[O] && De[me]);\n          }\n          var G = new Map([[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].flatMap((O, me) => O.map(_e => [_e, me])));\n          function re(O) {\n            return G.get(O);\n          }\n          function ye(O) {\n            return Boolean(De[O]) || O === \"|\" || O === \"^\" || O === \"&\";\n          }\n          function Ce(O) {\n            var me;\n            if (O.rest) return !0;\n            let _e = ve(O);\n            return ((me = s(_e)) === null || me === void 0 ? void 0 : me.type) === \"RestElement\";\n          }\n          var Be = new WeakMap();\n          function ve(O) {\n            if (Be.has(O)) return Be.get(O);\n            let me = [];\n            return O.this && me.push(O.this), Array.isArray(O.parameters) ? me.push(...O.parameters) : Array.isArray(O.params) && me.push(...O.params), O.rest && me.push(O.rest), Be.set(O, me), me;\n          }\n          function ze(O, me) {\n            let _e = O.getValue(),\n              He = 0,\n              Ge = it => me(it, He++);\n            _e.this && O.call(Ge, \"this\"), Array.isArray(_e.parameters) ? O.each(Ge, \"parameters\") : Array.isArray(_e.params) && O.each(Ge, \"params\"), _e.rest && O.call(Ge, \"rest\");\n          }\n          var be = new WeakMap();\n          function Ye(O) {\n            if (be.has(O)) return be.get(O);\n            let me = O.arguments;\n            return O.type === \"ImportExpression\" && (me = [O.source], O.attributes && me.push(O.attributes)), be.set(O, me), me;\n          }\n          function Se(O, me) {\n            let _e = O.getValue();\n            _e.type === \"ImportExpression\" ? (O.call(He => me(He, 0), \"source\"), _e.attributes && O.call(He => me(He, 1), \"attributes\")) : O.each(me, \"arguments\");\n          }\n          function Ie(O) {\n            return O.value.trim() === \"prettier-ignore\" && !O.unignore;\n          }\n          function Oe(O) {\n            return O && (O.prettierIgnore || Me(O, Te.PrettierIgnore));\n          }\n          function Je(O) {\n            let me = O.getValue();\n            return Oe(me);\n          }\n          var Te = {\n              Leading: 1 << 1,\n              Trailing: 1 << 2,\n              Dangling: 1 << 3,\n              Block: 1 << 4,\n              Line: 1 << 5,\n              PrettierIgnore: 1 << 6,\n              First: 1 << 7,\n              Last: 1 << 8\n            },\n            je = (O, me) => {\n              if (typeof O == \"function\" && (me = O, O = 0), O || me) return (_e, He, Ge) => !(O & Te.Leading && !_e.leading || O & Te.Trailing && !_e.trailing || O & Te.Dangling && (_e.leading || _e.trailing) || O & Te.Block && !g(_e) || O & Te.Line && !D(_e) || O & Te.First && He !== 0 || O & Te.Last && He !== Ge.length - 1 || O & Te.PrettierIgnore && !Ie(_e) || me && !me(_e));\n            };\n          function Me(O, me, _e) {\n            if (!u(O == null ? void 0 : O.comments)) return !1;\n            let He = je(me, _e);\n            return He ? O.comments.some(He) : !0;\n          }\n          function ae(O, me, _e) {\n            if (!Array.isArray(O == null ? void 0 : O.comments)) return [];\n            let He = je(me, _e);\n            return He ? O.comments.filter(He) : O.comments;\n          }\n          var nt = (O, me) => {\n            let {\n              originalText: _e\n            } = me;\n            return i(_e, y(O));\n          };\n          function tt(O) {\n            return de(O) || O.type === \"NewExpression\" || O.type === \"ImportExpression\";\n          }\n          function Ve(O) {\n            return O && (O.type === \"ObjectProperty\" || O.type === \"Property\" && !O.method && O.kind === \"init\");\n          }\n          function We(O) {\n            return Boolean(O.__isUsingHackPipeline);\n          }\n          var Xe = Symbol(\"ifWithoutBlockAndSameLineComment\");\n          function st(O) {\n            return O.type === \"TSAsExpression\" || O.type === \"TSSatisfiesExpression\";\n          }\n          r.exports = {\n            getFunctionParameters: ve,\n            iterateFunctionParametersPath: ze,\n            getCallArguments: Ye,\n            iterateCallArgumentsPath: Se,\n            hasRestParameter: Ce,\n            getLeftSide: I,\n            getLeftSidePathName: P,\n            getParentExportDeclaration: m,\n            getTypeScriptMappedTypeModifier: z,\n            hasFlowAnnotationComment: E,\n            hasFlowShorthandAnnotationComment: w,\n            hasLeadingOwnLineComment: Z,\n            hasNakedLeftSide: x,\n            hasNode: N,\n            hasIgnoreComment: Je,\n            hasNodeIgnoreComment: Oe,\n            identity: H,\n            isBinaryish: V,\n            isCallLikeExpression: tt,\n            isEnabledHackPipeline: We,\n            isLineComment: D,\n            isPrettierIgnoreComment: Ie,\n            isCallExpression: de,\n            isMemberExpression: ue,\n            isExportDeclaration: T,\n            isFlowAnnotationComment: U,\n            isFunctionCompositionArgs: Re,\n            isFunctionNotation: J,\n            isFunctionOrArrowExpression: b,\n            isGetterOrSetter: q,\n            isJestEachTemplateLiteral: ge,\n            isJsxNode: M,\n            isLiteral: C,\n            isLongCurriedCallExpression: Ne,\n            isSimpleCallArgument: Pe,\n            isMemberish: j,\n            isNumericLiteral: o,\n            isSignedNumericLiteral: d,\n            isObjectProperty: Ve,\n            isObjectType: S,\n            isObjectTypePropertyAFunction: L,\n            isSimpleType: ie,\n            isSimpleNumber: fe,\n            isSimpleTemplateLiteral: Fe,\n            isStringLiteral: v,\n            isStringPropSafeToUnquote: se,\n            isTemplateOnItsOwnLine: we,\n            isTestCall: K,\n            isTheOnlyJsxElementInMarkdown: R,\n            isTSXFile: pe,\n            isTypeAnnotationAFunction: Q,\n            isNextLineEmpty: nt,\n            needsHardlineAfterDanglingComment: ke,\n            rawText: oe,\n            shouldPrintComma: X,\n            isBitwiseOperator: ye,\n            shouldFlatten: A,\n            startsWithNoLookaheadToken: le,\n            getPrecedence: re,\n            hasComment: Me,\n            getComments: ae,\n            CommentCheckFlags: Te,\n            markerForIfWithoutBlockAndSameLineComment: Xe,\n            isTSTypeExpression: st\n          };\n        }\n      }),\n      jt = te({\n        \"src/language-js/print/template-literal.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = lt(),\n            {\n              getStringWidth: s,\n              getIndentSize: a\n            } = Ue(),\n            {\n              builders: {\n                join: n,\n                hardline: u,\n                softline: i,\n                group: l,\n                indent: p,\n                align: y,\n                lineSuffixBoundary: h,\n                addAlignmentToDoc: g\n              },\n              printer: {\n                printDocToString: c\n              },\n              utils: {\n                mapDoc: f\n              }\n            } = qe(),\n            {\n              isBinaryish: F,\n              isJestEachTemplateLiteral: _,\n              isSimpleTemplateLiteral: w,\n              hasComment: E,\n              isMemberExpression: N,\n              isTSTypeExpression: x\n            } = Ke();\n          function I(C, o, d) {\n            let v = C.getValue();\n            if (v.type === \"TemplateLiteral\" && _(v, C.getParentNode())) {\n              let R = P(C, d, o);\n              if (R) return R;\n            }\n            let b = \"expressions\";\n            v.type === \"TSTemplateLiteralType\" && (b = \"types\");\n            let B = [],\n              k = C.map(o, b),\n              M = w(v);\n            return M && (k = k.map(R => c(R, Object.assign(Object.assign({}, d), {}, {\n              printWidth: Number.POSITIVE_INFINITY\n            })).formatted)), B.push(h, \"`\"), C.each(R => {\n              let q = R.getName();\n              if (B.push(o()), q < k.length) {\n                let {\n                    tabWidth: J\n                  } = d,\n                  L = R.getValue(),\n                  Q = a(L.value.raw, J),\n                  V = k[q];\n                if (!M) {\n                  let Y = v[b][q];\n                  (E(Y) || N(Y) || Y.type === \"ConditionalExpression\" || Y.type === \"SequenceExpression\" || x(Y) || F(Y)) && (V = [p([i, V]), i]);\n                }\n                let j = Q === 0 && L.value.raw.endsWith(`\n`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Q, J);\n                B.push(l([\"${\", j, h, \"}\"]));\n              }\n            }, \"quasis\"), B.push(\"`\"), B;\n          }\n          function P(C, o, d) {\n            let v = C.getNode(),\n              S = v.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n            if (S.length > 1 || S.some(b => b.length > 0)) {\n              o.__inJestEach = !0;\n              let b = C.map(d, \"expressions\");\n              o.__inJestEach = !1;\n              let B = [],\n                k = b.map(L => \"${\" + c(L, Object.assign(Object.assign({}, o), {}, {\n                  printWidth: Number.POSITIVE_INFINITY,\n                  endOfLine: \"lf\"\n                })).formatted + \"}\"),\n                M = [{\n                  hasLineBreak: !1,\n                  cells: []\n                }];\n              for (let L = 1; L < v.quasis.length; L++) {\n                let Q = t(M),\n                  V = k[L - 1];\n                Q.cells.push(V), V.includes(`\n`) && (Q.hasLineBreak = !0), v.quasis[L].value.raw.includes(`\n`) && M.push({\n                  hasLineBreak: !1,\n                  cells: []\n                });\n              }\n              let R = Math.max(S.length, ...M.map(L => L.cells.length)),\n                q = Array.from({\n                  length: R\n                }).fill(0),\n                J = [{\n                  cells: S\n                }, ...M.filter(L => L.cells.length > 0)];\n              for (let {\n                cells: L\n              } of J.filter(Q => !Q.hasLineBreak)) for (let [Q, V] of L.entries()) q[Q] = Math.max(q[Q], s(V));\n              return B.push(h, \"`\", p([u, n(u, J.map(L => n(\" | \", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + \" \".repeat(q[V] - s(Q))))))]), u, \"`\"), B;\n            }\n          }\n          function $(C, o) {\n            let d = C.getValue(),\n              v = o();\n            return E(d) && (v = l([p([i, v]), i])), [\"${\", v, h, \"}\"];\n          }\n          function D(C, o) {\n            return C.map(d => $(d, o), \"expressions\");\n          }\n          function T(C, o) {\n            return f(C, d => typeof d == \"string\" ? o ? d.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : m(d) : d);\n          }\n          function m(C) {\n            return C.replace(/([\\\\`]|\\${)/g, \"\\\\$1\");\n          }\n          r.exports = {\n            printTemplateLiteral: I,\n            printTemplateExpressions: D,\n            escapeTemplateCharacters: T,\n            uncookTemplateElementValue: m\n          };\n        }\n      }),\n      Ym = te({\n        \"src/language-js/embed/markdown.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                indent: t,\n                softline: s,\n                literalline: a,\n                dedentToRoot: n\n              }\n            } = qe(),\n            {\n              escapeTemplateCharacters: u\n            } = jt();\n          function i(p, y, h) {\n            let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, (w, E) => \"\\\\\".repeat(E.length / 2) + \"`\"),\n              f = l(c),\n              F = f !== \"\";\n            F && (c = c.replace(new RegExp(`^${f}`, \"gm\"), \"\"));\n            let _ = u(h(c, {\n              parser: \"markdown\",\n              __inJsTemplate: !0\n            }, {\n              stripTrailingHardline: !0\n            }), !0);\n            return [\"`\", F ? t([s, _]) : [a, n(_)], s, \"`\"];\n          }\n          function l(p) {\n            let y = p.match(/^([^\\S\\n]*)\\S/m);\n            return y === null ? \"\" : y[1];\n          }\n          r.exports = i;\n        }\n      }),\n      Qm = te({\n        \"src/language-js/embed/css.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isNonEmptyArray: t\n            } = Ue(),\n            {\n              builders: {\n                indent: s,\n                hardline: a,\n                softline: n\n              },\n              utils: {\n                mapDoc: u,\n                replaceEndOfLine: i,\n                cleanDoc: l\n              }\n            } = qe(),\n            {\n              printTemplateExpressions: p\n            } = jt();\n          function y(c, f, F) {\n            let _ = c.getValue(),\n              w = _.quasis.map(P => P.value.raw),\n              E = 0,\n              N = w.reduce((P, $, D) => D === 0 ? $ : P + \"@prettier-placeholder-\" + E++ + \"-id\" + $, \"\"),\n              x = F(N, {\n                parser: \"scss\"\n              }, {\n                stripTrailingHardline: !0\n              }),\n              I = p(c, f);\n            return h(x, _, I);\n          }\n          function h(c, f, F) {\n            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim()) return \"``\";\n            let w = g(c, F);\n            if (!w) throw new Error(\"Couldn't insert all the expressions\");\n            return [\"`\", s([a, w]), n, \"`\"];\n          }\n          function g(c, f) {\n            if (!t(f)) return c;\n            let F = 0,\n              _ = u(l(c), w => typeof w != \"string\" || !w.includes(\"@prettier-placeholder\") ? w : w.split(/@prettier-placeholder-(\\d+)-id/).map((E, N) => N % 2 === 0 ? i(E) : (F++, f[E])));\n            return f.length === F ? _ : null;\n          }\n          r.exports = y;\n        }\n      }),\n      Zm = te({\n        \"src/language-js/embed/graphql.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                indent: t,\n                join: s,\n                hardline: a\n              }\n            } = qe(),\n            {\n              escapeTemplateCharacters: n,\n              printTemplateExpressions: u\n            } = jt();\n          function i(p, y, h) {\n            let g = p.getValue(),\n              c = g.quasis.length;\n            if (c === 1 && g.quasis[0].value.raw.trim() === \"\") return \"``\";\n            let f = u(p, y),\n              F = [];\n            for (let _ = 0; _ < c; _++) {\n              let w = g.quasis[_],\n                E = _ === 0,\n                N = _ === c - 1,\n                x = w.value.cooked,\n                I = x.split(`\n`),\n                P = I.length,\n                $ = f[_],\n                D = P > 2 && I[0].trim() === \"\" && I[1].trim() === \"\",\n                T = P > 2 && I[P - 1].trim() === \"\" && I[P - 2].trim() === \"\",\n                m = I.every(o => /^\\s*(?:#[^\\n\\r]*)?$/.test(o));\n              if (!N && /#[^\\n\\r]*$/.test(I[P - 1])) return null;\n              let C = null;\n              m ? C = l(I) : C = h(x, {\n                parser: \"graphql\"\n              }, {\n                stripTrailingHardline: !0\n              }), C ? (C = n(C, !1), !E && D && F.push(\"\"), F.push(C), !N && T && F.push(\"\")) : !E && !N && D && F.push(\"\"), $ && F.push($);\n            }\n            return [\"`\", t([a, s(a, F)]), a, \"`\"];\n          }\n          function l(p) {\n            let y = [],\n              h = !1,\n              g = p.map(c => c.trim());\n            for (let [c, f] of g.entries()) f !== \"\" && (g[c - 1] === \"\" && h ? y.push([a, f]) : y.push(f), h = !0);\n            return y.length === 0 ? null : s(a, y);\n          }\n          r.exports = i;\n        }\n      }),\n      ed = te({\n        \"src/language-js/embed/html.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                indent: t,\n                line: s,\n                hardline: a,\n                group: n\n              },\n              utils: {\n                mapDoc: u\n              }\n            } = qe(),\n            {\n              printTemplateExpressions: i,\n              uncookTemplateElementValue: l\n            } = jt(),\n            p = 0;\n          function y(h, g, c, f, F) {\n            let {\n                parser: _\n              } = F,\n              w = h.getValue(),\n              E = p;\n            p = p + 1 >>> 0;\n            let N = d => `PRETTIER_HTML_PLACEHOLDER_${d}_${E}_IN_JS`,\n              x = w.quasis.map((d, v, S) => v === S.length - 1 ? d.value.cooked : d.value.cooked + N(v)).join(\"\"),\n              I = i(h, g);\n            if (I.length === 0 && x.trim().length === 0) return \"``\";\n            let P = new RegExp(N(\"(\\\\d+)\"), \"g\"),\n              $ = 0,\n              D = c(x, {\n                parser: _,\n                __onHtmlRoot(d) {\n                  $ = d.children.length;\n                }\n              }, {\n                stripTrailingHardline: !0\n              }),\n              T = u(D, d => {\n                if (typeof d != \"string\") return d;\n                let v = [],\n                  S = d.split(P);\n                for (let b = 0; b < S.length; b++) {\n                  let B = S[b];\n                  if (b % 2 === 0) {\n                    B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\")), v.push(B));\n                    continue;\n                  }\n                  let k = Number(B);\n                  v.push(I[k]);\n                }\n                return v;\n              }),\n              m = /^\\s/.test(x) ? \" \" : \"\",\n              C = /\\s$/.test(x) ? \" \" : \"\",\n              o = f.htmlWhitespaceSensitivity === \"ignore\" ? a : m && C ? s : null;\n            return n(o ? [\"`\", t([o, n(T)]), o, \"`\"] : [\"`\", m, $ > 1 ? t(n(T)) : n(T), C, \"`\"]);\n          }\n          r.exports = y;\n        }\n      }),\n      td = te({\n        \"src/language-js/embed.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              hasComment: t,\n              CommentCheckFlags: s,\n              isObjectProperty: a\n            } = Ke(),\n            n = Ym(),\n            u = Qm(),\n            i = Zm(),\n            l = ed();\n          function p(D) {\n            if (g(D) || _(D) || w(D) || c(D)) return \"css\";\n            if (x(D)) return \"graphql\";\n            if (P(D)) return \"html\";\n            if (f(D)) return \"angular\";\n            if (h(D)) return \"markdown\";\n          }\n          function y(D, T, m, C) {\n            let o = D.getValue();\n            if (o.type !== \"TemplateLiteral\" || $(o)) return;\n            let d = p(D);\n            if (d) {\n              if (d === \"markdown\") return n(D, T, m);\n              if (d === \"css\") return u(D, T, m);\n              if (d === \"graphql\") return i(D, T, m);\n              if (d === \"html\" || d === \"angular\") return l(D, T, m, C, {\n                parser: d\n              });\n            }\n          }\n          function h(D) {\n            let T = D.getValue(),\n              m = D.getParentNode();\n            return m && m.type === \"TaggedTemplateExpression\" && T.quasis.length === 1 && m.tag.type === \"Identifier\" && (m.tag.name === \"md\" || m.tag.name === \"markdown\");\n          }\n          function g(D) {\n            let T = D.getValue(),\n              m = D.getParentNode(),\n              C = D.getParentNode(1);\n            return C && T.quasis && m.type === \"JSXExpressionContainer\" && C.type === \"JSXElement\" && C.openingElement.name.name === \"style\" && C.openingElement.attributes.some(o => o.name.name === \"jsx\") || m && m.type === \"TaggedTemplateExpression\" && m.tag.type === \"Identifier\" && m.tag.name === \"css\" || m && m.type === \"TaggedTemplateExpression\" && m.tag.type === \"MemberExpression\" && m.tag.object.name === \"css\" && (m.tag.property.name === \"global\" || m.tag.property.name === \"resolve\");\n          }\n          function c(D) {\n            return D.match(T => T.type === \"TemplateLiteral\", (T, m) => T.type === \"ArrayExpression\" && m === \"elements\", (T, m) => a(T) && T.key.type === \"Identifier\" && T.key.name === \"styles\" && m === \"value\", ...F);\n          }\n          function f(D) {\n            return D.match(T => T.type === \"TemplateLiteral\", (T, m) => a(T) && T.key.type === \"Identifier\" && T.key.name === \"template\" && m === \"value\", ...F);\n          }\n          var F = [(D, T) => D.type === \"ObjectExpression\" && T === \"properties\", (D, T) => D.type === \"CallExpression\" && D.callee.type === \"Identifier\" && D.callee.name === \"Component\" && T === \"arguments\", (D, T) => D.type === \"Decorator\" && T === \"expression\"];\n          function _(D) {\n            let T = D.getParentNode();\n            if (!T || T.type !== \"TaggedTemplateExpression\") return !1;\n            let m = T.tag.type === \"ParenthesizedExpression\" ? T.tag.expression : T.tag;\n            switch (m.type) {\n              case \"MemberExpression\":\n                return E(m.object) || N(m);\n              case \"CallExpression\":\n                return E(m.callee) || m.callee.type === \"MemberExpression\" && (m.callee.object.type === \"MemberExpression\" && (E(m.callee.object.object) || N(m.callee.object)) || m.callee.object.type === \"CallExpression\" && E(m.callee.object.callee));\n              case \"Identifier\":\n                return m.name === \"css\";\n              default:\n                return !1;\n            }\n          }\n          function w(D) {\n            let T = D.getParentNode(),\n              m = D.getParentNode(1);\n            return m && T.type === \"JSXExpressionContainer\" && m.type === \"JSXAttribute\" && m.name.type === \"JSXIdentifier\" && m.name.name === \"css\";\n          }\n          function E(D) {\n            return D.type === \"Identifier\" && D.name === \"styled\";\n          }\n          function N(D) {\n            return /^[A-Z]/.test(D.object.name) && D.property.name === \"extend\";\n          }\n          function x(D) {\n            let T = D.getValue(),\n              m = D.getParentNode();\n            return I(T, \"GraphQL\") || m && (m.type === \"TaggedTemplateExpression\" && (m.tag.type === \"MemberExpression\" && m.tag.object.name === \"graphql\" && m.tag.property.name === \"experimental\" || m.tag.type === \"Identifier\" && (m.tag.name === \"gql\" || m.tag.name === \"graphql\")) || m.type === \"CallExpression\" && m.callee.type === \"Identifier\" && m.callee.name === \"graphql\");\n          }\n          function I(D, T) {\n            return t(D, s.Block | s.Leading, m => {\n              let {\n                value: C\n              } = m;\n              return C === ` ${T} `;\n            });\n          }\n          function P(D) {\n            return I(D.getValue(), \"HTML\") || D.match(T => T.type === \"TemplateLiteral\", (T, m) => T.type === \"TaggedTemplateExpression\" && T.tag.type === \"Identifier\" && T.tag.name === \"html\" && m === \"quasi\");\n          }\n          function $(D) {\n            let {\n              quasis: T\n            } = D;\n            return T.some(m => {\n              let {\n                value: {\n                  cooked: C\n                }\n              } = m;\n              return C === null;\n            });\n          }\n          r.exports = y;\n        }\n      }),\n      rd = te({\n        \"src/language-js/clean.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Pt(),\n            s = new Set([\"range\", \"raw\", \"comments\", \"leadingComments\", \"trailingComments\", \"innerComments\", \"extra\", \"start\", \"end\", \"loc\", \"flags\", \"errors\", \"tokens\"]),\n            a = u => {\n              for (let i of u.quasis) delete i.value;\n            };\n          function n(u, i, l) {\n            if (u.type === \"Program\" && delete i.sourceType, (u.type === \"BigIntLiteral\" || u.type === \"BigIntLiteralTypeAnnotation\") && i.value && (i.value = i.value.toLowerCase()), (u.type === \"BigIntLiteral\" || u.type === \"Literal\") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === \"DecimalLiteral\" && (i.value = Number(i.value)), u.type === \"Literal\" && i.decimal && (i.decimal = Number(i.decimal)), u.type === \"EmptyStatement\" || u.type === \"JSXText\" || u.type === \"JSXExpressionContainer\" && (u.expression.type === \"Literal\" || u.expression.type === \"StringLiteral\") && u.expression.value === \" \") return null;\n            if ((u.type === \"Property\" || u.type === \"ObjectProperty\" || u.type === \"MethodDefinition\" || u.type === \"ClassProperty\" || u.type === \"ClassMethod\" || u.type === \"PropertyDefinition\" || u.type === \"TSDeclareMethod\" || u.type === \"TSPropertySignature\" || u.type === \"ObjectTypeProperty\") && typeof u.key == \"object\" && u.key && (u.key.type === \"Literal\" || u.key.type === \"NumericLiteral\" || u.key.type === \"StringLiteral\" || u.key.type === \"Identifier\") && delete i.key, u.type === \"JSXElement\" && u.openingElement.name.name === \"style\" && u.openingElement.attributes.some(h => h.name.name === \"jsx\")) for (let {\n              type: h,\n              expression: g\n            } of i.children) h === \"JSXExpressionContainer\" && g.type === \"TemplateLiteral\" && a(g);\n            u.type === \"JSXAttribute\" && u.name.name === \"css\" && u.value.type === \"JSXExpressionContainer\" && u.value.expression.type === \"TemplateLiteral\" && a(i.value.expression), u.type === \"JSXAttribute\" && u.value && u.value.type === \"Literal\" && /[\"']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/[\"']|&quot;|&apos;/g, '\"'));\n            let p = u.expression || u.callee;\n            if (u.type === \"Decorator\" && p.type === \"CallExpression\" && p.callee.name === \"Component\" && p.arguments.length === 1) {\n              let h = u.expression.arguments[0].properties;\n              for (let [g, c] of i.expression.arguments[0].properties.entries()) switch (h[g].key.name) {\n                case \"styles\":\n                  c.value.type === \"ArrayExpression\" && a(c.value.elements[0]);\n                  break;\n                case \"template\":\n                  c.value.type === \"TemplateLiteral\" && a(c.value);\n                  break;\n              }\n            }\n            if (u.type === \"TaggedTemplateExpression\" && (u.tag.type === \"MemberExpression\" || u.tag.type === \"Identifier\" && (u.tag.name === \"gql\" || u.tag.name === \"graphql\" || u.tag.name === \"css\" || u.tag.name === \"md\" || u.tag.name === \"markdown\" || u.tag.name === \"html\") || u.tag.type === \"CallExpression\") && a(i.quasi), u.type === \"TemplateLiteral\") {\n              var y;\n              (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some(g => t(g) && [\"GraphQL\", \"HTML\"].some(c => g.value === ` ${c} `))) || l.type === \"CallExpression\" && l.callee.name === \"graphql\" || !u.leadingComments) && a(i);\n            }\n            if (u.type === \"InterpreterDirective\" && (i.value = i.value.trimEnd()), (u.type === \"TSIntersectionType\" || u.type === \"TSUnionType\") && u.types.length === 1) return i.types[0];\n          }\n          n.ignoredProperties = s, r.exports = n;\n        }\n      }),\n      io = {};\n    Kt(io, {\n      EOL: () => Wn,\n      arch: () => nd,\n      cpus: () => Do,\n      default: () => vo,\n      endianness: () => ao,\n      freemem: () => po,\n      getNetworkInterfaces: () => ho,\n      hostname: () => oo,\n      loadavg: () => lo,\n      networkInterfaces: () => yo,\n      platform: () => ud,\n      release: () => go,\n      tmpDir: () => $n,\n      tmpdir: () => Vn,\n      totalmem: () => fo,\n      type: () => mo,\n      uptime: () => co\n    });\n    function ao() {\n      if (typeof Tr > \"u\") {\n        var e = new ArrayBuffer(2),\n          r = new Uint8Array(e),\n          t = new Uint16Array(e);\n        if (r[0] = 1, r[1] = 2, t[0] === 258) Tr = \"BE\";else if (t[0] === 513) Tr = \"LE\";else throw new Error(\"unable to figure out endianess\");\n      }\n      return Tr;\n    }\n    function oo() {\n      return typeof globalThis.location < \"u\" ? globalThis.location.hostname : \"\";\n    }\n    function lo() {\n      return [];\n    }\n    function co() {\n      return 0;\n    }\n    function po() {\n      return Number.MAX_VALUE;\n    }\n    function fo() {\n      return Number.MAX_VALUE;\n    }\n    function Do() {\n      return [];\n    }\n    function mo() {\n      return \"Browser\";\n    }\n    function go() {\n      return typeof globalThis.navigator < \"u\" ? globalThis.navigator.appVersion : \"\";\n    }\n    function yo() {}\n    function ho() {}\n    function nd() {\n      return \"javascript\";\n    }\n    function ud() {\n      return \"browser\";\n    }\n    function $n() {\n      return \"/tmp\";\n    }\n    var Tr,\n      Vn,\n      Wn,\n      vo,\n      sd = ht({\n        \"node-modules-polyfills:os\"() {\n          ne(), Vn = $n, Wn = `\n`, vo = {\n            EOL: Wn,\n            tmpdir: Vn,\n            tmpDir: $n,\n            networkInterfaces: yo,\n            getNetworkInterfaces: ho,\n            release: go,\n            type: mo,\n            cpus: Do,\n            totalmem: fo,\n            freemem: po,\n            uptime: co,\n            loadavg: lo,\n            hostname: oo,\n            endianness: ao\n          };\n        }\n      }),\n      id = te({\n        \"node-modules-polyfills-commonjs:os\"(e, r) {\n          ne();\n          var t = (sd(), ft(io));\n          if (t && t.default) {\n            r.exports = t.default;\n            for (let s in t) r.exports[s] = t[s];\n          } else t && (r.exports = t);\n        }\n      }),\n      ad = te({\n        \"node_modules/detect-newline/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = s => {\n            if (typeof s != \"string\") throw new TypeError(\"Expected a string\");\n            let a = s.match(/(?:\\r?\\n)/g) || [];\n            if (a.length === 0) return;\n            let n = a.filter(i => i === `\\r\n`).length,\n              u = a.length - n;\n            return n > u ? `\\r\n` : `\n`;\n          };\n          r.exports = t, r.exports.graceful = s => typeof s == \"string\" && t(s) || `\n`;\n        }\n      }),\n      od = te({\n        \"node_modules/jest-docblock/build/index.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.extract = c, e.parse = F, e.parseWithComments = _, e.print = w, e.strip = f;\n          function r() {\n            let N = id();\n            return r = function () {\n              return N;\n            }, N;\n          }\n          function t() {\n            let N = s(ad());\n            return t = function () {\n              return N;\n            }, N;\n          }\n          function s(N) {\n            return N && N.__esModule ? N : {\n              default: N\n            };\n          }\n          var a = /\\*\\/$/,\n            n = /^\\/\\*\\*?/,\n            u = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/,\n            i = /(^|\\s+)\\/\\/([^\\r\\n]*)/g,\n            l = /^(\\r?\\n)+/,\n            p = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g,\n            y = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g,\n            h = /(\\r?\\n|^) *\\* ?/g,\n            g = [];\n          function c(N) {\n            let x = N.match(u);\n            return x ? x[0].trimLeft() : \"\";\n          }\n          function f(N) {\n            let x = N.match(u);\n            return x && x[0] ? N.substring(x[0].length) : N;\n          }\n          function F(N) {\n            return _(N).pragmas;\n          }\n          function _(N) {\n            let x = (0, t().default)(N) || r().EOL;\n            N = N.replace(n, \"\").replace(a, \"\").replace(h, \"$1\");\n            let I = \"\";\n            for (; I !== N;) I = N, N = N.replace(p, `${x}$1 $2${x}`);\n            N = N.replace(l, \"\").trimRight();\n            let P = Object.create(null),\n              $ = N.replace(y, \"\").replace(l, \"\").trimRight(),\n              D;\n            for (; D = y.exec(N);) {\n              let T = D[2].replace(i, \"\");\n              typeof P[D[1]] == \"string\" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;\n            }\n            return {\n              comments: $,\n              pragmas: P\n            };\n          }\n          function w(N) {\n            let {\n                comments: x = \"\",\n                pragmas: I = {}\n              } = N,\n              P = (0, t().default)(x) || r().EOL,\n              $ = \"/**\",\n              D = \" *\",\n              T = \" */\",\n              m = Object.keys(I),\n              C = m.map(d => E(d, I[d])).reduce((d, v) => d.concat(v), []).map(d => `${D} ${d}${P}`).join(\"\");\n            if (!x) {\n              if (m.length === 0) return \"\";\n              if (m.length === 1 && !Array.isArray(I[m[0]])) {\n                let d = I[m[0]];\n                return `${$} ${E(m[0], d)[0]}${T}`;\n              }\n            }\n            let o = x.split(P).map(d => `${D} ${d}`).join(P) + P;\n            return $ + P + (x ? o : \"\") + (x && m.length ? D + P : \"\") + C + T;\n          }\n          function E(N, x) {\n            return g.concat(x).map(I => `@${N} ${I}`.trim());\n          }\n        }\n      }),\n      ld = te({\n        \"src/language-js/utils/get-shebang.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s) {\n            if (!s.startsWith(\"#!\")) return \"\";\n            let a = s.indexOf(`\n`);\n            return a === -1 ? s : s.slice(0, a);\n          }\n          r.exports = t;\n        }\n      }),\n      Co = te({\n        \"src/language-js/pragma.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              parseWithComments: t,\n              strip: s,\n              extract: a,\n              print: n\n            } = od(),\n            {\n              normalizeEndOfLine: u\n            } = Jn(),\n            i = ld();\n          function l(h) {\n            let g = i(h);\n            g && (h = h.slice(g.length + 1));\n            let c = a(h),\n              {\n                pragmas: f,\n                comments: F\n              } = t(c);\n            return {\n              shebang: g,\n              text: h,\n              pragmas: f,\n              comments: F\n            };\n          }\n          function p(h) {\n            let g = Object.keys(l(h).pragmas);\n            return g.includes(\"prettier\") || g.includes(\"format\");\n          }\n          function y(h) {\n            let {\n                shebang: g,\n                text: c,\n                pragmas: f,\n                comments: F\n              } = l(h),\n              _ = s(c),\n              w = n({\n                pragmas: Object.assign({\n                  format: \"\"\n                }, f),\n                comments: F.trimStart()\n              });\n            return (g ? `${g}\n` : \"\") + u(w) + (_.startsWith(`\n`) ? `\n` : `\n\n`) + _;\n          }\n          r.exports = {\n            hasPragma: p,\n            insertPragma: y\n          };\n        }\n      }),\n      cd = te({\n        \"src/language-js/utils/is-type-cast-comment.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Pt();\n          function s(a) {\n            return t(a) && a.value[0] === \"*\" && /@(?:type|satisfies)\\b/.test(a.value);\n          }\n          r.exports = s;\n        }\n      }),\n      Eo = te({\n        \"src/language-js/comments.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              getLast: t,\n              hasNewline: s,\n              getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a,\n              getNextNonSpaceNonCommentCharacter: n,\n              hasNewlineInRange: u,\n              addLeadingComment: i,\n              addTrailingComment: l,\n              addDanglingComment: p,\n              getNextNonSpaceNonCommentCharacterIndex: y,\n              isNonEmptyArray: h\n            } = Ue(),\n            {\n              getFunctionParameters: g,\n              isPrettierIgnoreComment: c,\n              isJsxNode: f,\n              hasFlowShorthandAnnotationComment: F,\n              hasFlowAnnotationComment: _,\n              hasIgnoreComment: w,\n              isCallLikeExpression: E,\n              getCallArguments: N,\n              isCallExpression: x,\n              isMemberExpression: I,\n              isObjectProperty: P,\n              isLineComment: $,\n              getComments: D,\n              CommentCheckFlags: T,\n              markerForIfWithoutBlockAndSameLineComment: m\n            } = Ke(),\n            {\n              locStart: C,\n              locEnd: o\n            } = ut(),\n            d = Pt(),\n            v = cd();\n          function S(De) {\n            return [H, Fe, Q, q, J, L, ie, he, se, ge, we, ke, ce, z, U].some(A => A(De));\n          }\n          function b(De) {\n            return [R, Fe, V, we, q, J, L, ie, z, Z, fe, ge, Pe, U, X].some(A => A(De));\n          }\n          function B(De) {\n            return [H, q, J, j, ue, ce, ge, de, K, pe, U, oe].some(A => A(De));\n          }\n          function k(De, A) {\n            let G = (De.body || De.properties).find(re => {\n              let {\n                type: ye\n              } = re;\n              return ye !== \"EmptyStatement\";\n            });\n            G ? i(G, A) : p(De, A);\n          }\n          function M(De, A) {\n            De.type === \"BlockStatement\" ? k(De, A) : i(De, A);\n          }\n          function R(De) {\n            let {\n              comment: A,\n              followingNode: G\n            } = De;\n            return G && v(A) ? (i(G, A), !0) : !1;\n          }\n          function q(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              followingNode: ye,\n              text: Ce\n            } = De;\n            if ((re == null ? void 0 : re.type) !== \"IfStatement\" || !ye) return !1;\n            if (n(Ce, A, o) === \")\") return l(G, A), !0;\n            if (G === re.consequent && ye === re.alternate) {\n              if (G.type === \"BlockStatement\") l(G, A);else {\n                let ve = A.type === \"SingleLine\" || A.loc.start.line === A.loc.end.line,\n                  ze = A.loc.start.line === G.loc.start.line;\n                ve && ze ? p(G, A, m) : p(re, A);\n              }\n              return !0;\n            }\n            return ye.type === \"BlockStatement\" ? (k(ye, A), !0) : ye.type === \"IfStatement\" ? (M(ye.consequent, A), !0) : re.consequent === ye ? (i(ye, A), !0) : !1;\n          }\n          function J(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              followingNode: ye,\n              text: Ce\n            } = De;\n            return (re == null ? void 0 : re.type) !== \"WhileStatement\" || !ye ? !1 : n(Ce, A, o) === \")\" ? (l(G, A), !0) : ye.type === \"BlockStatement\" ? (k(ye, A), !0) : re.body === ye ? (i(ye, A), !0) : !1;\n          }\n          function L(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              followingNode: ye\n            } = De;\n            return (re == null ? void 0 : re.type) !== \"TryStatement\" && (re == null ? void 0 : re.type) !== \"CatchClause\" || !ye ? !1 : re.type === \"CatchClause\" && G ? (l(G, A), !0) : ye.type === \"BlockStatement\" ? (k(ye, A), !0) : ye.type === \"TryStatement\" ? (M(ye.finalizer, A), !0) : ye.type === \"CatchClause\" ? (M(ye.body, A), !0) : !1;\n          }\n          function Q(De) {\n            let {\n              comment: A,\n              enclosingNode: G,\n              followingNode: re\n            } = De;\n            return I(G) && (re == null ? void 0 : re.type) === \"Identifier\" ? (i(G, A), !0) : !1;\n          }\n          function V(De) {\n            let {\n                comment: A,\n                precedingNode: G,\n                enclosingNode: re,\n                followingNode: ye,\n                text: Ce\n              } = De,\n              Be = G && !u(Ce, o(G), C(A));\n            return (!G || !Be) && ((re == null ? void 0 : re.type) === \"ConditionalExpression\" || (re == null ? void 0 : re.type) === \"TSConditionalType\") && ye ? (i(ye, A), !0) : !1;\n          }\n          function j(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re\n            } = De;\n            return P(re) && re.shorthand && re.key === G && re.value.type === \"AssignmentPattern\" ? (l(re.value.left, A), !0) : !1;\n          }\n          var Y = new Set([\"ClassDeclaration\", \"ClassExpression\", \"DeclareClass\", \"DeclareInterface\", \"InterfaceDeclaration\", \"TSInterfaceDeclaration\"]);\n          function ie(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              followingNode: ye\n            } = De;\n            if (Y.has(re == null ? void 0 : re.type)) {\n              if (h(re.decorators) && !(ye && ye.type === \"Decorator\")) return l(t(re.decorators), A), !0;\n              if (re.body && ye === re.body) return k(re.body, A), !0;\n              if (ye) {\n                if (re.superClass && ye === re.superClass && G && (G === re.id || G === re.typeParameters)) return l(G, A), !0;\n                for (let Ce of [\"implements\", \"extends\", \"mixins\"]) if (re[Ce] && ye === re[Ce][0]) return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A) : p(re, A, Ce), !0;\n              }\n            }\n            return !1;\n          }\n          var ee = new Set([\"ClassMethod\", \"ClassProperty\", \"PropertyDefinition\", \"TSAbstractPropertyDefinition\", \"TSAbstractMethodDefinition\", \"TSDeclareMethod\", \"MethodDefinition\", \"ClassAccessorProperty\", \"AccessorProperty\", \"TSAbstractAccessorProperty\"]);\n          function ce(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              text: ye\n            } = De;\n            return re && G && n(ye, A, o) === \"(\" && (re.type === \"Property\" || re.type === \"TSDeclareMethod\" || re.type === \"TSAbstractMethodDefinition\") && G.type === \"Identifier\" && re.key === G && n(ye, G, o) !== \":\" || (G == null ? void 0 : G.type) === \"Decorator\" && ee.has(re == null ? void 0 : re.type) ? (l(G, A), !0) : !1;\n          }\n          var W = new Set([\"FunctionDeclaration\", \"FunctionExpression\", \"ClassMethod\", \"MethodDefinition\", \"ObjectMethod\"]);\n          function K(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              text: ye\n            } = De;\n            return n(ye, A, o) !== \"(\" ? !1 : G && W.has(re == null ? void 0 : re.type) ? (l(G, A), !0) : !1;\n          }\n          function de(De) {\n            let {\n              comment: A,\n              enclosingNode: G,\n              text: re\n            } = De;\n            if ((G == null ? void 0 : G.type) !== \"ArrowFunctionExpression\") return !1;\n            let ye = y(re, A, o);\n            return ye !== !1 && re.slice(ye, ye + 2) === \"=>\" ? (p(G, A), !0) : !1;\n          }\n          function ue(De) {\n            let {\n              comment: A,\n              enclosingNode: G,\n              text: re\n            } = De;\n            return n(re, A, o) !== \")\" ? !1 : G && (le(G) && g(G).length === 0 || E(G) && N(G).length === 0) ? (p(G, A), !0) : ((G == null ? void 0 : G.type) === \"MethodDefinition\" || (G == null ? void 0 : G.type) === \"TSAbstractMethodDefinition\") && g(G.value).length === 0 ? (p(G.value, A), !0) : !1;\n          }\n          function Fe(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              followingNode: ye,\n              text: Ce\n            } = De;\n            if ((G == null ? void 0 : G.type) === \"FunctionTypeParam\" && (re == null ? void 0 : re.type) === \"FunctionTypeAnnotation\" && (ye == null ? void 0 : ye.type) !== \"FunctionTypeParam\" || ((G == null ? void 0 : G.type) === \"Identifier\" || (G == null ? void 0 : G.type) === \"AssignmentPattern\") && re && le(re) && n(Ce, A, o) === \")\") return l(G, A), !0;\n            if ((re == null ? void 0 : re.type) === \"FunctionDeclaration\" && (ye == null ? void 0 : ye.type) === \"BlockStatement\") {\n              let Be = (() => {\n                let ve = g(re);\n                if (ve.length > 0) return a(Ce, o(t(ve)));\n                let ze = a(Ce, o(re.id));\n                return ze !== !1 && a(Ce, ze + 1);\n              })();\n              if (C(A) > Be) return k(ye, A), !0;\n            }\n            return !1;\n          }\n          function z(De) {\n            let {\n              comment: A,\n              enclosingNode: G\n            } = De;\n            return (G == null ? void 0 : G.type) === \"LabeledStatement\" ? (i(G, A), !0) : !1;\n          }\n          function U(De) {\n            let {\n              comment: A,\n              enclosingNode: G\n            } = De;\n            return ((G == null ? void 0 : G.type) === \"ContinueStatement\" || (G == null ? void 0 : G.type) === \"BreakStatement\") && !G.label ? (l(G, A), !0) : !1;\n          }\n          function Z(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re\n            } = De;\n            return x(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A), !0) : !1;\n          }\n          function se(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              followingNode: ye\n            } = De;\n            return (re == null ? void 0 : re.type) === \"UnionTypeAnnotation\" || (re == null ? void 0 : re.type) === \"TSUnionType\" ? (c(A) && (ye.prettierIgnore = !0, A.unignore = !0), G ? (l(G, A), !0) : !1) : (((ye == null ? void 0 : ye.type) === \"UnionTypeAnnotation\" || (ye == null ? void 0 : ye.type) === \"TSUnionType\") && c(A) && (ye.types[0].prettierIgnore = !0, A.unignore = !0), !1);\n          }\n          function fe(De) {\n            let {\n              comment: A,\n              enclosingNode: G\n            } = De;\n            return P(G) ? (i(G, A), !0) : !1;\n          }\n          function ge(De) {\n            let {\n              comment: A,\n              enclosingNode: G,\n              followingNode: re,\n              ast: ye,\n              isLastComment: Ce\n            } = De;\n            return ye && ye.body && ye.body.length === 0 ? (Ce ? p(ye, A) : i(ye, A), !0) : (G == null ? void 0 : G.type) === \"Program\" && (G == null ? void 0 : G.body.length) === 0 && !h(G.directives) ? (Ce ? p(G, A) : i(G, A), !0) : (re == null ? void 0 : re.type) === \"Program\" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === \"ModuleExpression\" ? (p(re, A), !0) : !1;\n          }\n          function he(De) {\n            let {\n              comment: A,\n              enclosingNode: G\n            } = De;\n            return (G == null ? void 0 : G.type) === \"ForInStatement\" || (G == null ? void 0 : G.type) === \"ForOfStatement\" ? (i(G, A), !0) : !1;\n          }\n          function we(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              text: ye\n            } = De;\n            if ((re == null ? void 0 : re.type) === \"ImportSpecifier\" || (re == null ? void 0 : re.type) === \"ExportSpecifier\") return i(re, A), !0;\n            let Ce = (G == null ? void 0 : G.type) === \"ImportSpecifier\" && (re == null ? void 0 : re.type) === \"ImportDeclaration\",\n              Be = (G == null ? void 0 : G.type) === \"ExportSpecifier\" && (re == null ? void 0 : re.type) === \"ExportNamedDeclaration\";\n            return (Ce || Be) && s(ye, o(A)) ? (l(G, A), !0) : !1;\n          }\n          function ke(De) {\n            let {\n              comment: A,\n              enclosingNode: G\n            } = De;\n            return (G == null ? void 0 : G.type) === \"AssignmentPattern\" ? (i(G, A), !0) : !1;\n          }\n          var Re = new Set([\"VariableDeclarator\", \"AssignmentExpression\", \"TypeAlias\", \"TSTypeAliasDeclaration\"]),\n            Ne = new Set([\"ObjectExpression\", \"ArrayExpression\", \"TemplateLiteral\", \"TaggedTemplateExpression\", \"ObjectTypeAnnotation\", \"TSTypeLiteral\"]);\n          function Pe(De) {\n            let {\n              comment: A,\n              enclosingNode: G,\n              followingNode: re\n            } = De;\n            return Re.has(G == null ? void 0 : G.type) && re && (Ne.has(re.type) || d(A)) ? (i(re, A), !0) : !1;\n          }\n          function oe(De) {\n            let {\n              comment: A,\n              enclosingNode: G,\n              followingNode: re,\n              text: ye\n            } = De;\n            return !re && ((G == null ? void 0 : G.type) === \"TSMethodSignature\" || (G == null ? void 0 : G.type) === \"TSDeclareFunction\" || (G == null ? void 0 : G.type) === \"TSAbstractMethodDefinition\") && n(ye, A, o) === \";\" ? (l(G, A), !0) : !1;\n          }\n          function H(De) {\n            let {\n              comment: A,\n              enclosingNode: G,\n              followingNode: re\n            } = De;\n            if (c(A) && (G == null ? void 0 : G.type) === \"TSMappedType\" && (re == null ? void 0 : re.type) === \"TSTypeParameter\" && re.constraint) return G.prettierIgnore = !0, A.unignore = !0, !0;\n          }\n          function pe(De) {\n            let {\n              comment: A,\n              precedingNode: G,\n              enclosingNode: re,\n              followingNode: ye\n            } = De;\n            return (re == null ? void 0 : re.type) !== \"TSMappedType\" ? !1 : (ye == null ? void 0 : ye.type) === \"TSTypeParameter\" && ye.name ? (i(ye.name, A), !0) : (G == null ? void 0 : G.type) === \"TSTypeParameter\" && G.constraint ? (l(G.constraint, A), !0) : !1;\n          }\n          function X(De) {\n            let {\n              comment: A,\n              enclosingNode: G,\n              followingNode: re\n            } = De;\n            return !G || G.type !== \"SwitchCase\" || G.test || !re || re !== G.consequent[0] ? !1 : (re.type === \"BlockStatement\" && $(A) ? k(re, A) : p(G, A), !0);\n          }\n          function le(De) {\n            return De.type === \"ArrowFunctionExpression\" || De.type === \"FunctionExpression\" || De.type === \"FunctionDeclaration\" || De.type === \"ObjectMethod\" || De.type === \"ClassMethod\" || De.type === \"TSDeclareFunction\" || De.type === \"TSCallSignatureDeclaration\" || De.type === \"TSConstructSignatureDeclaration\" || De.type === \"TSMethodSignature\" || De.type === \"TSConstructorType\" || De.type === \"TSFunctionType\" || De.type === \"TSDeclareMethod\";\n          }\n          function Ae(De, A) {\n            if ((A.parser === \"typescript\" || A.parser === \"flow\" || A.parser === \"acorn\" || A.parser === \"espree\" || A.parser === \"meriyah\" || A.parser === \"__babel_estree\") && De.type === \"MethodDefinition\" && De.value && De.value.type === \"FunctionExpression\" && g(De.value).length === 0 && !De.value.returnType && !h(De.value.typeParameters) && De.value.body) return [...(De.decorators || []), De.key, De.value.body];\n          }\n          function Ee(De) {\n            let A = De.getValue(),\n              G = De.getParentNode(),\n              re = ye => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));\n            return (A && (f(A) || F(A) || x(G) && re(A)) || G && (G.type === \"JSXSpreadAttribute\" || G.type === \"JSXSpreadChild\" || G.type === \"UnionTypeAnnotation\" || G.type === \"TSUnionType\" || (G.type === \"ClassDeclaration\" || G.type === \"ClassExpression\") && G.superClass === A)) && (!w(De) || G.type === \"UnionTypeAnnotation\" || G.type === \"TSUnionType\");\n          }\n          r.exports = {\n            handleOwnLineComment: S,\n            handleEndOfLineComment: b,\n            handleRemainingComment: B,\n            getCommentChildNodes: Ae,\n            willPrintOwnComments: Ee\n          };\n        }\n      }),\n      qt = te({\n        \"src/language-js/needs-parens.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = lt(),\n            s = Kn(),\n            {\n              getFunctionParameters: a,\n              getLeftSidePathName: n,\n              hasFlowShorthandAnnotationComment: u,\n              hasNakedLeftSide: i,\n              hasNode: l,\n              isBitwiseOperator: p,\n              startsWithNoLookaheadToken: y,\n              shouldFlatten: h,\n              getPrecedence: g,\n              isCallExpression: c,\n              isMemberExpression: f,\n              isObjectProperty: F,\n              isTSTypeExpression: _\n            } = Ke();\n          function w(D, T) {\n            let m = D.getParentNode();\n            if (!m) return !1;\n            let C = D.getName(),\n              o = D.getNode();\n            if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D)) return !0;\n            if (E(o)) return !1;\n            if (T.parser !== \"flow\" && u(D.getValue())) return !0;\n            if (o.type === \"Identifier\") {\n              if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(o.name) || C === \"left\" && (o.name === \"async\" && !m.await || o.name === \"let\") && m.type === \"ForOfStatement\") return !0;\n              if (o.name === \"let\") {\n                var d;\n                let S = (d = D.findAncestor(b => b.type === \"ForOfStatement\")) === null || d === void 0 ? void 0 : d.left;\n                if (S && y(S, b => b === o)) return !0;\n              }\n              if (C === \"object\" && o.name === \"let\" && m.type === \"MemberExpression\" && m.computed && !m.optional) {\n                let S = D.findAncestor(B => B.type === \"ExpressionStatement\" || B.type === \"ForStatement\" || B.type === \"ForInStatement\"),\n                  b = S ? S.type === \"ExpressionStatement\" ? S.expression : S.type === \"ForStatement\" ? S.init : S.left : void 0;\n                if (b && y(b, B => B === o)) return !0;\n              }\n              return !1;\n            }\n            if (o.type === \"ObjectExpression\" || o.type === \"FunctionExpression\" || o.type === \"ClassExpression\" || o.type === \"DoExpression\") {\n              var v;\n              let S = (v = D.findAncestor(b => b.type === \"ExpressionStatement\")) === null || v === void 0 ? void 0 : v.expression;\n              if (S && y(S, b => b === o)) return !0;\n            }\n            switch (m.type) {\n              case \"ParenthesizedExpression\":\n                return !1;\n              case \"ClassDeclaration\":\n              case \"ClassExpression\":\n                {\n                  if (C === \"superClass\" && (o.type === \"ArrowFunctionExpression\" || o.type === \"AssignmentExpression\" || o.type === \"AwaitExpression\" || o.type === \"BinaryExpression\" || o.type === \"ConditionalExpression\" || o.type === \"LogicalExpression\" || o.type === \"NewExpression\" || o.type === \"ObjectExpression\" || o.type === \"SequenceExpression\" || o.type === \"TaggedTemplateExpression\" || o.type === \"UnaryExpression\" || o.type === \"UpdateExpression\" || o.type === \"YieldExpression\" || o.type === \"TSNonNullExpression\")) return !0;\n                  break;\n                }\n              case \"ExportDefaultDeclaration\":\n                return $(D, T) || o.type === \"SequenceExpression\";\n              case \"Decorator\":\n                {\n                  if (C === \"expression\") {\n                    if (f(o) && o.computed) return !0;\n                    let S = !1,\n                      b = !1,\n                      B = o;\n                    for (; B;) switch (B.type) {\n                      case \"MemberExpression\":\n                        b = !0, B = B.object;\n                        break;\n                      case \"CallExpression\":\n                        if (b || S) return T.parser !== \"typescript\";\n                        S = !0, B = B.callee;\n                        break;\n                      case \"Identifier\":\n                        return !1;\n                      case \"TaggedTemplateExpression\":\n                        return T.parser !== \"typescript\";\n                      default:\n                        return !0;\n                    }\n                    return !0;\n                  }\n                  break;\n                }\n              case \"ArrowFunctionExpression\":\n                {\n                  if (C === \"body\" && o.type !== \"SequenceExpression\" && y(o, S => S.type === \"ObjectExpression\")) return !0;\n                  break;\n                }\n            }\n            switch (o.type) {\n              case \"UpdateExpression\":\n                if (m.type === \"UnaryExpression\") return o.prefix && (o.operator === \"++\" && m.operator === \"+\" || o.operator === \"--\" && m.operator === \"-\");\n              case \"UnaryExpression\":\n                switch (m.type) {\n                  case \"UnaryExpression\":\n                    return o.operator === m.operator && (o.operator === \"+\" || o.operator === \"-\");\n                  case \"BindExpression\":\n                    return !0;\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return C === \"object\";\n                  case \"TaggedTemplateExpression\":\n                    return !0;\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return C === \"callee\";\n                  case \"BinaryExpression\":\n                    return C === \"left\" && m.operator === \"**\";\n                  case \"TSNonNullExpression\":\n                    return !0;\n                  default:\n                    return !1;\n                }\n              case \"BinaryExpression\":\n                {\n                  if (m.type === \"UpdateExpression\" || o.operator === \"in\" && N(D)) return !0;\n                  if (o.operator === \"|>\" && o.extra && o.extra.parenthesized) {\n                    let S = D.getParentNode(1);\n                    if (S.type === \"BinaryExpression\" && S.operator === \"|>\") return !0;\n                  }\n                }\n              case \"TSTypeAssertion\":\n              case \"TSAsExpression\":\n              case \"TSSatisfiesExpression\":\n              case \"LogicalExpression\":\n                switch (m.type) {\n                  case \"TSSatisfiesExpression\":\n                  case \"TSAsExpression\":\n                    return !_(o);\n                  case \"ConditionalExpression\":\n                    return _(o);\n                  case \"CallExpression\":\n                  case \"NewExpression\":\n                  case \"OptionalCallExpression\":\n                    return C === \"callee\";\n                  case \"ClassExpression\":\n                  case \"ClassDeclaration\":\n                    return C === \"superClass\";\n                  case \"TSTypeAssertion\":\n                  case \"TaggedTemplateExpression\":\n                  case \"UnaryExpression\":\n                  case \"JSXSpreadAttribute\":\n                  case \"SpreadElement\":\n                  case \"SpreadProperty\":\n                  case \"BindExpression\":\n                  case \"AwaitExpression\":\n                  case \"TSNonNullExpression\":\n                  case \"UpdateExpression\":\n                    return !0;\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return C === \"object\";\n                  case \"AssignmentExpression\":\n                  case \"AssignmentPattern\":\n                    return C === \"left\" && (o.type === \"TSTypeAssertion\" || _(o));\n                  case \"LogicalExpression\":\n                    if (o.type === \"LogicalExpression\") return m.operator !== o.operator;\n                  case \"BinaryExpression\":\n                    {\n                      let {\n                        operator: S,\n                        type: b\n                      } = o;\n                      if (!S && b !== \"TSTypeAssertion\") return !0;\n                      let B = g(S),\n                        k = m.operator,\n                        M = g(k);\n                      return M > B || C === \"right\" && M === B || M === B && !h(k, S) ? !0 : M < B && S === \"%\" ? k === \"+\" || k === \"-\" : !!p(k);\n                    }\n                  default:\n                    return !1;\n                }\n              case \"SequenceExpression\":\n                switch (m.type) {\n                  case \"ReturnStatement\":\n                    return !1;\n                  case \"ForStatement\":\n                    return !1;\n                  case \"ExpressionStatement\":\n                    return C !== \"expression\";\n                  case \"ArrowFunctionExpression\":\n                    return C !== \"body\";\n                  default:\n                    return !0;\n                }\n              case \"YieldExpression\":\n                if (m.type === \"UnaryExpression\" || m.type === \"AwaitExpression\" || _(m) || m.type === \"TSNonNullExpression\") return !0;\n              case \"AwaitExpression\":\n                switch (m.type) {\n                  case \"TaggedTemplateExpression\":\n                  case \"UnaryExpression\":\n                  case \"LogicalExpression\":\n                  case \"SpreadElement\":\n                  case \"SpreadProperty\":\n                  case \"TSAsExpression\":\n                  case \"TSSatisfiesExpression\":\n                  case \"TSNonNullExpression\":\n                  case \"BindExpression\":\n                    return !0;\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return C === \"object\";\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return C === \"callee\";\n                  case \"ConditionalExpression\":\n                    return C === \"test\";\n                  case \"BinaryExpression\":\n                    return !(!o.argument && m.operator === \"|>\");\n                  default:\n                    return !1;\n                }\n              case \"TSConditionalType\":\n              case \"TSFunctionType\":\n              case \"TSConstructorType\":\n                if (C === \"extendsType\" && m.type === \"TSConditionalType\") {\n                  if (o.type === \"TSConditionalType\") return !0;\n                  let {\n                    typeAnnotation: S\n                  } = o.returnType || o.typeAnnotation;\n                  if (S.type === \"TSTypePredicate\" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === \"TSInferType\" && S.typeParameter.constraint) return !0;\n                }\n                if (C === \"checkType\" && m.type === \"TSConditionalType\") return !0;\n              case \"TSUnionType\":\n              case \"TSIntersectionType\":\n                if ((m.type === \"TSUnionType\" || m.type === \"TSIntersectionType\") && m.types.length > 1 && (!o.types || o.types.length > 1)) return !0;\n              case \"TSInferType\":\n                if (o.type === \"TSInferType\" && m.type === \"TSRestType\") return !1;\n              case \"TSTypeOperator\":\n                return m.type === \"TSArrayType\" || m.type === \"TSOptionalType\" || m.type === \"TSRestType\" || C === \"objectType\" && m.type === \"TSIndexedAccessType\" || m.type === \"TSTypeOperator\" || m.type === \"TSTypeAnnotation\" && D.getParentNode(1).type.startsWith(\"TSJSDoc\");\n              case \"TSTypeQuery\":\n                return C === \"objectType\" && m.type === \"TSIndexedAccessType\" || C === \"elementType\" && m.type === \"TSArrayType\";\n              case \"TypeofTypeAnnotation\":\n                return C === \"objectType\" && (m.type === \"IndexedAccessType\" || m.type === \"OptionalIndexedAccessType\") || C === \"elementType\" && m.type === \"ArrayTypeAnnotation\";\n              case \"ArrayTypeAnnotation\":\n                return m.type === \"NullableTypeAnnotation\";\n              case \"IntersectionTypeAnnotation\":\n              case \"UnionTypeAnnotation\":\n                return m.type === \"ArrayTypeAnnotation\" || m.type === \"NullableTypeAnnotation\" || m.type === \"IntersectionTypeAnnotation\" || m.type === \"UnionTypeAnnotation\" || C === \"objectType\" && (m.type === \"IndexedAccessType\" || m.type === \"OptionalIndexedAccessType\");\n              case \"NullableTypeAnnotation\":\n                return m.type === \"ArrayTypeAnnotation\" || C === \"objectType\" && (m.type === \"IndexedAccessType\" || m.type === \"OptionalIndexedAccessType\");\n              case \"FunctionTypeAnnotation\":\n                {\n                  let S = m.type === \"NullableTypeAnnotation\" ? D.getParentNode(1) : m;\n                  return S.type === \"UnionTypeAnnotation\" || S.type === \"IntersectionTypeAnnotation\" || S.type === \"ArrayTypeAnnotation\" || C === \"objectType\" && (S.type === \"IndexedAccessType\" || S.type === \"OptionalIndexedAccessType\") || S.type === \"NullableTypeAnnotation\" || m.type === \"FunctionTypeParam\" && m.name === null && a(o).some(b => b.typeAnnotation && b.typeAnnotation.type === \"NullableTypeAnnotation\");\n                }\n              case \"OptionalIndexedAccessType\":\n                return C === \"objectType\" && m.type === \"IndexedAccessType\";\n              case \"StringLiteral\":\n              case \"NumericLiteral\":\n              case \"Literal\":\n                if (typeof o.value == \"string\" && m.type === \"ExpressionStatement\" && !m.directive) {\n                  let S = D.getParentNode(1);\n                  return S.type === \"Program\" || S.type === \"BlockStatement\";\n                }\n                return C === \"object\" && m.type === \"MemberExpression\" && typeof o.value == \"number\";\n              case \"AssignmentExpression\":\n                {\n                  let S = D.getParentNode(1);\n                  return C === \"body\" && m.type === \"ArrowFunctionExpression\" ? !0 : C === \"key\" && (m.type === \"ClassProperty\" || m.type === \"PropertyDefinition\") && m.computed || (C === \"init\" || C === \"update\") && m.type === \"ForStatement\" ? !1 : m.type === \"ExpressionStatement\" ? o.left.type === \"ObjectPattern\" : !(C === \"key\" && m.type === \"TSPropertySignature\" || m.type === \"AssignmentExpression\" || m.type === \"SequenceExpression\" && S && S.type === \"ForStatement\" && (S.init === m || S.update === m) || C === \"value\" && m.type === \"Property\" && S && S.type === \"ObjectPattern\" && S.properties.includes(m) || m.type === \"NGChainedExpression\");\n                }\n              case \"ConditionalExpression\":\n                switch (m.type) {\n                  case \"TaggedTemplateExpression\":\n                  case \"UnaryExpression\":\n                  case \"SpreadElement\":\n                  case \"SpreadProperty\":\n                  case \"BinaryExpression\":\n                  case \"LogicalExpression\":\n                  case \"NGPipeExpression\":\n                  case \"ExportDefaultDeclaration\":\n                  case \"AwaitExpression\":\n                  case \"JSXSpreadAttribute\":\n                  case \"TSTypeAssertion\":\n                  case \"TypeCastExpression\":\n                  case \"TSAsExpression\":\n                  case \"TSSatisfiesExpression\":\n                  case \"TSNonNullExpression\":\n                    return !0;\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return C === \"callee\";\n                  case \"ConditionalExpression\":\n                    return C === \"test\";\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return C === \"object\";\n                  default:\n                    return !1;\n                }\n              case \"FunctionExpression\":\n                switch (m.type) {\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return C === \"callee\";\n                  case \"TaggedTemplateExpression\":\n                    return !0;\n                  default:\n                    return !1;\n                }\n              case \"ArrowFunctionExpression\":\n                switch (m.type) {\n                  case \"BinaryExpression\":\n                    return m.operator !== \"|>\" || o.extra && o.extra.parenthesized;\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return C === \"callee\";\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return C === \"object\";\n                  case \"TSAsExpression\":\n                  case \"TSSatisfiesExpression\":\n                  case \"TSNonNullExpression\":\n                  case \"BindExpression\":\n                  case \"TaggedTemplateExpression\":\n                  case \"UnaryExpression\":\n                  case \"LogicalExpression\":\n                  case \"AwaitExpression\":\n                  case \"TSTypeAssertion\":\n                    return !0;\n                  case \"ConditionalExpression\":\n                    return C === \"test\";\n                  default:\n                    return !1;\n                }\n              case \"ClassExpression\":\n                if (s(o.decorators)) return !0;\n                switch (m.type) {\n                  case \"NewExpression\":\n                    return C === \"callee\";\n                  default:\n                    return !1;\n                }\n              case \"OptionalMemberExpression\":\n              case \"OptionalCallExpression\":\n                {\n                  let S = D.getParentNode(1);\n                  if (C === \"object\" && m.type === \"MemberExpression\" || C === \"callee\" && (m.type === \"CallExpression\" || m.type === \"NewExpression\") || m.type === \"TSNonNullExpression\" && S.type === \"MemberExpression\" && S.object === m) return !0;\n                }\n              case \"CallExpression\":\n              case \"MemberExpression\":\n              case \"TaggedTemplateExpression\":\n              case \"TSNonNullExpression\":\n                if (C === \"callee\" && (m.type === \"BindExpression\" || m.type === \"NewExpression\")) {\n                  let S = o;\n                  for (; S;) switch (S.type) {\n                    case \"CallExpression\":\n                    case \"OptionalCallExpression\":\n                      return !0;\n                    case \"MemberExpression\":\n                    case \"OptionalMemberExpression\":\n                    case \"BindExpression\":\n                      S = S.object;\n                      break;\n                    case \"TaggedTemplateExpression\":\n                      S = S.tag;\n                      break;\n                    case \"TSNonNullExpression\":\n                      S = S.expression;\n                      break;\n                    default:\n                      return !1;\n                  }\n                }\n                return !1;\n              case \"BindExpression\":\n                return C === \"callee\" && (m.type === \"BindExpression\" || m.type === \"NewExpression\") || C === \"object\" && f(m);\n              case \"NGPipeExpression\":\n                return !(m.type === \"NGRoot\" || m.type === \"NGMicrosyntaxExpression\" || m.type === \"ObjectProperty\" && !(o.extra && o.extra.parenthesized) || m.type === \"ArrayExpression\" || c(m) && m.arguments[C] === o || C === \"right\" && m.type === \"NGPipeExpression\" || C === \"property\" && m.type === \"MemberExpression\" || m.type === \"AssignmentExpression\");\n              case \"JSXFragment\":\n              case \"JSXElement\":\n                return C === \"callee\" || C === \"left\" && m.type === \"BinaryExpression\" && m.operator === \"<\" || m.type !== \"ArrayExpression\" && m.type !== \"ArrowFunctionExpression\" && m.type !== \"AssignmentExpression\" && m.type !== \"AssignmentPattern\" && m.type !== \"BinaryExpression\" && m.type !== \"NewExpression\" && m.type !== \"ConditionalExpression\" && m.type !== \"ExpressionStatement\" && m.type !== \"JsExpressionRoot\" && m.type !== \"JSXAttribute\" && m.type !== \"JSXElement\" && m.type !== \"JSXExpressionContainer\" && m.type !== \"JSXFragment\" && m.type !== \"LogicalExpression\" && !c(m) && !F(m) && m.type !== \"ReturnStatement\" && m.type !== \"ThrowStatement\" && m.type !== \"TypeCastExpression\" && m.type !== \"VariableDeclarator\" && m.type !== \"YieldExpression\";\n              case \"TypeAnnotation\":\n                return C === \"returnType\" && m.type === \"ArrowFunctionExpression\" && x(o);\n            }\n            return !1;\n          }\n          function E(D) {\n            return D.type === \"BlockStatement\" || D.type === \"BreakStatement\" || D.type === \"ClassBody\" || D.type === \"ClassDeclaration\" || D.type === \"ClassMethod\" || D.type === \"ClassProperty\" || D.type === \"PropertyDefinition\" || D.type === \"ClassPrivateProperty\" || D.type === \"ContinueStatement\" || D.type === \"DebuggerStatement\" || D.type === \"DeclareClass\" || D.type === \"DeclareExportAllDeclaration\" || D.type === \"DeclareExportDeclaration\" || D.type === \"DeclareFunction\" || D.type === \"DeclareInterface\" || D.type === \"DeclareModule\" || D.type === \"DeclareModuleExports\" || D.type === \"DeclareVariable\" || D.type === \"DoWhileStatement\" || D.type === \"EnumDeclaration\" || D.type === \"ExportAllDeclaration\" || D.type === \"ExportDefaultDeclaration\" || D.type === \"ExportNamedDeclaration\" || D.type === \"ExpressionStatement\" || D.type === \"ForInStatement\" || D.type === \"ForOfStatement\" || D.type === \"ForStatement\" || D.type === \"FunctionDeclaration\" || D.type === \"IfStatement\" || D.type === \"ImportDeclaration\" || D.type === \"InterfaceDeclaration\" || D.type === \"LabeledStatement\" || D.type === \"MethodDefinition\" || D.type === \"ReturnStatement\" || D.type === \"SwitchStatement\" || D.type === \"ThrowStatement\" || D.type === \"TryStatement\" || D.type === \"TSDeclareFunction\" || D.type === \"TSEnumDeclaration\" || D.type === \"TSImportEqualsDeclaration\" || D.type === \"TSInterfaceDeclaration\" || D.type === \"TSModuleDeclaration\" || D.type === \"TSNamespaceExportDeclaration\" || D.type === \"TypeAlias\" || D.type === \"VariableDeclaration\" || D.type === \"WhileStatement\" || D.type === \"WithStatement\";\n          }\n          function N(D) {\n            let T = 0,\n              m = D.getValue();\n            for (; m;) {\n              let C = D.getParentNode(T++);\n              if (C && C.type === \"ForStatement\" && C.init === m) return !0;\n              m = C;\n            }\n            return !1;\n          }\n          function x(D) {\n            return l(D, T => T.type === \"ObjectTypeAnnotation\" && l(T, m => m.type === \"FunctionTypeAnnotation\" || void 0) || void 0);\n          }\n          function I(D) {\n            switch (D.type) {\n              case \"ObjectExpression\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          function P(D) {\n            let T = D.getValue(),\n              m = D.getParentNode(),\n              C = D.getName();\n            switch (m.type) {\n              case \"NGPipeExpression\":\n                if (typeof C == \"number\" && m.arguments[C] === T && m.arguments.length - 1 === C) return D.callParent(P);\n                break;\n              case \"ObjectProperty\":\n                if (C === \"value\") {\n                  let o = D.getParentNode(1);\n                  return t(o.properties) === m;\n                }\n                break;\n              case \"BinaryExpression\":\n              case \"LogicalExpression\":\n                if (C === \"right\") return D.callParent(P);\n                break;\n              case \"ConditionalExpression\":\n                if (C === \"alternate\") return D.callParent(P);\n                break;\n              case \"UnaryExpression\":\n                if (m.prefix) return D.callParent(P);\n                break;\n            }\n            return !1;\n          }\n          function $(D, T) {\n            let m = D.getValue(),\n              C = D.getParentNode();\n            return m.type === \"FunctionExpression\" || m.type === \"ClassExpression\" ? C.type === \"ExportDefaultDeclaration\" || !w(D, T) : !i(m) || C.type !== \"ExportDefaultDeclaration\" && w(D, T) ? !1 : D.call(o => $(o, T), ...n(D, m));\n          }\n          r.exports = w;\n        }\n      }),\n      Fo = te({\n        \"src/language-js/print-preprocess.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s, a) {\n            switch (a.parser) {\n              case \"json\":\n              case \"json5\":\n              case \"json-stringify\":\n              case \"__js_expression\":\n              case \"__vue_expression\":\n              case \"__vue_ts_expression\":\n                return Object.assign(Object.assign({}, s), {}, {\n                  type: a.parser.startsWith(\"__\") ? \"JsExpressionRoot\" : \"JsonRoot\",\n                  node: s,\n                  comments: [],\n                  rootMarker: a.rootMarker\n                });\n              default:\n                return s;\n            }\n          }\n          r.exports = t;\n        }\n      }),\n      pd = te({\n        \"src/language-js/print/html-binding.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            builders: {\n              join: t,\n              line: s,\n              group: a,\n              softline: n,\n              indent: u\n            }\n          } = qe();\n          function i(p, y, h) {\n            let g = p.getValue();\n            if (y.__onHtmlBindingRoot && p.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === \"File\") {\n              if (y.__isVueForBindingLeft) return p.call(c => {\n                let f = t([\",\", s], c.map(h, \"params\")),\n                  {\n                    params: F\n                  } = c.getValue();\n                return F.length === 1 ? f : [\"(\", u([n, a(f)]), n, \")\"];\n              }, \"program\", \"body\", 0);\n              if (y.__isVueBindings) return p.call(c => t([\",\", s], c.map(h, \"params\")), \"program\", \"body\", 0);\n            }\n          }\n          function l(p) {\n            switch (p.type) {\n              case \"MemberExpression\":\n                switch (p.property.type) {\n                  case \"Identifier\":\n                  case \"NumericLiteral\":\n                  case \"StringLiteral\":\n                    return l(p.object);\n                }\n                return !1;\n              case \"Identifier\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          r.exports = {\n            isVueEventBindingExpression: l,\n            printHtmlBinding: i\n          };\n        }\n      }),\n      ru = te({\n        \"src/language-js/print/binaryish.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printComments: t\n            } = et(),\n            {\n              getLast: s\n            } = Ue(),\n            {\n              builders: {\n                join: a,\n                line: n,\n                softline: u,\n                group: i,\n                indent: l,\n                align: p,\n                indentIfBreak: y\n              },\n              utils: {\n                cleanDoc: h,\n                getDocParts: g,\n                isConcat: c\n              }\n            } = qe(),\n            {\n              hasLeadingOwnLineComment: f,\n              isBinaryish: F,\n              isJsxNode: _,\n              shouldFlatten: w,\n              hasComment: E,\n              CommentCheckFlags: N,\n              isCallExpression: x,\n              isMemberExpression: I,\n              isObjectProperty: P,\n              isEnabledHackPipeline: $\n            } = Ke(),\n            D = 0;\n          function T(o, d, v) {\n            let S = o.getValue(),\n              b = o.getParentNode(),\n              B = o.getParentNode(1),\n              k = S !== b.body && (b.type === \"IfStatement\" || b.type === \"WhileStatement\" || b.type === \"SwitchStatement\" || b.type === \"DoWhileStatement\"),\n              M = $(d) && S.operator === \"|>\",\n              R = m(o, v, d, !1, k);\n            if (k) return R;\n            if (M) return i(R);\n            if (x(b) && b.callee === S || b.type === \"UnaryExpression\" || I(b) && !b.computed) return i([l([u, ...R]), u]);\n            let q = b.type === \"ReturnStatement\" || b.type === \"ThrowStatement\" || b.type === \"JSXExpressionContainer\" && B.type === \"JSXAttribute\" || S.operator !== \"|\" && b.type === \"JsExpressionRoot\" || S.type !== \"NGPipeExpression\" && (b.type === \"NGRoot\" && d.parser === \"__ng_binding\" || b.type === \"NGMicrosyntaxExpression\" && B.type === \"NGMicrosyntax\" && B.body.length === 1) || S === b.body && b.type === \"ArrowFunctionExpression\" || S !== b.body && b.type === \"ForStatement\" || b.type === \"ConditionalExpression\" && B.type !== \"ReturnStatement\" && B.type !== \"ThrowStatement\" && !x(B) || b.type === \"TemplateLiteral\",\n              J = b.type === \"AssignmentExpression\" || b.type === \"VariableDeclarator\" || b.type === \"ClassProperty\" || b.type === \"PropertyDefinition\" || b.type === \"TSAbstractPropertyDefinition\" || b.type === \"ClassPrivateProperty\" || P(b),\n              L = F(S.left) && w(S.operator, S.left.operator);\n            if (q || C(S) && !L || !C(S) && J) return i(R);\n            if (R.length === 0) return \"\";\n            let Q = _(S.right),\n              V = R.findIndex(W => typeof W != \"string\" && !Array.isArray(W) && W.type === \"group\"),\n              j = R.slice(0, V === -1 ? 1 : V + 1),\n              Y = R.slice(j.length, Q ? -1 : void 0),\n              ie = Symbol(\"logicalChain-\" + ++D),\n              ee = i([...j, l(Y)], {\n                id: ie\n              });\n            if (!Q) return ee;\n            let ce = s(R);\n            return i([ee, y(ce, {\n              groupId: ie\n            })]);\n          }\n          function m(o, d, v, S, b) {\n            let B = o.getValue();\n            if (!F(B)) return [i(d())];\n            let k = [];\n            w(B.operator, B.left.operator) ? k = o.call(Y => m(Y, d, v, !0, b), \"left\") : k.push(i(d(\"left\")));\n            let M = C(B),\n              R = (B.operator === \"|>\" || B.type === \"NGPipeExpression\" || B.operator === \"|\" && v.parser === \"__vue_expression\") && !f(v.originalText, B.right),\n              q = B.type === \"NGPipeExpression\" ? \"|\" : B.operator,\n              J = B.type === \"NGPipeExpression\" && B.arguments.length > 0 ? i(l([n, \": \", a([n, \": \"], o.map(d, \"arguments\").map(Y => p(2, i(Y))))])) : \"\",\n              L;\n            if (M) L = [q, \" \", d(\"right\"), J];else {\n              let ie = $(v) && q === \"|>\" ? o.call(ee => m(ee, d, v, !0, b), \"right\") : d(\"right\");\n              L = [R ? n : \"\", q, R ? \" \" : n, ie, J];\n            }\n            let Q = o.getParentNode(),\n              V = E(B.left, N.Trailing | N.Line),\n              j = V || !(b && B.type === \"LogicalExpression\") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;\n            if (k.push(R ? \"\" : \" \", j ? i(L, {\n              shouldBreak: V\n            }) : L), S && E(B)) {\n              let Y = h(t(o, k, v));\n              return c(Y) || Y.type === \"fill\" ? g(Y) : [Y];\n            }\n            return k;\n          }\n          function C(o) {\n            return o.type !== \"LogicalExpression\" ? !1 : !!(o.right.type === \"ObjectExpression\" && o.right.properties.length > 0 || o.right.type === \"ArrayExpression\" && o.right.elements.length > 0 || _(o.right));\n          }\n          r.exports = {\n            printBinaryishExpression: T,\n            shouldInlineLogicalExpression: C\n          };\n        }\n      }),\n      fd = te({\n        \"src/language-js/print/angular.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                join: t,\n                line: s,\n                group: a\n              }\n            } = qe(),\n            {\n              hasNode: n,\n              hasComment: u,\n              getComments: i\n            } = Ke(),\n            {\n              printBinaryishExpression: l\n            } = ru();\n          function p(g, c, f) {\n            let F = g.getValue();\n            if (F.type.startsWith(\"NG\")) switch (F.type) {\n              case \"NGRoot\":\n                return [f(\"node\"), u(F.node) ? \" //\" + i(F.node)[0].value.trimEnd() : \"\"];\n              case \"NGPipeExpression\":\n                return l(g, c, f);\n              case \"NGChainedExpression\":\n                return a(t([\";\", s], g.map(_ => h(_) ? f() : [\"(\", f(), \")\"], \"expressions\")));\n              case \"NGEmptyExpression\":\n                return \"\";\n              case \"NGQuotedExpression\":\n                return [F.prefix, \": \", F.value.trim()];\n              case \"NGMicrosyntax\":\n                return g.map((_, w) => [w === 0 ? \"\" : y(_.getValue(), w, F) ? \" \" : [\";\", s], f()], \"body\");\n              case \"NGMicrosyntaxKey\":\n                return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(F.name) ? F.name : JSON.stringify(F.name);\n              case \"NGMicrosyntaxExpression\":\n                return [f(\"expression\"), F.alias === null ? \"\" : [\" as \", f(\"alias\")]];\n              case \"NGMicrosyntaxKeyedExpression\":\n                {\n                  let _ = g.getName(),\n                    w = g.getParentNode(),\n                    E = y(F, _, w) || (_ === 1 && (F.key.name === \"then\" || F.key.name === \"else\") || _ === 2 && F.key.name === \"else\" && w.body[_ - 1].type === \"NGMicrosyntaxKeyedExpression\" && w.body[_ - 1].key.name === \"then\") && w.body[0].type === \"NGMicrosyntaxExpression\";\n                  return [f(\"key\"), E ? \" \" : \": \", f(\"expression\")];\n                }\n              case \"NGMicrosyntaxLet\":\n                return [\"let \", f(\"key\"), F.value === null ? \"\" : [\" = \", f(\"value\")]];\n              case \"NGMicrosyntaxAs\":\n                return [f(\"key\"), \" as \", f(\"alias\")];\n              default:\n                throw new Error(`Unknown Angular node type: ${JSON.stringify(F.type)}.`);\n            }\n          }\n          function y(g, c, f) {\n            return g.type === \"NGMicrosyntaxKeyedExpression\" && g.key.name === \"of\" && c === 1 && f.body[0].type === \"NGMicrosyntaxLet\" && f.body[0].value === null;\n          }\n          function h(g) {\n            return n(g.getValue(), c => {\n              switch (c.type) {\n                case void 0:\n                  return !1;\n                case \"CallExpression\":\n                case \"OptionalCallExpression\":\n                case \"AssignmentExpression\":\n                  return !0;\n              }\n            });\n          }\n          r.exports = {\n            printAngular: p\n          };\n        }\n      }),\n      Dd = te({\n        \"src/language-js/print/jsx.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printComments: t,\n              printDanglingComments: s,\n              printCommentsSeparately: a\n            } = et(),\n            {\n              builders: {\n                line: n,\n                hardline: u,\n                softline: i,\n                group: l,\n                indent: p,\n                conditionalGroup: y,\n                fill: h,\n                ifBreak: g,\n                lineSuffixBoundary: c,\n                join: f\n              },\n              utils: {\n                willBreak: F\n              }\n            } = qe(),\n            {\n              getLast: _,\n              getPreferredQuote: w\n            } = Ue(),\n            {\n              isJsxNode: E,\n              rawText: N,\n              isCallExpression: x,\n              isStringLiteral: I,\n              isBinaryish: P,\n              hasComment: $,\n              CommentCheckFlags: D,\n              hasNodeIgnoreComment: T\n            } = Ke(),\n            m = qt(),\n            {\n              willPrintOwnComments: C\n            } = Eo(),\n            o = U => U === \"\" || U === n || U === u || U === i;\n          function d(U, Z, se) {\n            let fe = U.getValue();\n            if (fe.type === \"JSXElement\" && de(fe)) return [se(\"openingElement\"), se(\"closingElement\")];\n            let ge = fe.type === \"JSXElement\" ? se(\"openingElement\") : se(\"openingFragment\"),\n              he = fe.type === \"JSXElement\" ? se(\"closingElement\") : se(\"closingFragment\");\n            if (fe.children.length === 1 && fe.children[0].type === \"JSXExpressionContainer\" && (fe.children[0].expression.type === \"TemplateLiteral\" || fe.children[0].expression.type === \"TaggedTemplateExpression\")) return [ge, ...U.map(se, \"children\"), he];\n            fe.children = fe.children.map(A => Fe(A) ? {\n              type: \"JSXText\",\n              value: \" \",\n              raw: \" \"\n            } : A);\n            let we = fe.children.some(E),\n              ke = fe.children.filter(A => A.type === \"JSXExpressionContainer\").length > 1,\n              Re = fe.type === \"JSXElement\" && fe.openingElement.attributes.length > 1,\n              Ne = F(ge) || we || Re || ke,\n              Pe = U.getParentNode().rootMarker === \"mdx\",\n              oe = Z.singleQuote ? \"{' '}\" : '{\" \"}',\n              H = Pe ? \" \" : g([oe, i], \" \"),\n              pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === \"fbt\",\n              X = v(U, Z, se, H, pe),\n              le = fe.children.some(A => ue(A));\n            for (let A = X.length - 2; A >= 0; A--) {\n              let G = X[A] === \"\" && X[A + 1] === \"\",\n                re = X[A] === u && X[A + 1] === \"\" && X[A + 2] === u,\n                ye = (X[A] === i || X[A] === u) && X[A + 1] === \"\" && X[A + 2] === H,\n                Ce = X[A] === H && X[A + 1] === \"\" && (X[A + 2] === i || X[A + 2] === u),\n                Be = X[A] === H && X[A + 1] === \"\" && X[A + 2] === H,\n                ve = X[A] === i && X[A + 1] === \"\" && X[A + 2] === u || X[A] === u && X[A + 1] === \"\" && X[A + 2] === i;\n              re && le || G || ye || Be || ve ? X.splice(A, 2) : Ce && X.splice(A + 1, 2);\n            }\n            for (; X.length > 0 && o(_(X));) X.pop();\n            for (; X.length > 1 && o(X[0]) && o(X[1]);) X.shift(), X.shift();\n            let Ae = [];\n            for (let [A, G] of X.entries()) {\n              if (G === H) {\n                if (A === 1 && X[A - 1] === \"\") {\n                  if (X.length === 2) {\n                    Ae.push(oe);\n                    continue;\n                  }\n                  Ae.push([oe, u]);\n                  continue;\n                } else if (A === X.length - 1) {\n                  Ae.push(oe);\n                  continue;\n                } else if (X[A - 1] === \"\" && X[A - 2] === u) {\n                  Ae.push(oe);\n                  continue;\n                }\n              }\n              Ae.push(G), F(G) && (Ne = !0);\n            }\n            let Ee = le ? h(Ae) : l(Ae, {\n              shouldBreak: !0\n            });\n            if (Pe) return Ee;\n            let De = l([ge, p([u, Ee]), u, he]);\n            return Ne ? De : y([l([ge, ...X, he]), De]);\n          }\n          function v(U, Z, se, fe, ge) {\n            let he = [];\n            return U.each((we, ke, Re) => {\n              let Ne = we.getValue();\n              if (Ne.type === \"JSXText\") {\n                let Pe = N(Ne);\n                if (ue(Ne)) {\n                  let oe = Pe.split(ce);\n                  if (oe[0] === \"\") {\n                    if (he.push(\"\"), oe.shift(), /\\n/.test(oe[0])) {\n                      let pe = Re[ke + 1];\n                      he.push(b(ge, oe[1], Ne, pe));\n                    } else he.push(fe);\n                    oe.shift();\n                  }\n                  let H;\n                  if (_(oe) === \"\" && (oe.pop(), H = oe.pop()), oe.length === 0) return;\n                  for (let [pe, X] of oe.entries()) pe % 2 === 1 ? he.push(n) : he.push(X);\n                  if (H !== void 0) {\n                    if (/\\n/.test(H)) {\n                      let pe = Re[ke + 1];\n                      he.push(b(ge, _(he), Ne, pe));\n                    } else he.push(fe);\n                  } else {\n                    let pe = Re[ke + 1];\n                    he.push(S(ge, _(he), Ne, pe));\n                  }\n                } else /\\n/.test(Pe) ? Pe.match(/\\n/g).length > 1 && he.push(\"\", u) : he.push(\"\", fe);\n              } else {\n                let Pe = se();\n                he.push(Pe);\n                let oe = Re[ke + 1];\n                if (oe && ue(oe)) {\n                  let pe = K(N(oe)).split(ce)[0];\n                  he.push(S(ge, pe, Ne, oe));\n                } else he.push(u);\n              }\n            }, \"children\"), he;\n          }\n          function S(U, Z, se, fe) {\n            return U ? \"\" : se.type === \"JSXElement\" && !se.closingElement || fe && fe.type === \"JSXElement\" && !fe.closingElement ? Z.length === 1 ? i : u : i;\n          }\n          function b(U, Z, se, fe) {\n            return U ? u : Z.length === 1 ? se.type === \"JSXElement\" && !se.closingElement || fe && fe.type === \"JSXElement\" && !fe.closingElement ? u : i : u;\n          }\n          function B(U, Z, se) {\n            let fe = U.getParentNode();\n            if (!fe || {\n              ArrayExpression: !0,\n              JSXAttribute: !0,\n              JSXElement: !0,\n              JSXExpressionContainer: !0,\n              JSXFragment: !0,\n              ExpressionStatement: !0,\n              CallExpression: !0,\n              OptionalCallExpression: !0,\n              ConditionalExpression: !0,\n              JsExpressionRoot: !0\n            }[fe.type]) return Z;\n            let he = U.match(void 0, ke => ke.type === \"ArrowFunctionExpression\", x, ke => ke.type === \"JSXExpressionContainer\"),\n              we = m(U, se);\n            return l([we ? \"\" : g(\"(\"), p([i, Z]), i, we ? \"\" : g(\")\")], {\n              shouldBreak: he\n            });\n          }\n          function k(U, Z, se) {\n            let fe = U.getValue(),\n              ge = [];\n            if (ge.push(se(\"name\")), fe.value) {\n              let he;\n              if (I(fe.value)) {\n                let ke = N(fe.value).slice(1, -1).replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"'),\n                  {\n                    escaped: Re,\n                    quote: Ne,\n                    regex: Pe\n                  } = w(ke, Z.jsxSingleQuote ? \"'\" : '\"');\n                ke = ke.replace(Pe, Re);\n                let {\n                  leading: oe,\n                  trailing: H\n                } = U.call(() => a(U, Z), \"value\");\n                he = [oe, Ne, ke, Ne, H];\n              } else he = se(\"value\");\n              ge.push(\"=\", he);\n            }\n            return ge;\n          }\n          function M(U, Z, se) {\n            let fe = U.getValue(),\n              ge = (he, we) => he.type === \"JSXEmptyExpression\" || !$(he) && (he.type === \"ArrayExpression\" || he.type === \"ObjectExpression\" || he.type === \"ArrowFunctionExpression\" || he.type === \"AwaitExpression\" && (ge(he.argument, he) || he.argument.type === \"JSXElement\") || x(he) || he.type === \"FunctionExpression\" || he.type === \"TemplateLiteral\" || he.type === \"TaggedTemplateExpression\" || he.type === \"DoExpression\" || E(we) && (he.type === \"ConditionalExpression\" || P(he)));\n            return ge(fe.expression, U.getParentNode(0)) ? l([\"{\", se(\"expression\"), c, \"}\"]) : l([\"{\", p([i, se(\"expression\")]), i, c, \"}\"]);\n          }\n          function R(U, Z, se) {\n            let fe = U.getValue(),\n              ge = fe.name && $(fe.name) || fe.typeParameters && $(fe.typeParameters);\n            if (fe.selfClosing && fe.attributes.length === 0 && !ge) return [\"<\", se(\"name\"), se(\"typeParameters\"), \" />\"];\n            if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`\n`) && !ge && !$(fe.attributes[0])) return l([\"<\", se(\"name\"), se(\"typeParameters\"), \" \", ...U.map(se, \"attributes\"), fe.selfClosing ? \" />\" : \">\"]);\n            let he = fe.attributes && fe.attributes.some(ke => ke.value && I(ke.value) && ke.value.value.includes(`\n`)),\n              we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n;\n            return l([\"<\", se(\"name\"), se(\"typeParameters\"), p(U.map(() => [we, se()], \"attributes\")), ...q(fe, Z, ge)], {\n              shouldBreak: he\n            });\n          }\n          function q(U, Z, se) {\n            return U.selfClosing ? [n, \"/>\"] : J(U, Z, se) ? [\">\"] : [i, \">\"];\n          }\n          function J(U, Z, se) {\n            let fe = U.attributes.length > 0 && $(_(U.attributes), D.Trailing);\n            return U.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U.attributes.length > 0) && !fe;\n          }\n          function L(U, Z, se) {\n            let fe = U.getValue(),\n              ge = [];\n            ge.push(\"</\");\n            let he = se(\"name\");\n            return $(fe.name, D.Leading | D.Line) ? ge.push(p([u, he]), u) : $(fe.name, D.Leading | D.Block) ? ge.push(\" \", he) : ge.push(he), ge.push(\">\"), ge;\n          }\n          function Q(U, Z) {\n            let se = U.getValue(),\n              fe = $(se),\n              ge = $(se, D.Line),\n              he = se.type === \"JSXOpeningFragment\";\n            return [he ? \"<\" : \"</\", p([ge ? u : fe && !he ? \" \" : \"\", s(U, Z, !0)]), ge ? u : \"\", \">\"];\n          }\n          function V(U, Z, se) {\n            let fe = t(U, d(U, Z, se), Z);\n            return B(U, fe, Z);\n          }\n          function j(U, Z) {\n            let se = U.getValue(),\n              fe = $(se, D.Line);\n            return [s(U, Z, !fe), fe ? u : \"\"];\n          }\n          function Y(U, Z, se) {\n            let fe = U.getValue();\n            return [\"{\", U.call(ge => {\n              let he = [\"...\", se()],\n                we = ge.getValue();\n              return !$(we) || !C(ge) ? he : [p([i, t(ge, he, Z)]), i];\n            }, fe.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"];\n          }\n          function ie(U, Z, se) {\n            let fe = U.getValue();\n            if (fe.type.startsWith(\"JSX\")) switch (fe.type) {\n              case \"JSXAttribute\":\n                return k(U, Z, se);\n              case \"JSXIdentifier\":\n                return String(fe.name);\n              case \"JSXNamespacedName\":\n                return f(\":\", [se(\"namespace\"), se(\"name\")]);\n              case \"JSXMemberExpression\":\n                return f(\".\", [se(\"object\"), se(\"property\")]);\n              case \"JSXSpreadAttribute\":\n                return Y(U, Z, se);\n              case \"JSXSpreadChild\":\n                return Y(U, Z, se);\n              case \"JSXExpressionContainer\":\n                return M(U, Z, se);\n              case \"JSXFragment\":\n              case \"JSXElement\":\n                return V(U, Z, se);\n              case \"JSXOpeningElement\":\n                return R(U, Z, se);\n              case \"JSXClosingElement\":\n                return L(U, Z, se);\n              case \"JSXOpeningFragment\":\n              case \"JSXClosingFragment\":\n                return Q(U, Z);\n              case \"JSXEmptyExpression\":\n                return j(U, Z);\n              case \"JSXText\":\n                throw new Error(\"JSXText should be handled by JSXElement\");\n              default:\n                throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);\n            }\n          }\n          var ee = ` \n\\r\t`,\n            ce = new RegExp(\"([\" + ee + \"]+)\"),\n            W = new RegExp(\"[^\" + ee + \"]\"),\n            K = U => U.replace(new RegExp(\"(?:^\" + ce.source + \"|\" + ce.source + \"$)\"), \"\");\n          function de(U) {\n            if (U.children.length === 0) return !0;\n            if (U.children.length > 1) return !1;\n            let Z = U.children[0];\n            return Z.type === \"JSXText\" && !ue(Z);\n          }\n          function ue(U) {\n            return U.type === \"JSXText\" && (W.test(N(U)) || !/\\n/.test(N(U)));\n          }\n          function Fe(U) {\n            return U.type === \"JSXExpressionContainer\" && I(U.expression) && U.expression.value === \" \" && !$(U.expression);\n          }\n          function z(U) {\n            let Z = U.getValue(),\n              se = U.getParentNode();\n            if (!se || !Z || !E(Z) || !E(se)) return !1;\n            let fe = se.children.indexOf(Z),\n              ge = null;\n            for (let he = fe; he > 0; he--) {\n              let we = se.children[he - 1];\n              if (!(we.type === \"JSXText\" && !ue(we))) {\n                ge = we;\n                break;\n              }\n            }\n            return ge && ge.type === \"JSXExpressionContainer\" && ge.expression.type === \"JSXEmptyExpression\" && T(ge.expression);\n          }\n          r.exports = {\n            hasJsxIgnoreComment: z,\n            printJsx: ie\n          };\n        }\n      }),\n      ct = te({\n        \"src/language-js/print/misc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isNonEmptyArray: t\n            } = Ue(),\n            {\n              builders: {\n                indent: s,\n                join: a,\n                line: n\n              }\n            } = qe(),\n            {\n              isFlowAnnotationComment: u\n            } = Ke();\n          function i(_) {\n            let w = _.getValue();\n            return !w.optional || w.type === \"Identifier\" && w === _.getParentNode().key ? \"\" : w.type === \"OptionalCallExpression\" || w.type === \"OptionalMemberExpression\" && w.computed ? \"?.\" : \"?\";\n          }\n          function l(_) {\n            return _.getValue().definite || _.match(void 0, (w, E) => E === \"id\" && w.type === \"VariableDeclarator\" && w.definite) ? \"!\" : \"\";\n          }\n          function p(_, w, E) {\n            let N = _.getValue();\n            return N.typeArguments ? E(\"typeArguments\") : N.typeParameters ? E(\"typeParameters\") : \"\";\n          }\n          function y(_, w, E) {\n            let N = _.getValue();\n            if (!N.typeAnnotation) return \"\";\n            let x = _.getParentNode(),\n              I = x.type === \"DeclareFunction\" && x.id === N;\n            return u(w.originalText, N.typeAnnotation) ? [\" /*: \", E(\"typeAnnotation\"), \" */\"] : [I ? \"\" : \": \", E(\"typeAnnotation\")];\n          }\n          function h(_, w, E) {\n            return [\"::\", E(\"callee\")];\n          }\n          function g(_, w, E) {\n            let N = _.getValue();\n            return t(N.modifiers) ? [a(\" \", _.map(E, \"modifiers\")), \" \"] : \"\";\n          }\n          function c(_, w, E) {\n            return _.type === \"EmptyStatement\" ? \";\" : _.type === \"BlockStatement\" || E ? [\" \", w] : s([n, w]);\n          }\n          function f(_, w, E) {\n            return [\"...\", E(\"argument\"), y(_, w, E)];\n          }\n          function F(_, w) {\n            let E = _.slice(1, -1);\n            if (E.includes('\"') || E.includes(\"'\")) return _;\n            let N = w.singleQuote ? \"'\" : '\"';\n            return N + E + N;\n          }\n          r.exports = {\n            printOptionalToken: i,\n            printDefiniteToken: l,\n            printFunctionTypeParameters: p,\n            printBindExpressionCallee: h,\n            printTypeScriptModifiers: g,\n            printTypeAnnotation: y,\n            printRestSpread: f,\n            adjustClause: c,\n            printDirective: F\n          };\n        }\n      }),\n      er = te({\n        \"src/language-js/print/array.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              builders: {\n                line: s,\n                softline: a,\n                hardline: n,\n                group: u,\n                indent: i,\n                ifBreak: l,\n                fill: p\n              }\n            } = qe(),\n            {\n              getLast: y,\n              hasNewline: h\n            } = Ue(),\n            {\n              shouldPrintComma: g,\n              hasComment: c,\n              CommentCheckFlags: f,\n              isNextLineEmpty: F,\n              isNumericLiteral: _,\n              isSignedNumericLiteral: w\n            } = Ke(),\n            {\n              locStart: E\n            } = ut(),\n            {\n              printOptionalToken: N,\n              printTypeAnnotation: x\n            } = ct();\n          function I(T, m, C) {\n            let o = T.getValue(),\n              d = [],\n              v = o.type === \"TupleExpression\" ? \"#[\" : \"[\",\n              S = \"]\";\n            if (o.elements.length === 0) c(o, f.Dangling) ? d.push(u([v, t(T, m), a, S])) : d.push(v, S);else {\n              let b = y(o.elements),\n                B = !(b && b.type === \"RestElement\"),\n                k = b === null,\n                M = Symbol(\"array\"),\n                R = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {\n                  let j = L && L.type;\n                  if (j !== \"ArrayExpression\" && j !== \"ObjectExpression\") return !1;\n                  let Y = V[Q + 1];\n                  if (Y && j !== Y.type) return !1;\n                  let ie = j === \"ArrayExpression\" ? \"elements\" : \"properties\";\n                  return L[ie] && L[ie].length > 1;\n                }),\n                q = P(o, m),\n                J = B ? k ? \",\" : g(m) ? q ? l(\",\", \"\", {\n                  groupId: M\n                }) : l(\",\") : \"\" : \"\";\n              d.push(u([v, i([a, q ? D(T, m, C, J) : [$(T, m, \"elements\", C), J], t(T, m, !0)]), a, S], {\n                shouldBreak: R,\n                id: M\n              }));\n            }\n            return d.push(N(T), x(T, m, C)), d;\n          }\n          function P(T, m) {\n            return T.elements.length > 1 && T.elements.every(C => C && (_(C) || w(C) && !c(C.argument)) && !c(C, f.Trailing | f.Line, o => !h(m.originalText, E(o), {\n              backwards: !0\n            })));\n          }\n          function $(T, m, C, o) {\n            let d = [],\n              v = [];\n            return T.each(S => {\n              d.push(v, u(o())), v = [\",\", s], S.getValue() && F(S.getValue(), m) && v.push(a);\n            }, C), d;\n          }\n          function D(T, m, C, o) {\n            let d = [];\n            return T.each((v, S, b) => {\n              let B = S === b.length - 1;\n              d.push([C(), B ? o : \",\"]), B || d.push(F(v.getValue(), m) ? [n, n] : c(b[S + 1], f.Leading | f.Line) ? n : s);\n            }, \"elements\"), p(d);\n          }\n          r.exports = {\n            printArray: I,\n            printArrayItems: $,\n            isConciselyPrintedArray: P\n          };\n        }\n      }),\n      Ao = te({\n        \"src/language-js/print/call-arguments.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              getLast: s,\n              getPenultimate: a\n            } = Ue(),\n            {\n              getFunctionParameters: n,\n              hasComment: u,\n              CommentCheckFlags: i,\n              isFunctionCompositionArgs: l,\n              isJsxNode: p,\n              isLongCurriedCallExpression: y,\n              shouldPrintComma: h,\n              getCallArguments: g,\n              iterateCallArgumentsPath: c,\n              isNextLineEmpty: f,\n              isCallExpression: F,\n              isStringLiteral: _,\n              isObjectProperty: w,\n              isTSTypeExpression: E\n            } = Ke(),\n            {\n              builders: {\n                line: N,\n                hardline: x,\n                softline: I,\n                group: P,\n                indent: $,\n                conditionalGroup: D,\n                ifBreak: T,\n                breakParent: m\n              },\n              utils: {\n                willBreak: C\n              }\n            } = qe(),\n            {\n              ArgExpansionBailout: o\n            } = Qt(),\n            {\n              isConciselyPrintedArray: d\n            } = er();\n          function v(q, J, L) {\n            let Q = q.getValue(),\n              V = Q.type === \"ImportExpression\",\n              j = g(Q);\n            if (j.length === 0) return [\"(\", t(q, J, !0), \")\"];\n            if (k(j)) return [\"(\", L([\"arguments\", 0]), \", \", L([\"arguments\", 1]), \")\"];\n            let Y = !1,\n              ie = !1,\n              ee = j.length - 1,\n              ce = [];\n            c(q, (z, U) => {\n              let Z = z.getNode(),\n                se = [L()];\n              U === ee || (f(Z, J) ? (U === 0 && (ie = !0), Y = !0, se.push(\",\", x, x)) : se.push(\",\", N)), ce.push(se);\n            });\n            let W = !(V || Q.callee && Q.callee.type === \"Import\") && h(J, \"all\") ? \",\" : \"\";\n            function K() {\n              return P([\"(\", $([N, ...ce]), W, N, \")\"], {\n                shouldBreak: !0\n              });\n            }\n            if (Y || q.getParentNode().type !== \"Decorator\" && l(j)) return K();\n            let de = B(j),\n              ue = b(j, J);\n            if (de || ue) {\n              if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C)) return K();\n              let z = [];\n              try {\n                q.try(() => {\n                  c(q, (U, Z) => {\n                    de && Z === 0 && (z = [[L([], {\n                      expandFirstArg: !0\n                    }), ce.length > 1 ? \",\" : \"\", ie ? x : N, ie ? x : \"\"], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], {\n                      expandLastArg: !0\n                    })]);\n                  });\n                });\n              } catch (U) {\n                if (U instanceof o) return K();\n                throw U;\n              }\n              return [ce.some(C) ? m : \"\", D([[\"(\", ...z, \")\"], de ? [\"(\", P(z[0], {\n                shouldBreak: !0\n              }), ...z.slice(1), \")\"] : [\"(\", ...ce.slice(0, -1), P(s(z), {\n                shouldBreak: !0\n              }), \")\"], K()])];\n            }\n            let Fe = [\"(\", $([I, ...ce]), T(W), I, \")\"];\n            return y(q) ? Fe : P(Fe, {\n              shouldBreak: ce.some(C) || Y\n            });\n          }\n          function S(q) {\n            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n            return q.type === \"ObjectExpression\" && (q.properties.length > 0 || u(q)) || q.type === \"ArrayExpression\" && (q.elements.length > 0 || u(q)) || q.type === \"TSTypeAssertion\" && S(q.expression) || E(q) && S(q.expression) || q.type === \"FunctionExpression\" || q.type === \"ArrowFunctionExpression\" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== \"TSTypeReference\" || M(q.body)) && (q.body.type === \"BlockStatement\" || q.body.type === \"ArrowFunctionExpression\" && S(q.body, !0) || q.body.type === \"ObjectExpression\" || q.body.type === \"ArrayExpression\" || !J && (F(q.body) || q.body.type === \"ConditionalExpression\") || p(q.body)) || q.type === \"DoExpression\" || q.type === \"ModuleExpression\";\n          }\n          function b(q, J) {\n            let L = s(q),\n              Q = a(q);\n            return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q.length !== 2 || Q.type !== \"ArrowFunctionExpression\" || L.type !== \"ArrayExpression\") && !(q.length > 1 && L.type === \"ArrayExpression\" && d(L, J));\n          }\n          function B(q) {\n            if (q.length !== 2) return !1;\n            let [J, L] = q;\n            return J.type === \"ModuleExpression\" && R(L) ? !0 : !u(J) && (J.type === \"FunctionExpression\" || J.type === \"ArrowFunctionExpression\" && J.body.type === \"BlockStatement\") && L.type !== \"FunctionExpression\" && L.type !== \"ArrowFunctionExpression\" && L.type !== \"ConditionalExpression\" && !S(L);\n          }\n          function k(q) {\n            return q.length === 2 && q[0].type === \"ArrowFunctionExpression\" && n(q[0]).length === 0 && q[0].body.type === \"BlockStatement\" && q[1].type === \"ArrayExpression\" && !q.some(J => u(J));\n          }\n          function M(q) {\n            return q.type === \"BlockStatement\" && (q.body.some(J => J.type !== \"EmptyStatement\") || u(q, i.Dangling));\n          }\n          function R(q) {\n            return q.type === \"ObjectExpression\" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === \"Identifier\" && q.properties[0].key.name === \"type\" && _(q.properties[0].value) && q.properties[0].value.value === \"module\";\n          }\n          r.exports = v;\n        }\n      }),\n      So = te({\n        \"src/language-js/print/member.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                softline: t,\n                group: s,\n                indent: a,\n                label: n\n              }\n            } = qe(),\n            {\n              isNumericLiteral: u,\n              isMemberExpression: i,\n              isCallExpression: l\n            } = Ke(),\n            {\n              printOptionalToken: p\n            } = ct();\n          function y(g, c, f) {\n            let F = g.getValue(),\n              _ = g.getParentNode(),\n              w,\n              E = 0;\n            do w = g.getParentNode(E), E++; while (w && (i(w) || w.type === \"TSNonNullExpression\"));\n            let N = f(\"object\"),\n              x = h(g, c, f),\n              I = w && (w.type === \"NewExpression\" || w.type === \"BindExpression\" || w.type === \"AssignmentExpression\" && w.left.type !== \"Identifier\") || F.computed || F.object.type === \"Identifier\" && F.property.type === \"Identifier\" && !i(_) || (_.type === \"AssignmentExpression\" || _.type === \"VariableDeclarator\") && (l(F.object) && F.object.arguments.length > 0 || F.object.type === \"TSNonNullExpression\" && l(F.object.expression) && F.object.expression.arguments.length > 0 || N.label === \"member-chain\");\n            return n(N.label === \"member-chain\" ? \"member-chain\" : \"member\", [N, I ? x : s(a([t, x]))]);\n          }\n          function h(g, c, f) {\n            let F = f(\"property\"),\n              _ = g.getValue(),\n              w = p(g);\n            return _.computed ? !_.property || u(_.property) ? [w, \"[\", F, \"]\"] : s([w, \"[\", a([t, F]), t, \"]\"]) : [w, \".\", F];\n          }\n          r.exports = {\n            printMemberExpression: y,\n            printMemberLookup: h\n          };\n        }\n      }),\n      md = te({\n        \"src/language-js/print/member-chain.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printComments: t\n            } = et(),\n            {\n              getLast: s,\n              isNextLineEmptyAfterIndex: a,\n              getNextNonSpaceNonCommentCharacterIndex: n\n            } = Ue(),\n            u = qt(),\n            {\n              isCallExpression: i,\n              isMemberExpression: l,\n              isFunctionOrArrowExpression: p,\n              isLongCurriedCallExpression: y,\n              isMemberish: h,\n              isNumericLiteral: g,\n              isSimpleCallArgument: c,\n              hasComment: f,\n              CommentCheckFlags: F,\n              isNextLineEmpty: _\n            } = Ke(),\n            {\n              locEnd: w\n            } = ut(),\n            {\n              builders: {\n                join: E,\n                hardline: N,\n                group: x,\n                indent: I,\n                conditionalGroup: P,\n                breakParent: $,\n                label: D\n              },\n              utils: {\n                willBreak: T\n              }\n            } = qe(),\n            m = Ao(),\n            {\n              printMemberLookup: C\n            } = So(),\n            {\n              printOptionalToken: o,\n              printFunctionTypeParameters: d,\n              printBindExpressionCallee: v\n            } = ct();\n          function S(b, B, k) {\n            let M = b.getParentNode(),\n              R = !M || M.type === \"ExpressionStatement\",\n              q = [];\n            function J(Ne) {\n              let {\n                  originalText: Pe\n                } = B,\n                oe = n(Pe, Ne, w);\n              return Pe.charAt(oe) === \")\" ? oe !== !1 && a(Pe, oe + 1) : _(Ne, B);\n            }\n            function L(Ne) {\n              let Pe = Ne.getValue();\n              i(Pe) && (h(Pe.callee) || i(Pe.callee)) ? (q.unshift({\n                node: Pe,\n                printed: [t(Ne, [o(Ne), d(Ne, B, k), m(Ne, B, k)], B), J(Pe) ? N : \"\"]\n              }), Ne.call(oe => L(oe), \"callee\")) : h(Pe) ? (q.unshift({\n                node: Pe,\n                needsParens: u(Ne, B),\n                printed: t(Ne, l(Pe) ? C(Ne, B, k) : v(Ne, B, k), B)\n              }), Ne.call(oe => L(oe), \"object\")) : Pe.type === \"TSNonNullExpression\" ? (q.unshift({\n                node: Pe,\n                printed: t(Ne, \"!\", B)\n              }), Ne.call(oe => L(oe), \"expression\")) : q.unshift({\n                node: Pe,\n                printed: k()\n              });\n            }\n            let Q = b.getValue();\n            q.unshift({\n              node: Q,\n              printed: [o(b), d(b, B, k), m(b, B, k)]\n            }), Q.callee && b.call(Ne => L(Ne), \"callee\");\n            let V = [],\n              j = [q[0]],\n              Y = 1;\n            for (; Y < q.length && (q[Y].node.type === \"TSNonNullExpression\" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g(q[Y].node.property)); ++Y) j.push(q[Y]);\n            if (!i(q[0].node)) for (; Y + 1 < q.length && h(q[Y].node) && h(q[Y + 1].node); ++Y) j.push(q[Y]);\n            V.push(j), j = [];\n            let ie = !1;\n            for (; Y < q.length; ++Y) {\n              if (ie && h(q[Y].node)) {\n                if (q[Y].node.computed && g(q[Y].node.property)) {\n                  j.push(q[Y]);\n                  continue;\n                }\n                V.push(j), j = [], ie = !1;\n              }\n              (i(q[Y].node) || q[Y].node.type === \"ImportExpression\") && (ie = !0), j.push(q[Y]), f(q[Y].node, F.Trailing) && (V.push(j), j = [], ie = !1);\n            }\n            j.length > 0 && V.push(j);\n            function ee(Ne) {\n              return /^[A-Z]|^[$_]+$/.test(Ne);\n            }\n            function ce(Ne) {\n              return Ne.length <= B.tabWidth;\n            }\n            function W(Ne) {\n              let Pe = Ne[1].length > 0 && Ne[1][0].node.computed;\n              if (Ne[0].length === 1) {\n                let H = Ne[0][0].node;\n                return H.type === \"ThisExpression\" || H.type === \"Identifier\" && (ee(H.name) || R && ce(H.name) || Pe);\n              }\n              let oe = s(Ne[0]).node;\n              return l(oe) && oe.property.type === \"Identifier\" && (ee(oe.property.name) || Pe);\n            }\n            let K = V.length >= 2 && !f(V[1][0].node) && W(V);\n            function de(Ne) {\n              let Pe = Ne.map(oe => oe.printed);\n              return Ne.length > 0 && s(Ne).needsParens ? [\"(\", ...Pe, \")\"] : Pe;\n            }\n            function ue(Ne) {\n              return Ne.length === 0 ? \"\" : I(x([N, E(N, Ne.map(de))]));\n            }\n            let Fe = V.map(de),\n              z = Fe,\n              U = K ? 3 : 2,\n              Z = V.flat(),\n              se = Z.slice(1, -1).some(Ne => f(Ne.node, F.Leading)) || Z.slice(0, -1).some(Ne => f(Ne.node, F.Trailing)) || V[U] && f(V[U][0].node, F.Leading);\n            if (V.length <= U && !se) return y(b) ? z : x(z);\n            let fe = s(V[K ? 1 : 0]).node,\n              ge = !i(fe) && J(fe),\n              he = [de(V[0]), K ? V.slice(1, 2).map(de) : \"\", ge ? N : \"\", ue(V.slice(K ? 2 : 1))],\n              we = q.map(Ne => {\n                let {\n                  node: Pe\n                } = Ne;\n                return Pe;\n              }).filter(i);\n            function ke() {\n              let Ne = s(s(V)).node,\n                Pe = s(Fe);\n              return i(Ne) && T(Pe) && we.slice(0, -1).some(oe => oe.arguments.some(p));\n            }\n            let Re;\n            return se || we.length > 2 && we.some(Ne => !Ne.arguments.every(Pe => c(Pe, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x(he) : Re = [T(z) || ge ? $ : \"\", P([z, he])], D(\"member-chain\", Re);\n          }\n          r.exports = S;\n        }\n      }),\n      xo = te({\n        \"src/language-js/print/call-expression.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                join: t,\n                group: s\n              }\n            } = qe(),\n            a = qt(),\n            {\n              getCallArguments: n,\n              hasFlowAnnotationComment: u,\n              isCallExpression: i,\n              isMemberish: l,\n              isStringLiteral: p,\n              isTemplateOnItsOwnLine: y,\n              isTestCall: h,\n              iterateCallArgumentsPath: g\n            } = Ke(),\n            c = md(),\n            f = Ao(),\n            {\n              printOptionalToken: F,\n              printFunctionTypeParameters: _\n            } = ct();\n          function w(N, x, I) {\n            let P = N.getValue(),\n              $ = N.getParentNode(),\n              D = P.type === \"NewExpression\",\n              T = P.type === \"ImportExpression\",\n              m = F(N),\n              C = n(P);\n            if (C.length > 0 && (!T && !D && E(P, $) || C.length === 1 && y(C[0], x.originalText) || !D && h(P, $))) {\n              let v = [];\n              return g(N, () => {\n                v.push(I());\n              }), [D ? \"new \" : \"\", I(\"callee\"), m, _(N, x, I), \"(\", t(\", \", v), \")\"];\n            }\n            let o = (x.parser === \"babel\" || x.parser === \"babel-flow\") && P.callee && P.callee.type === \"Identifier\" && u(P.callee.trailingComments);\n            if (o && (P.callee.trailingComments[0].printed = !0), !T && !D && l(P.callee) && !N.call(v => a(v, x), \"callee\")) return c(N, x, I);\n            let d = [D ? \"new \" : \"\", T ? \"import\" : I(\"callee\"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : \"\", _(N, x, I), f(N, x, I)];\n            return T || i(P.callee) ? s(d) : d;\n          }\n          function E(N, x) {\n            if (N.callee.type !== \"Identifier\") return !1;\n            if (N.callee.name === \"require\") return !0;\n            if (N.callee.name === \"define\") {\n              let I = n(N);\n              return x.type === \"ExpressionStatement\" && (I.length === 1 || I.length === 2 && I[0].type === \"ArrayExpression\" || I.length === 3 && p(I[0]) && I[1].type === \"ArrayExpression\");\n            }\n            return !1;\n          }\n          r.exports = {\n            printCallExpression: w\n          };\n        }\n      }),\n      tr = te({\n        \"src/language-js/print/assignment.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isNonEmptyArray: t,\n              getStringWidth: s\n            } = Ue(),\n            {\n              builders: {\n                line: a,\n                group: n,\n                indent: u,\n                indentIfBreak: i,\n                lineSuffixBoundary: l\n              },\n              utils: {\n                cleanDoc: p,\n                willBreak: y,\n                canBreak: h\n              }\n            } = qe(),\n            {\n              hasLeadingOwnLineComment: g,\n              isBinaryish: c,\n              isStringLiteral: f,\n              isLiteral: F,\n              isNumericLiteral: _,\n              isCallExpression: w,\n              isMemberExpression: E,\n              getCallArguments: N,\n              rawText: x,\n              hasComment: I,\n              isSignedNumericLiteral: P,\n              isObjectProperty: $\n            } = Ke(),\n            {\n              shouldInlineLogicalExpression: D\n            } = ru(),\n            {\n              printCallExpression: T\n            } = xo();\n          function m(W, K, de, ue, Fe, z) {\n            let U = d(W, K, de, ue, z),\n              Z = de(z, {\n                assignmentLayout: U\n              });\n            switch (U) {\n              case \"break-after-operator\":\n                return n([n(ue), Fe, n(u([a, Z]))]);\n              case \"never-break-after-operator\":\n                return n([n(ue), Fe, \" \", Z]);\n              case \"fluid\":\n                {\n                  let se = Symbol(\"assignment\");\n                  return n([n(ue), Fe, n(u(a), {\n                    id: se\n                  }), l, i(Z, {\n                    groupId: se\n                  })]);\n                }\n              case \"break-lhs\":\n                return n([ue, Fe, \" \", n(Z)]);\n              case \"chain\":\n                return [n(ue), Fe, a, Z];\n              case \"chain-tail\":\n                return [n(ue), Fe, u([a, Z])];\n              case \"chain-tail-arrow-chain\":\n                return [n(ue), Fe, Z];\n              case \"only-left\":\n                return ue;\n            }\n          }\n          function C(W, K, de) {\n            let ue = W.getValue();\n            return m(W, K, de, de(\"left\"), [\" \", ue.operator], \"right\");\n          }\n          function o(W, K, de) {\n            return m(W, K, de, de(\"id\"), \" =\", \"init\");\n          }\n          function d(W, K, de, ue, Fe) {\n            let z = W.getValue(),\n              U = z[Fe];\n            if (!U) return \"only-left\";\n            let Z = !b(U);\n            if (W.match(b, B, he => !Z || he.type !== \"ExpressionStatement\" && he.type !== \"VariableDeclaration\")) return Z ? U.type === \"ArrowFunctionExpression\" && U.body.type === \"ArrowFunctionExpression\" ? \"chain-tail-arrow-chain\" : \"chain-tail\" : \"chain\";\n            if (!Z && b(U.right) || g(K.originalText, U)) return \"break-after-operator\";\n            if (U.type === \"CallExpression\" && U.callee.name === \"require\" || K.parser === \"json5\" || K.parser === \"json\") return \"never-break-after-operator\";\n            if (S(z) || k(z) || q(z) || J(z) && h(ue)) return \"break-lhs\";\n            let ge = ie(z, ue, K);\n            return W.call(() => v(W, K, de, ge), Fe) ? \"break-after-operator\" : ge || U.type === \"TemplateLiteral\" || U.type === \"TaggedTemplateExpression\" || U.type === \"BooleanLiteral\" || _(U) || U.type === \"ClassExpression\" ? \"never-break-after-operator\" : \"fluid\";\n          }\n          function v(W, K, de, ue) {\n            let Fe = W.getValue();\n            if (c(Fe) && !D(Fe)) return !0;\n            switch (Fe.type) {\n              case \"StringLiteralTypeAnnotation\":\n              case \"SequenceExpression\":\n                return !0;\n              case \"ConditionalExpression\":\n                {\n                  let {\n                    test: Z\n                  } = Fe;\n                  return c(Z) && !D(Z);\n                }\n              case \"ClassExpression\":\n                return t(Fe.decorators);\n            }\n            if (ue) return !1;\n            let z = Fe,\n              U = [];\n            for (;;) if (z.type === \"UnaryExpression\") z = z.argument, U.push(\"argument\");else if (z.type === \"TSNonNullExpression\") z = z.expression, U.push(\"expression\");else break;\n            return !!(f(z) || W.call(() => V(W, K, de), ...U));\n          }\n          function S(W) {\n            if (B(W)) {\n              let K = W.left || W.id;\n              return K.type === \"ObjectPattern\" && K.properties.length > 2 && K.properties.some(de => $(de) && (!de.shorthand || de.value && de.value.type === \"AssignmentPattern\"));\n            }\n            return !1;\n          }\n          function b(W) {\n            return W.type === \"AssignmentExpression\";\n          }\n          function B(W) {\n            return b(W) || W.type === \"VariableDeclarator\";\n          }\n          function k(W) {\n            let K = M(W);\n            if (t(K)) {\n              let de = W.type === \"TSTypeAliasDeclaration\" ? \"constraint\" : \"bound\";\n              if (K.length > 1 && K.some(ue => ue[de] || ue.default)) return !0;\n            }\n            return !1;\n          }\n          function M(W) {\n            return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;\n          }\n          function R(W) {\n            return W.type === \"TSTypeAliasDeclaration\" || W.type === \"TypeAlias\";\n          }\n          function q(W) {\n            if (W.type !== \"VariableDeclarator\") return !1;\n            let {\n              typeAnnotation: K\n            } = W.id;\n            if (!K || !K.typeAnnotation) return !1;\n            let de = L(K.typeAnnotation);\n            return t(de) && de.length > 1 && de.some(ue => t(L(ue)) || ue.type === \"TSConditionalType\");\n          }\n          function J(W) {\n            return W.type === \"VariableDeclarator\" && W.init && W.init.type === \"ArrowFunctionExpression\";\n          }\n          function L(W) {\n            return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;\n          }\n          function Q(W) {\n            return W.type === \"TSTypeReference\" || W.type === \"GenericTypeAnnotation\";\n          }\n          function V(W, K, de) {\n            let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,\n              Fe = W.getValue(),\n              z = () => V(W, K, de, !0);\n            if (Fe.type === \"TSNonNullExpression\") return W.call(z, \"expression\");\n            if (w(Fe)) {\n              if (T(W, K, de).label === \"member-chain\") return !1;\n              let Z = N(Fe);\n              return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? !1 : W.call(z, \"callee\");\n            }\n            return E(Fe) ? W.call(z, \"object\") : ue && (Fe.type === \"Identifier\" || Fe.type === \"ThisExpression\");\n          }\n          var j = .25;\n          function Y(W, K) {\n            let {\n              printWidth: de\n            } = K;\n            if (I(W)) return !1;\n            let ue = de * j;\n            if (W.type === \"ThisExpression\" || W.type === \"Identifier\" && W.name.length <= ue || P(W) && !I(W.argument)) return !0;\n            let Fe = W.type === \"Literal\" && \"regex\" in W && W.regex.pattern || W.type === \"RegExpLiteral\" && W.pattern;\n            return Fe ? Fe.length <= ue : f(W) ? x(W).length <= ue : W.type === \"TemplateLiteral\" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`\n`) : F(W);\n          }\n          function ie(W, K, de) {\n            if (!$(W)) return !1;\n            K = p(K);\n            let ue = 3;\n            return typeof K == \"string\" && s(K) < de.tabWidth + ue;\n          }\n          function ee(W, K) {\n            let de = ce(W);\n            if (t(de)) {\n              if (de.length > 1) return !0;\n              if (de.length === 1) {\n                let Fe = de[0];\n                if (Fe.type === \"TSUnionType\" || Fe.type === \"UnionTypeAnnotation\" || Fe.type === \"TSIntersectionType\" || Fe.type === \"IntersectionTypeAnnotation\" || Fe.type === \"TSTypeLiteral\" || Fe.type === \"ObjectTypeAnnotation\") return !0;\n              }\n              let ue = W.typeParameters ? \"typeParameters\" : \"typeArguments\";\n              if (y(K(ue))) return !0;\n            }\n            return !1;\n          }\n          function ce(W) {\n            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;\n          }\n          r.exports = {\n            printVariableDeclarator: o,\n            printAssignmentExpression: C,\n            printAssignment: m,\n            isArrowFunctionVariableDeclarator: J\n          };\n        }\n      }),\n      Lr = te({\n        \"src/language-js/print/function-parameters.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              getNextNonSpaceNonCommentCharacter: t\n            } = Ue(),\n            {\n              printDanglingComments: s\n            } = et(),\n            {\n              builders: {\n                line: a,\n                hardline: n,\n                softline: u,\n                group: i,\n                indent: l,\n                ifBreak: p\n              },\n              utils: {\n                removeLines: y,\n                willBreak: h\n              }\n            } = qe(),\n            {\n              getFunctionParameters: g,\n              iterateFunctionParametersPath: c,\n              isSimpleType: f,\n              isTestCall: F,\n              isTypeAnnotationAFunction: _,\n              isObjectType: w,\n              isObjectTypePropertyAFunction: E,\n              hasRestParameter: N,\n              shouldPrintComma: x,\n              hasComment: I,\n              isNextLineEmpty: P\n            } = Ke(),\n            {\n              locEnd: $\n            } = ut(),\n            {\n              ArgExpansionBailout: D\n            } = Qt(),\n            {\n              printFunctionTypeParameters: T\n            } = ct();\n          function m(v, S, b, B, k) {\n            let M = v.getValue(),\n              R = g(M),\n              q = k ? T(v, b, S) : \"\";\n            if (R.length === 0) return [q, \"(\", s(v, b, !0, ie => t(b.originalText, ie, $) === \")\"), \")\"];\n            let J = v.getParentNode(),\n              L = F(J),\n              Q = C(M),\n              V = [];\n            if (c(v, (ie, ee) => {\n              let ce = ee === R.length - 1;\n              ce && M.rest && V.push(\"...\"), V.push(S()), !ce && (V.push(\",\"), L || Q ? V.push(\" \") : P(R[ee], b) ? V.push(n, n) : V.push(a));\n            }), B) {\n              if (h(q) || h(V)) throw new D();\n              return i([y(q), \"(\", y(V), \")\"]);\n            }\n            let j = R.every(ie => !ie.decorators);\n            return Q && j ? [q, \"(\", ...V, \")\"] : L ? [q, \"(\", ...V, \")\"] : (E(J) || _(J) || J.type === \"TypeAlias\" || J.type === \"UnionTypeAnnotation\" || J.type === \"TSUnionType\" || J.type === \"IntersectionTypeAnnotation\" || J.type === \"FunctionTypeAnnotation\" && J.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f(R[0].typeAnnotation) && !M.rest ? b.arrowParens === \"always\" ? [\"(\", ...V, \")\"] : V : [q, \"(\", l([u, ...V]), p(!N(M) && x(b, \"all\") ? \",\" : \"\"), u, \")\"];\n          }\n          function C(v) {\n            if (!v) return !1;\n            let S = g(v);\n            if (S.length !== 1) return !1;\n            let [b] = S;\n            return !I(b) && (b.type === \"ObjectPattern\" || b.type === \"ArrayPattern\" || b.type === \"Identifier\" && b.typeAnnotation && (b.typeAnnotation.type === \"TypeAnnotation\" || b.typeAnnotation.type === \"TSTypeAnnotation\") && w(b.typeAnnotation.typeAnnotation) || b.type === \"FunctionTypeParam\" && w(b.typeAnnotation) || b.type === \"AssignmentPattern\" && (b.left.type === \"ObjectPattern\" || b.left.type === \"ArrayPattern\") && (b.right.type === \"Identifier\" || b.right.type === \"ObjectExpression\" && b.right.properties.length === 0 || b.right.type === \"ArrayExpression\" && b.right.elements.length === 0));\n          }\n          function o(v) {\n            let S;\n            return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;\n          }\n          function d(v, S) {\n            let b = o(v);\n            if (!b) return !1;\n            let B = v.typeParameters && v.typeParameters.params;\n            if (B) {\n              if (B.length > 1) return !1;\n              if (B.length === 1) {\n                let k = B[0];\n                if (k.constraint || k.default) return !1;\n              }\n            }\n            return g(v).length === 1 && (w(b) || h(S));\n          }\n          r.exports = {\n            printFunctionParameters: m,\n            shouldHugFunctionParameters: C,\n            shouldGroupFunctionParameters: d\n          };\n        }\n      }),\n      Or = te({\n        \"src/language-js/print/type-annotation.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printComments: t,\n              printDanglingComments: s\n            } = et(),\n            {\n              isNonEmptyArray: a\n            } = Ue(),\n            {\n              builders: {\n                group: n,\n                join: u,\n                line: i,\n                softline: l,\n                indent: p,\n                align: y,\n                ifBreak: h\n              }\n            } = qe(),\n            g = qt(),\n            {\n              locStart: c\n            } = ut(),\n            {\n              isSimpleType: f,\n              isObjectType: F,\n              hasLeadingOwnLineComment: _,\n              isObjectTypePropertyAFunction: w,\n              shouldPrintComma: E\n            } = Ke(),\n            {\n              printAssignment: N\n            } = tr(),\n            {\n              printFunctionParameters: x,\n              shouldGroupFunctionParameters: I\n            } = Lr(),\n            {\n              printArrayItems: P\n            } = er();\n          function $(b) {\n            if (f(b) || F(b)) return !0;\n            if (b.type === \"UnionTypeAnnotation\" || b.type === \"TSUnionType\") {\n              let B = b.types.filter(M => M.type === \"VoidTypeAnnotation\" || M.type === \"TSVoidKeyword\" || M.type === \"NullLiteralTypeAnnotation\" || M.type === \"TSNullKeyword\").length,\n                k = b.types.some(M => M.type === \"ObjectTypeAnnotation\" || M.type === \"TSTypeLiteral\" || M.type === \"GenericTypeAnnotation\" || M.type === \"TSTypeReference\");\n              if (b.types.length - 1 === B && k) return !0;\n            }\n            return !1;\n          }\n          function D(b, B, k) {\n            let M = B.semi ? \";\" : \"\",\n              R = b.getValue(),\n              q = [];\n            return q.push(\"opaque type \", k(\"id\"), k(\"typeParameters\")), R.supertype && q.push(\": \", k(\"supertype\")), R.impltype && q.push(\" = \", k(\"impltype\")), q.push(M), q;\n          }\n          function T(b, B, k) {\n            let M = B.semi ? \";\" : \"\",\n              R = b.getValue(),\n              q = [];\n            R.declare && q.push(\"declare \"), q.push(\"type \", k(\"id\"), k(\"typeParameters\"));\n            let J = R.type === \"TSTypeAliasDeclaration\" ? \"typeAnnotation\" : \"right\";\n            return [N(b, B, k, q, \" =\", J), M];\n          }\n          function m(b, B, k) {\n            let M = b.getValue(),\n              R = b.map(k, \"types\"),\n              q = [],\n              J = !1;\n            for (let L = 0; L < R.length; ++L) L === 0 ? q.push(R[L]) : F(M.types[L - 1]) && F(M.types[L]) ? q.push([\" & \", J ? p(R[L]) : R[L]]) : !F(M.types[L - 1]) && !F(M.types[L]) ? q.push(p([\" &\", i, R[L]])) : (L > 1 && (J = !0), q.push(\" & \", L > 1 ? p(R[L]) : R[L]));\n            return n(q);\n          }\n          function C(b, B, k) {\n            let M = b.getValue(),\n              R = b.getParentNode(),\n              q = R.type !== \"TypeParameterInstantiation\" && R.type !== \"TSTypeParameterInstantiation\" && R.type !== \"GenericTypeAnnotation\" && R.type !== \"TSTypeReference\" && R.type !== \"TSTypeAssertion\" && R.type !== \"TupleTypeAnnotation\" && R.type !== \"TSTupleType\" && !(R.type === \"FunctionTypeParam\" && !R.name && b.getParentNode(1).this !== R) && !((R.type === \"TypeAlias\" || R.type === \"VariableDeclarator\" || R.type === \"TSTypeAliasDeclaration\") && _(B.originalText, M)),\n              J = $(M),\n              L = b.map(j => {\n                let Y = k();\n                return J || (Y = y(2, Y)), t(j, Y, B);\n              }, \"types\");\n            if (J) return u(\" | \", L);\n            let Q = q && !_(B.originalText, M),\n              V = [h([Q ? i : \"\", \"| \"]), u([i, \"| \"], L)];\n            return g(b, B) ? n([p(V), l]) : R.type === \"TupleTypeAnnotation\" && R.types.length > 1 || R.type === \"TSTupleType\" && R.elementTypes.length > 1 ? n([p([h([\"(\", l]), V]), l, h(\")\")]) : n(q ? p(V) : V);\n          }\n          function o(b, B, k) {\n            let M = b.getValue(),\n              R = [],\n              q = b.getParentNode(0),\n              J = b.getParentNode(1),\n              L = b.getParentNode(2),\n              Q = M.type === \"TSFunctionType\" || !((q.type === \"ObjectTypeProperty\" || q.type === \"ObjectTypeInternalSlot\") && !q.variance && !q.optional && c(q) === c(M) || q.type === \"ObjectTypeCallProperty\" || L && L.type === \"DeclareFunction\"),\n              V = Q && (q.type === \"TypeAnnotation\" || q.type === \"TSTypeAnnotation\"),\n              j = V && Q && (q.type === \"TypeAnnotation\" || q.type === \"TSTypeAnnotation\") && J.type === \"ArrowFunctionExpression\";\n            w(q) && (Q = !0, V = !0), j && R.push(\"(\");\n            let Y = x(b, k, B, !1, !0),\n              ie = M.returnType || M.predicate || M.typeAnnotation ? [Q ? \" => \" : \": \", k(\"returnType\"), k(\"predicate\"), k(\"typeAnnotation\")] : \"\",\n              ee = I(M, ie);\n            return R.push(ee ? n(Y) : Y), ie && R.push(ie), j && R.push(\")\"), n(R);\n          }\n          function d(b, B, k) {\n            let M = b.getValue(),\n              R = M.type === \"TSTupleType\" ? \"elementTypes\" : \"types\",\n              q = M[R],\n              J = a(q),\n              L = J ? l : \"\";\n            return n([\"[\", p([L, P(b, B, R, k)]), h(J && E(B, \"all\") ? \",\" : \"\"), s(b, B, !0), L, \"]\"]);\n          }\n          function v(b, B, k) {\n            let M = b.getValue(),\n              R = M.type === \"OptionalIndexedAccessType\" && M.optional ? \"?.[\" : \"[\";\n            return [k(\"objectType\"), R, k(\"indexType\"), \"]\"];\n          }\n          function S(b, B, k) {\n            let M = b.getValue();\n            return [M.postfix ? \"\" : k, B(\"typeAnnotation\"), M.postfix ? k : \"\"];\n          }\n          r.exports = {\n            printOpaqueType: D,\n            printTypeAlias: T,\n            printIntersectionType: m,\n            printUnionType: C,\n            printFunctionType: o,\n            printTupleType: d,\n            printIndexedAccessType: v,\n            shouldHugType: $,\n            printJSDocType: S\n          };\n        }\n      }),\n      jr = te({\n        \"src/language-js/print/type-parameters.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              builders: {\n                join: s,\n                line: a,\n                hardline: n,\n                softline: u,\n                group: i,\n                indent: l,\n                ifBreak: p\n              }\n            } = qe(),\n            {\n              isTestCall: y,\n              hasComment: h,\n              CommentCheckFlags: g,\n              isTSXFile: c,\n              shouldPrintComma: f,\n              getFunctionParameters: F,\n              isObjectType: _,\n              getTypeScriptMappedTypeModifier: w\n            } = Ke(),\n            {\n              createGroupIdMapper: E\n            } = Ue(),\n            {\n              shouldHugType: N\n            } = Or(),\n            {\n              isArrowFunctionVariableDeclarator: x\n            } = tr(),\n            I = E(\"typeParameters\");\n          function P(T, m, C, o) {\n            let d = T.getValue();\n            if (!d[o]) return \"\";\n            if (!Array.isArray(d[o])) return C(o);\n            let v = T.getNode(2),\n              S = v && y(v),\n              b = T.match(M => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === \"typeAnnotation\", M => M.type === \"Identifier\", x);\n            if (d[o].length === 0 || !b && (S || d[o].length === 1 && (d[o][0].type === \"NullableTypeAnnotation\" || N(d[o][0])))) return [\"<\", s(\", \", T.map(C, o)), $(T, m), \">\"];\n            let k = d.type === \"TSTypeParameterInstantiation\" ? \"\" : F(d).length === 1 && c(m) && !d[o][0].constraint && T.getParentNode().type === \"ArrowFunctionExpression\" ? \",\" : f(m, \"all\") ? p(\",\") : \"\";\n            return i([\"<\", l([u, s([\",\", a], T.map(C, o))]), k, u, \">\"], {\n              id: I(d)\n            });\n          }\n          function $(T, m) {\n            let C = T.getValue();\n            if (!h(C, g.Dangling)) return \"\";\n            let o = !h(C, g.Line),\n              d = t(T, m, o);\n            return o ? d : [d, n];\n          }\n          function D(T, m, C) {\n            let o = T.getValue(),\n              d = [o.type === \"TSTypeParameter\" && o.const ? \"const \" : \"\"],\n              v = T.getParentNode();\n            return v.type === \"TSMappedType\" ? (v.readonly && d.push(w(v.readonly, \"readonly\"), \" \"), d.push(\"[\", C(\"name\")), o.constraint && d.push(\" in \", C(\"constraint\")), v.nameType && d.push(\" as \", T.callParent(() => C(\"nameType\"))), d.push(\"]\"), d) : (o.variance && d.push(C(\"variance\")), o.in && d.push(\"in \"), o.out && d.push(\"out \"), d.push(C(\"name\")), o.bound && d.push(\": \", C(\"bound\")), o.constraint && d.push(\" extends \", C(\"constraint\")), o.default && d.push(\" = \", C(\"default\")), d);\n          }\n          r.exports = {\n            printTypeParameter: D,\n            printTypeParameters: P,\n            getTypeParametersGroupId: I\n          };\n        }\n      }),\n      rr = te({\n        \"src/language-js/print/property.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printComments: t\n            } = et(),\n            {\n              printString: s,\n              printNumber: a\n            } = Ue(),\n            {\n              isNumericLiteral: n,\n              isSimpleNumber: u,\n              isStringLiteral: i,\n              isStringPropSafeToUnquote: l,\n              rawText: p\n            } = Ke(),\n            {\n              printAssignment: y\n            } = tr(),\n            h = new WeakMap();\n          function g(f, F, _) {\n            let w = f.getNode();\n            if (w.computed) return [\"[\", _(\"key\"), \"]\"];\n            let E = f.getParentNode(),\n              {\n                key: N\n              } = w;\n            if (F.quoteProps === \"consistent\" && !h.has(E)) {\n              let x = (E.properties || E.body || E.members).some(I => !I.computed && I.key && i(I.key) && !l(I, F));\n              h.set(E, x);\n            }\n            if ((N.type === \"Identifier\" || n(N) && u(a(p(N))) && String(N.value) === a(p(N)) && !(F.parser === \"typescript\" || F.parser === \"babel-ts\")) && (F.parser === \"json\" || F.quoteProps === \"consistent\" && h.get(E))) {\n              let x = s(JSON.stringify(N.type === \"Identifier\" ? N.name : N.value.toString()), F);\n              return f.call(I => t(I, x, F), \"key\");\n            }\n            return l(w, F) && (F.quoteProps === \"as-needed\" || F.quoteProps === \"consistent\" && !h.get(E)) ? f.call(x => t(x, /^\\d/.test(N.value) ? a(N.value) : N.value, F), \"key\") : _(\"key\");\n          }\n          function c(f, F, _) {\n            return f.getValue().shorthand ? _(\"value\") : y(f, F, _, g(f, F, _), \":\", \"value\");\n          }\n          r.exports = {\n            printProperty: c,\n            printPropertyKey: g\n          };\n        }\n      }),\n      qr = te({\n        \"src/language-js/print/function.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Zt(),\n            {\n              printDanglingComments: s,\n              printCommentsSeparately: a\n            } = et(),\n            n = lt(),\n            {\n              getNextNonSpaceNonCommentCharacterIndex: u\n            } = Ue(),\n            {\n              builders: {\n                line: i,\n                softline: l,\n                group: p,\n                indent: y,\n                ifBreak: h,\n                hardline: g,\n                join: c,\n                indentIfBreak: f\n              },\n              utils: {\n                removeLines: F,\n                willBreak: _\n              }\n            } = qe(),\n            {\n              ArgExpansionBailout: w\n            } = Qt(),\n            {\n              getFunctionParameters: E,\n              hasLeadingOwnLineComment: N,\n              isFlowAnnotationComment: x,\n              isJsxNode: I,\n              isTemplateOnItsOwnLine: P,\n              shouldPrintComma: $,\n              startsWithNoLookaheadToken: D,\n              isBinaryish: T,\n              isLineComment: m,\n              hasComment: C,\n              getComments: o,\n              CommentCheckFlags: d,\n              isCallLikeExpression: v,\n              isCallExpression: S,\n              getCallArguments: b,\n              hasNakedLeftSide: B,\n              getLeftSide: k\n            } = Ke(),\n            {\n              locEnd: M\n            } = ut(),\n            {\n              printFunctionParameters: R,\n              shouldGroupFunctionParameters: q\n            } = Lr(),\n            {\n              printPropertyKey: J\n            } = rr(),\n            {\n              printFunctionTypeParameters: L\n            } = ct();\n          function Q(U, Z, se, fe) {\n            let ge = U.getValue(),\n              he = !1;\n            if ((ge.type === \"FunctionDeclaration\" || ge.type === \"FunctionExpression\") && fe && fe.expandLastArg) {\n              let Pe = U.getParentNode();\n              S(Pe) && b(Pe).length > 1 && (he = !0);\n            }\n            let we = [];\n            ge.type === \"TSDeclareFunction\" && ge.declare && we.push(\"declare \"), ge.async && we.push(\"async \"), ge.generator ? we.push(\"function* \") : we.push(\"function \"), ge.id && we.push(Z(\"id\"));\n            let ke = R(U, Z, se, he),\n              Re = K(U, Z, se),\n              Ne = q(ge, Re);\n            return we.push(L(U, se, Z), p([Ne ? p(ke) : ke, Re]), ge.body ? \" \" : \"\", Z(\"body\")), se.semi && (ge.declare || !ge.body) && we.push(\";\"), we;\n          }\n          function V(U, Z, se) {\n            let fe = U.getNode(),\n              {\n                kind: ge\n              } = fe,\n              he = fe.value || fe,\n              we = [];\n            return !ge || ge === \"init\" || ge === \"method\" || ge === \"constructor\" ? he.async && we.push(\"async \") : (t.ok(ge === \"get\" || ge === \"set\"), we.push(ge, \" \")), he.generator && we.push(\"*\"), we.push(J(U, Z, se), fe.optional || fe.key.optional ? \"?\" : \"\"), fe === he ? we.push(j(U, Z, se)) : he.type === \"FunctionExpression\" ? we.push(U.call(ke => j(ke, Z, se), \"value\")) : we.push(se(\"value\")), we;\n          }\n          function j(U, Z, se) {\n            let fe = U.getNode(),\n              ge = R(U, se, Z),\n              he = K(U, se, Z),\n              we = q(fe, he),\n              ke = [L(U, Z, se), p([we ? p(ge) : ge, he])];\n            return fe.body ? ke.push(\" \", se(\"body\")) : ke.push(Z.semi ? \";\" : \"\"), ke;\n          }\n          function Y(U, Z, se, fe) {\n            let ge = U.getValue(),\n              he = [];\n            if (ge.async && he.push(\"async \"), W(U, Z)) he.push(se([\"params\", 0]));else {\n              let ke = fe && (fe.expandLastArg || fe.expandFirstArg),\n                Re = K(U, se, Z);\n              if (ke) {\n                if (_(Re)) throw new w();\n                Re = p(F(Re));\n              }\n              he.push(p([R(U, se, Z, ke, !0), Re]));\n            }\n            let we = s(U, Z, !0, ke => {\n              let Re = u(Z.originalText, ke, M);\n              return Re !== !1 && Z.originalText.slice(Re, Re + 2) === \"=>\";\n            });\n            return we && he.push(\" \", we), he;\n          }\n          function ie(U, Z, se, fe, ge, he) {\n            let we = U.getName(),\n              ke = U.getParentNode(),\n              Re = v(ke) && we === \"callee\",\n              Ne = Boolean(Z && Z.assignmentLayout),\n              Pe = he.body.type !== \"BlockStatement\" && he.body.type !== \"ObjectExpression\" && he.body.type !== \"SequenceExpression\",\n              oe = Re && Pe || Z && Z.assignmentLayout === \"chain-tail-arrow-chain\",\n              H = Symbol(\"arrow-chain\");\n            return he.body.type === \"SequenceExpression\" && (ge = p([\"(\", y([l, ge]), l, \")\"])), p([p(y([Re || Ne ? l : \"\", p(c([\" =>\", i], se), {\n              shouldBreak: fe\n            })]), {\n              id: H,\n              shouldBreak: oe\n            }), \" =>\", f(Pe ? y([i, ge]) : [\" \", ge], {\n              groupId: H\n            }), Re ? h(l, \"\", {\n              groupId: H\n            }) : \"\"]);\n          }\n          function ee(U, Z, se, fe) {\n            let ge = U.getValue(),\n              he = [],\n              we = [],\n              ke = !1;\n            if (function H() {\n              let pe = Y(U, Z, se, fe);\n              if (he.length === 0) he.push(pe);else {\n                let {\n                  leading: X,\n                  trailing: le\n                } = a(U, Z);\n                he.push([X, pe]), we.unshift(le);\n              }\n              ke = ke || ge.returnType && E(ge).length > 0 || ge.typeParameters || E(ge).some(X => X.type !== \"Identifier\"), ge.body.type !== \"ArrowFunctionExpression\" || fe && fe.expandLastArg ? we.unshift(se(\"body\", fe)) : (ge = ge.body, U.call(H, \"body\"));\n            }(), he.length > 1) return ie(U, fe, he, ke, we, ge);\n            let Re = he;\n            if (Re.push(\" =>\"), !N(Z.originalText, ge.body) && (ge.body.type === \"ArrayExpression\" || ge.body.type === \"ObjectExpression\" || ge.body.type === \"BlockStatement\" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === \"ArrowFunctionExpression\" || ge.body.type === \"DoExpression\")) return p([...Re, \" \", we]);\n            if (ge.body.type === \"SequenceExpression\") return p([...Re, p([\" (\", y([l, we]), l, \")\"])]);\n            let Ne = (fe && fe.expandLastArg || U.getParentNode().type === \"JSXExpressionContainer\") && !C(ge),\n              Pe = fe && fe.expandLastArg && $(Z, \"all\"),\n              oe = ge.body.type === \"ConditionalExpression\" && !D(ge.body, H => H.type === \"ObjectExpression\");\n            return p([...Re, p([y([i, oe ? h(\"\", \"(\") : \"\", we, oe ? h(\"\", \")\") : \"\"]), Ne ? [h(Pe ? \",\" : \"\"), l] : \"\"])]);\n          }\n          function ce(U) {\n            let Z = E(U);\n            return Z.length === 1 && !U.typeParameters && !C(U, d.Dangling) && Z[0].type === \"Identifier\" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U.predicate && !U.returnType;\n          }\n          function W(U, Z) {\n            if (Z.arrowParens === \"always\") return !1;\n            if (Z.arrowParens === \"avoid\") {\n              let se = U.getValue();\n              return ce(se);\n            }\n            return !1;\n          }\n          function K(U, Z, se) {\n            let fe = U.getValue(),\n              ge = Z(\"returnType\");\n            if (fe.returnType && x(se.originalText, fe.returnType)) return [\" /*: \", ge, \" */\"];\n            let he = [ge];\n            return fe.returnType && fe.returnType.typeAnnotation && he.unshift(\": \"), fe.predicate && he.push(fe.returnType ? \" \" : \": \", Z(\"predicate\")), he;\n          }\n          function de(U, Z, se) {\n            let fe = U.getValue(),\n              ge = Z.semi ? \";\" : \"\",\n              he = [];\n            fe.argument && (z(Z, fe.argument) ? he.push([\" (\", y([g, se(\"argument\")]), g, \")\"]) : T(fe.argument) || fe.argument.type === \"SequenceExpression\" ? he.push(p([h(\" (\", \" \"), y([l, se(\"argument\")]), l, h(\")\")])) : he.push(\" \", se(\"argument\")));\n            let we = o(fe),\n              ke = n(we),\n              Re = ke && m(ke);\n            return Re && he.push(ge), C(fe, d.Dangling) && he.push(\" \", s(U, Z, !0)), Re || he.push(ge), he;\n          }\n          function ue(U, Z, se) {\n            return [\"return\", de(U, Z, se)];\n          }\n          function Fe(U, Z, se) {\n            return [\"throw\", de(U, Z, se)];\n          }\n          function z(U, Z) {\n            if (N(U.originalText, Z)) return !0;\n            if (B(Z)) {\n              let se = Z,\n                fe;\n              for (; fe = k(se);) if (se = fe, N(U.originalText, se)) return !0;\n            }\n            return !1;\n          }\n          r.exports = {\n            printFunction: Q,\n            printArrowFunction: ee,\n            printMethod: V,\n            printReturnStatement: ue,\n            printThrowStatement: Fe,\n            printMethodInternal: j,\n            shouldPrintParamsWithoutParens: W\n          };\n        }\n      }),\n      nu = te({\n        \"src/language-js/print/decorators.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isNonEmptyArray: t,\n              hasNewline: s\n            } = Ue(),\n            {\n              builders: {\n                line: a,\n                hardline: n,\n                join: u,\n                breakParent: i,\n                group: l\n              }\n            } = qe(),\n            {\n              locStart: p,\n              locEnd: y\n            } = ut(),\n            {\n              getParentExportDeclaration: h\n            } = Ke();\n          function g(w, E, N) {\n            let x = w.getValue();\n            return l([u(a, w.map(N, \"decorators\")), F(x, E) ? n : a]);\n          }\n          function c(w, E, N) {\n            return [u(n, w.map(N, \"declaration\", \"decorators\")), n];\n          }\n          function f(w, E, N) {\n            let x = w.getValue(),\n              {\n                decorators: I\n              } = x;\n            if (!t(I) || _(w.getParentNode())) return;\n            let P = x.type === \"ClassExpression\" || x.type === \"ClassDeclaration\" || F(x, E);\n            return [h(w) ? n : P ? i : \"\", u(a, w.map(N, \"decorators\")), a];\n          }\n          function F(w, E) {\n            return w.decorators.some(N => s(E.originalText, y(N)));\n          }\n          function _(w) {\n            if (w.type !== \"ExportDefaultDeclaration\" && w.type !== \"ExportNamedDeclaration\" && w.type !== \"DeclareExportDeclaration\") return !1;\n            let E = w.declaration && w.declaration.decorators;\n            return t(E) && p(w) === p(E[0]);\n          }\n          r.exports = {\n            printDecorators: f,\n            printClassMemberDecorators: g,\n            printDecoratorsBeforeExport: c,\n            hasDecoratorsBeforeExport: _\n          };\n        }\n      }),\n      nr = te({\n        \"src/language-js/print/class.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isNonEmptyArray: t,\n              createGroupIdMapper: s\n            } = Ue(),\n            {\n              printComments: a,\n              printDanglingComments: n\n            } = et(),\n            {\n              builders: {\n                join: u,\n                line: i,\n                hardline: l,\n                softline: p,\n                group: y,\n                indent: h,\n                ifBreak: g\n              }\n            } = qe(),\n            {\n              hasComment: c,\n              CommentCheckFlags: f\n            } = Ke(),\n            {\n              getTypeParametersGroupId: F\n            } = jr(),\n            {\n              printMethod: _\n            } = qr(),\n            {\n              printOptionalToken: w,\n              printTypeAnnotation: E,\n              printDefiniteToken: N\n            } = ct(),\n            {\n              printPropertyKey: x\n            } = rr(),\n            {\n              printAssignment: I\n            } = tr(),\n            {\n              printClassMemberDecorators: P\n            } = nu();\n          function $(b, B, k) {\n            let M = b.getValue(),\n              R = [];\n            M.declare && R.push(\"declare \"), M.abstract && R.push(\"abstract \"), R.push(\"class\");\n            let q = M.id && c(M.id, f.Trailing) || M.typeParameters && c(M.typeParameters, f.Trailing) || M.superClass && c(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements),\n              J = [],\n              L = [];\n            if (M.id && J.push(\" \", k(\"id\")), J.push(k(\"typeParameters\")), M.superClass) {\n              let Q = [d(b, B, k), k(\"superTypeParameters\")],\n                V = b.call(j => [\"extends \", a(j, Q, B)], \"superClass\");\n              q ? L.push(i, y(V)) : L.push(\" \", V);\n            } else L.push(o(b, B, k, \"extends\"));\n            if (L.push(o(b, B, k, \"mixins\"), o(b, B, k, \"implements\")), q) {\n              let Q;\n              C(M) ? Q = [...J, h(L)] : Q = h([...J, L]), R.push(y(Q, {\n                id: D(M)\n              }));\n            } else R.push(...J, ...L);\n            return R.push(\" \", k(\"body\")), R;\n          }\n          var D = s(\"heritageGroup\");\n          function T(b) {\n            return g(l, \"\", {\n              groupId: D(b)\n            });\n          }\n          function m(b) {\n            return [\"superClass\", \"extends\", \"mixins\", \"implements\"].filter(B => Boolean(b[B])).length > 1;\n          }\n          function C(b) {\n            return b.typeParameters && !c(b.typeParameters, f.Trailing | f.Line) && !m(b);\n          }\n          function o(b, B, k, M) {\n            let R = b.getValue();\n            if (!t(R[M])) return \"\";\n            let q = n(b, B, !0, J => {\n              let {\n                marker: L\n              } = J;\n              return L === M;\n            });\n            return [C(R) ? g(\" \", i, {\n              groupId: F(R.typeParameters)\n            }) : i, q, q && l, M, y(h([i, u([\",\", i], b.map(k, M))]))];\n          }\n          function d(b, B, k) {\n            let M = k(\"superClass\");\n            return b.getParentNode().type === \"AssignmentExpression\" ? y(g([\"(\", h([p, M]), p, \")\"], M)) : M;\n          }\n          function v(b, B, k) {\n            let M = b.getValue(),\n              R = [];\n            return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + \" \"), M.readonly && R.push(\"readonly \"), M.declare && R.push(\"declare \"), M.static && R.push(\"static \"), (M.type === \"TSAbstractMethodDefinition\" || M.abstract) && R.push(\"abstract \"), M.override && R.push(\"override \"), R.push(_(b, B, k)), R;\n          }\n          function S(b, B, k) {\n            let M = b.getValue(),\n              R = [],\n              q = B.semi ? \";\" : \"\";\n            return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + \" \"), M.declare && R.push(\"declare \"), M.static && R.push(\"static \"), (M.type === \"TSAbstractPropertyDefinition\" || M.type === \"TSAbstractAccessorProperty\" || M.abstract) && R.push(\"abstract \"), M.override && R.push(\"override \"), M.readonly && R.push(\"readonly \"), M.variance && R.push(k(\"variance\")), (M.type === \"ClassAccessorProperty\" || M.type === \"AccessorProperty\" || M.type === \"TSAbstractAccessorProperty\") && R.push(\"accessor \"), R.push(x(b, B, k), w(b), N(b), E(b, B, k)), [I(b, B, k, R, \" =\", \"value\"), q];\n          }\n          r.exports = {\n            printClass: $,\n            printClassMethod: v,\n            printClassProperty: S,\n            printHardlineAfterHeritage: T\n          };\n        }\n      }),\n      bo = te({\n        \"src/language-js/print/interface.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isNonEmptyArray: t\n            } = Ue(),\n            {\n              builders: {\n                join: s,\n                line: a,\n                group: n,\n                indent: u,\n                ifBreak: i\n              }\n            } = qe(),\n            {\n              hasComment: l,\n              identity: p,\n              CommentCheckFlags: y\n            } = Ke(),\n            {\n              getTypeParametersGroupId: h\n            } = jr(),\n            {\n              printTypeScriptModifiers: g\n            } = ct();\n          function c(f, F, _) {\n            let w = f.getValue(),\n              E = [];\n            w.declare && E.push(\"declare \"), w.type === \"TSInterfaceDeclaration\" && E.push(w.abstract ? \"abstract \" : \"\", g(f, F, _)), E.push(\"interface\");\n            let N = [],\n              x = [];\n            w.type !== \"InterfaceTypeAnnotation\" && N.push(\" \", _(\"id\"), _(\"typeParameters\"));\n            let I = w.typeParameters && !l(w.typeParameters, y.Trailing | y.Line);\n            return t(w.extends) && x.push(I ? i(\" \", a, {\n              groupId: h(w.typeParameters)\n            }) : a, \"extends \", (w.extends.length === 1 ? p : u)(s([\",\", a], f.map(_, \"extends\")))), w.id && l(w.id, y.Trailing) || t(w.extends) ? I ? E.push(n([...N, u(x)])) : E.push(n(u([...N, ...x]))) : E.push(...N, ...x), E.push(\" \", _(\"body\")), n(E);\n          }\n          r.exports = {\n            printInterface: c\n          };\n        }\n      }),\n      To = te({\n        \"src/language-js/print/module.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isNonEmptyArray: t\n            } = Ue(),\n            {\n              builders: {\n                softline: s,\n                group: a,\n                indent: n,\n                join: u,\n                line: i,\n                ifBreak: l,\n                hardline: p\n              }\n            } = qe(),\n            {\n              printDanglingComments: y\n            } = et(),\n            {\n              hasComment: h,\n              CommentCheckFlags: g,\n              shouldPrintComma: c,\n              needsHardlineAfterDanglingComment: f,\n              isStringLiteral: F,\n              rawText: _\n            } = Ke(),\n            {\n              locStart: w,\n              hasSameLoc: E\n            } = ut(),\n            {\n              hasDecoratorsBeforeExport: N,\n              printDecoratorsBeforeExport: x\n            } = nu();\n          function I(S, b, B) {\n            let k = S.getValue(),\n              M = b.semi ? \";\" : \"\",\n              R = [],\n              {\n                importKind: q\n              } = k;\n            return R.push(\"import\"), q && q !== \"value\" && R.push(\" \", q), R.push(m(S, b, B), T(S, b, B), o(S, b, B), M), R;\n          }\n          function P(S, b, B) {\n            let k = S.getValue(),\n              M = [];\n            N(k) && M.push(x(S, b, B));\n            let {\n              type: R,\n              exportKind: q,\n              declaration: J\n            } = k;\n            return M.push(\"export\"), (k.default || R === \"ExportDefaultDeclaration\") && M.push(\" default\"), h(k, g.Dangling) && (M.push(\" \", y(S, b, !0)), f(k) && M.push(p)), J ? M.push(\" \", B(\"declaration\")) : M.push(q === \"type\" ? \" type\" : \"\", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(\";\"), M;\n          }\n          function $(S, b, B) {\n            let k = S.getValue(),\n              M = b.semi ? \";\" : \"\",\n              R = [],\n              {\n                exportKind: q,\n                exported: J\n              } = k;\n            return R.push(\"export\"), q === \"type\" && R.push(\" type\"), R.push(\" *\"), J && R.push(\" as \", B(\"exported\")), R.push(T(S, b, B), o(S, b, B), M), R;\n          }\n          function D(S, b) {\n            if (!b.semi) return !1;\n            let {\n                type: B,\n                declaration: k\n              } = S,\n              M = S.default || B === \"ExportDefaultDeclaration\";\n            if (!k) return !0;\n            let {\n              type: R\n            } = k;\n            return !!(M && R !== \"ClassDeclaration\" && R !== \"FunctionDeclaration\" && R !== \"TSInterfaceDeclaration\" && R !== \"DeclareClass\" && R !== \"DeclareFunction\" && R !== \"TSDeclareFunction\" && R !== \"EnumDeclaration\");\n          }\n          function T(S, b, B) {\n            let k = S.getValue();\n            if (!k.source) return \"\";\n            let M = [];\n            return C(k, b) || M.push(\" from\"), M.push(\" \", B(\"source\")), M;\n          }\n          function m(S, b, B) {\n            let k = S.getValue();\n            if (C(k, b)) return \"\";\n            let M = [\" \"];\n            if (t(k.specifiers)) {\n              let R = [],\n                q = [];\n              S.each(() => {\n                let J = S.getValue().type;\n                if (J === \"ExportNamespaceSpecifier\" || J === \"ExportDefaultSpecifier\" || J === \"ImportNamespaceSpecifier\" || J === \"ImportDefaultSpecifier\") R.push(B());else if (J === \"ExportSpecifier\" || J === \"ImportSpecifier\") q.push(B());else throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);\n              }, \"specifiers\"), M.push(u(\", \", R)), q.length > 0 && (R.length > 0 && M.push(\", \"), q.length > 1 || R.length > 0 || k.specifiers.some(L => h(L)) ? M.push(a([\"{\", n([b.bracketSpacing ? i : s, u([\",\", i], q)]), l(c(b) ? \",\" : \"\"), b.bracketSpacing ? i : s, \"}\"])) : M.push([\"{\", b.bracketSpacing ? \" \" : \"\", ...q, b.bracketSpacing ? \" \" : \"\", \"}\"]));\n            } else M.push(\"{}\");\n            return M;\n          }\n          function C(S, b) {\n            let {\n              type: B,\n              importKind: k,\n              source: M,\n              specifiers: R\n            } = S;\n            return B !== \"ImportDeclaration\" || t(R) || k === \"type\" ? !1 : !/{\\s*}/.test(b.originalText.slice(w(S), w(M)));\n          }\n          function o(S, b, B) {\n            let k = S.getNode();\n            return t(k.assertions) ? [\" assert {\", b.bracketSpacing ? \" \" : \"\", u(\", \", S.map(B, \"assertions\")), b.bracketSpacing ? \" \" : \"\", \"}\"] : \"\";\n          }\n          function d(S, b, B) {\n            let k = S.getNode(),\n              {\n                type: M\n              } = k,\n              R = [],\n              q = M === \"ImportSpecifier\" ? k.importKind : k.exportKind;\n            q && q !== \"value\" && R.push(q, \" \");\n            let J = M.startsWith(\"Import\"),\n              L = J ? \"imported\" : \"local\",\n              Q = J ? \"local\" : \"exported\",\n              V = k[L],\n              j = k[Q],\n              Y = \"\",\n              ie = \"\";\n            return M === \"ExportNamespaceSpecifier\" || M === \"ImportNamespaceSpecifier\" ? Y = \"*\" : V && (Y = B(L)), j && !v(k) && (ie = B(Q)), R.push(Y, Y && ie ? \" as \" : \"\", ie), R;\n          }\n          function v(S) {\n            if (S.type !== \"ImportSpecifier\" && S.type !== \"ExportSpecifier\") return !1;\n            let {\n              local: b,\n              [S.type === \"ImportSpecifier\" ? \"imported\" : \"exported\"]: B\n            } = S;\n            if (b.type !== B.type || !E(b, B)) return !1;\n            if (F(b)) return b.value === B.value && _(b) === _(B);\n            switch (b.type) {\n              case \"Identifier\":\n                return b.name === B.name;\n              default:\n                return !1;\n            }\n          }\n          r.exports = {\n            printImportDeclaration: I,\n            printExportDeclaration: P,\n            printExportAllDeclaration: $,\n            printModuleSpecifier: d\n          };\n        }\n      }),\n      uu = te({\n        \"src/language-js/print/object.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              builders: {\n                line: s,\n                softline: a,\n                group: n,\n                indent: u,\n                ifBreak: i,\n                hardline: l\n              }\n            } = qe(),\n            {\n              getLast: p,\n              hasNewlineInRange: y,\n              hasNewline: h,\n              isNonEmptyArray: g\n            } = Ue(),\n            {\n              shouldPrintComma: c,\n              hasComment: f,\n              getComments: F,\n              CommentCheckFlags: _,\n              isNextLineEmpty: w\n            } = Ke(),\n            {\n              locStart: E,\n              locEnd: N\n            } = ut(),\n            {\n              printOptionalToken: x,\n              printTypeAnnotation: I\n            } = ct(),\n            {\n              shouldHugFunctionParameters: P\n            } = Lr(),\n            {\n              shouldHugType: $\n            } = Or(),\n            {\n              printHardlineAfterHeritage: D\n            } = nr();\n          function T(m, C, o) {\n            let d = C.semi ? \";\" : \"\",\n              v = m.getValue(),\n              S;\n            v.type === \"TSTypeLiteral\" ? S = \"members\" : v.type === \"TSInterfaceBody\" ? S = \"body\" : S = \"properties\";\n            let b = v.type === \"ObjectTypeAnnotation\",\n              B = [S];\n            b && B.push(\"indexers\", \"callProperties\", \"internalSlots\");\n            let k = B.map(W => v[W][0]).sort((W, K) => E(W) - E(K))[0],\n              M = m.getParentNode(0),\n              R = b && M && (M.type === \"InterfaceDeclaration\" || M.type === \"DeclareInterface\" || M.type === \"DeclareClass\") && m.getName() === \"body\",\n              q = v.type === \"TSInterfaceBody\" || R || v.type === \"ObjectPattern\" && M.type !== \"FunctionDeclaration\" && M.type !== \"FunctionExpression\" && M.type !== \"ArrowFunctionExpression\" && M.type !== \"ObjectMethod\" && M.type !== \"ClassMethod\" && M.type !== \"ClassPrivateMethod\" && M.type !== \"AssignmentPattern\" && M.type !== \"CatchClause\" && v.properties.some(W => W.value && (W.value.type === \"ObjectPattern\" || W.value.type === \"ArrayPattern\")) || v.type !== \"ObjectPattern\" && k && y(C.originalText, E(v), E(k)),\n              J = R ? \";\" : v.type === \"TSInterfaceBody\" || v.type === \"TSTypeLiteral\" ? i(d, \";\") : \",\",\n              L = v.type === \"RecordExpression\" ? \"#{\" : v.exact ? \"{|\" : \"{\",\n              Q = v.exact ? \"|}\" : \"}\",\n              V = [];\n            for (let W of B) m.each(K => {\n              let de = K.getValue();\n              V.push({\n                node: de,\n                printed: o(),\n                loc: E(de)\n              });\n            }, W);\n            B.length > 1 && V.sort((W, K) => W.loc - K.loc);\n            let j = [],\n              Y = V.map(W => {\n                let K = [...j, n(W.printed)];\n                return j = [J, s], (W.node.type === \"TSPropertySignature\" || W.node.type === \"TSMethodSignature\" || W.node.type === \"TSConstructSignatureDeclaration\") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;\n              });\n            if (v.inexact) {\n              let W;\n              if (f(v, _.Dangling)) {\n                let K = f(v, _.Line);\n                W = [t(m, C, !0), K || h(C.originalText, N(p(F(v)))) ? l : s, \"...\"];\n              } else W = [\"...\"];\n              Y.push([...j, ...W]);\n            }\n            let ie = p(v[S]),\n              ee = !(v.inexact || ie && ie.type === \"RestElement\" || ie && (ie.type === \"TSPropertySignature\" || ie.type === \"TSCallSignatureDeclaration\" || ie.type === \"TSMethodSignature\" || ie.type === \"TSConstructSignatureDeclaration\") && f(ie, _.PrettierIgnore)),\n              ce;\n            if (Y.length === 0) {\n              if (!f(v, _.Dangling)) return [L, Q, I(m, C, o)];\n              ce = n([L, t(m, C), a, Q, x(m), I(m, C, o)]);\n            } else ce = [R && g(v.properties) ? D(M) : \"\", L, u([C.bracketSpacing ? s : a, ...Y]), i(ee && (J !== \",\" || c(C)) ? J : \"\"), C.bracketSpacing ? s : a, Q, x(m), I(m, C, o)];\n            return m.match(W => W.type === \"ObjectPattern\" && !W.decorators, (W, K, de) => P(W) && (K === \"params\" || K === \"parameters\" || K === \"this\" || K === \"rest\") && de === 0) || m.match($, (W, K) => K === \"typeAnnotation\", (W, K) => K === \"typeAnnotation\", (W, K, de) => P(W) && (K === \"params\" || K === \"parameters\" || K === \"this\" || K === \"rest\") && de === 0) || !q && m.match(W => W.type === \"ObjectPattern\", W => W.type === \"AssignmentExpression\" || W.type === \"VariableDeclarator\") ? ce : n(ce, {\n              shouldBreak: q\n            });\n          }\n          r.exports = {\n            printObject: T\n          };\n        }\n      }),\n      dd = te({\n        \"src/language-js/print/flow.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Zt(),\n            {\n              printDanglingComments: s\n            } = et(),\n            {\n              printString: a,\n              printNumber: n\n            } = Ue(),\n            {\n              builders: {\n                hardline: u,\n                softline: i,\n                group: l,\n                indent: p\n              }\n            } = qe(),\n            {\n              getParentExportDeclaration: y,\n              isFunctionNotation: h,\n              isGetterOrSetter: g,\n              rawText: c,\n              shouldPrintComma: f\n            } = Ke(),\n            {\n              locStart: F,\n              locEnd: _\n            } = ut(),\n            {\n              replaceTextEndOfLine: w\n            } = Yt(),\n            {\n              printClass: E\n            } = nr(),\n            {\n              printOpaqueType: N,\n              printTypeAlias: x,\n              printIntersectionType: I,\n              printUnionType: P,\n              printFunctionType: $,\n              printTupleType: D,\n              printIndexedAccessType: T\n            } = Or(),\n            {\n              printInterface: m\n            } = bo(),\n            {\n              printTypeParameter: C,\n              printTypeParameters: o\n            } = jr(),\n            {\n              printExportDeclaration: d,\n              printExportAllDeclaration: v\n            } = To(),\n            {\n              printArrayItems: S\n            } = er(),\n            {\n              printObject: b\n            } = uu(),\n            {\n              printPropertyKey: B\n            } = rr(),\n            {\n              printOptionalToken: k,\n              printTypeAnnotation: M,\n              printRestSpread: R\n            } = ct();\n          function q(L, Q, V) {\n            let j = L.getValue(),\n              Y = Q.semi ? \";\" : \"\",\n              ie = [];\n            switch (j.type) {\n              case \"DeclareClass\":\n                return J(L, E(L, Q, V));\n              case \"DeclareFunction\":\n                return J(L, [\"function \", V(\"id\"), j.predicate ? \" \" : \"\", V(\"predicate\"), Y]);\n              case \"DeclareModule\":\n                return J(L, [\"module \", V(\"id\"), \" \", V(\"body\")]);\n              case \"DeclareModuleExports\":\n                return J(L, [\"module.exports\", \": \", V(\"typeAnnotation\"), Y]);\n              case \"DeclareVariable\":\n                return J(L, [\"var \", V(\"id\"), Y]);\n              case \"DeclareOpaqueType\":\n                return J(L, N(L, Q, V));\n              case \"DeclareInterface\":\n                return J(L, m(L, Q, V));\n              case \"DeclareTypeAlias\":\n                return J(L, x(L, Q, V));\n              case \"DeclareExportDeclaration\":\n                return J(L, d(L, Q, V));\n              case \"DeclareExportAllDeclaration\":\n                return J(L, v(L, Q, V));\n              case \"OpaqueType\":\n                return N(L, Q, V);\n              case \"TypeAlias\":\n                return x(L, Q, V);\n              case \"IntersectionTypeAnnotation\":\n                return I(L, Q, V);\n              case \"UnionTypeAnnotation\":\n                return P(L, Q, V);\n              case \"FunctionTypeAnnotation\":\n                return $(L, Q, V);\n              case \"TupleTypeAnnotation\":\n                return D(L, Q, V);\n              case \"GenericTypeAnnotation\":\n                return [V(\"id\"), o(L, Q, V, \"typeParameters\")];\n              case \"IndexedAccessType\":\n              case \"OptionalIndexedAccessType\":\n                return T(L, Q, V);\n              case \"TypeAnnotation\":\n                return V(\"typeAnnotation\");\n              case \"TypeParameter\":\n                return C(L, Q, V);\n              case \"TypeofTypeAnnotation\":\n                return [\"typeof \", V(\"argument\")];\n              case \"ExistsTypeAnnotation\":\n                return \"*\";\n              case \"EmptyTypeAnnotation\":\n                return \"empty\";\n              case \"MixedTypeAnnotation\":\n                return \"mixed\";\n              case \"ArrayTypeAnnotation\":\n                return [V(\"elementType\"), \"[]\"];\n              case \"BooleanLiteralTypeAnnotation\":\n                return String(j.value);\n              case \"EnumDeclaration\":\n                return [\"enum \", V(\"id\"), \" \", V(\"body\")];\n              case \"EnumBooleanBody\":\n              case \"EnumNumberBody\":\n              case \"EnumStringBody\":\n              case \"EnumSymbolBody\":\n                {\n                  if (j.type === \"EnumSymbolBody\" || j.explicitType) {\n                    let ee = null;\n                    switch (j.type) {\n                      case \"EnumBooleanBody\":\n                        ee = \"boolean\";\n                        break;\n                      case \"EnumNumberBody\":\n                        ee = \"number\";\n                        break;\n                      case \"EnumStringBody\":\n                        ee = \"string\";\n                        break;\n                      case \"EnumSymbolBody\":\n                        ee = \"symbol\";\n                        break;\n                    }\n                    ie.push(\"of \", ee, \" \");\n                  }\n                  if (j.members.length === 0 && !j.hasUnknownMembers) ie.push(l([\"{\", s(L, Q), i, \"}\"]));else {\n                    let ee = j.members.length > 0 ? [u, S(L, Q, \"members\", V), j.hasUnknownMembers || f(Q) ? \",\" : \"\"] : [];\n                    ie.push(l([\"{\", p([...ee, ...(j.hasUnknownMembers ? [u, \"...\"] : [])]), s(L, Q, !0), u, \"}\"]));\n                  }\n                  return ie;\n                }\n              case \"EnumBooleanMember\":\n              case \"EnumNumberMember\":\n              case \"EnumStringMember\":\n                return [V(\"id\"), \" = \", typeof j.init == \"object\" ? V(\"init\") : String(j.init)];\n              case \"EnumDefaultedMember\":\n                return V(\"id\");\n              case \"FunctionTypeParam\":\n                {\n                  let ee = j.name ? V(\"name\") : L.getParentNode().this === j ? \"this\" : \"\";\n                  return [ee, k(L), ee ? \": \" : \"\", V(\"typeAnnotation\")];\n                }\n              case \"InterfaceDeclaration\":\n              case \"InterfaceTypeAnnotation\":\n                return m(L, Q, V);\n              case \"ClassImplements\":\n              case \"InterfaceExtends\":\n                return [V(\"id\"), V(\"typeParameters\")];\n              case \"NullableTypeAnnotation\":\n                return [\"?\", V(\"typeAnnotation\")];\n              case \"Variance\":\n                {\n                  let {\n                    kind: ee\n                  } = j;\n                  return t.ok(ee === \"plus\" || ee === \"minus\"), ee === \"plus\" ? \"+\" : \"-\";\n                }\n              case \"ObjectTypeCallProperty\":\n                return j.static && ie.push(\"static \"), ie.push(V(\"value\")), ie;\n              case \"ObjectTypeIndexer\":\n                return [j.static ? \"static \" : \"\", j.variance ? V(\"variance\") : \"\", \"[\", V(\"id\"), j.id ? \": \" : \"\", V(\"key\"), \"]: \", V(\"value\")];\n              case \"ObjectTypeProperty\":\n                {\n                  let ee = \"\";\n                  return j.proto ? ee = \"proto \" : j.static && (ee = \"static \"), [ee, g(j) ? j.kind + \" \" : \"\", j.variance ? V(\"variance\") : \"\", B(L, Q, V), k(L), h(j) ? \"\" : \": \", V(\"value\")];\n                }\n              case \"ObjectTypeAnnotation\":\n                return b(L, Q, V);\n              case \"ObjectTypeInternalSlot\":\n                return [j.static ? \"static \" : \"\", \"[[\", V(\"id\"), \"]]\", k(L), j.method ? \"\" : \": \", V(\"value\")];\n              case \"ObjectTypeSpreadProperty\":\n                return R(L, Q, V);\n              case \"QualifiedTypeofIdentifier\":\n              case \"QualifiedTypeIdentifier\":\n                return [V(\"qualification\"), \".\", V(\"id\")];\n              case \"StringLiteralTypeAnnotation\":\n                return w(a(c(j), Q));\n              case \"NumberLiteralTypeAnnotation\":\n                t.strictEqual(typeof j.value, \"number\");\n              case \"BigIntLiteralTypeAnnotation\":\n                return j.extra ? n(j.extra.raw) : n(j.raw);\n              case \"TypeCastExpression\":\n                return [\"(\", V(\"expression\"), M(L, Q, V), \")\"];\n              case \"TypeParameterDeclaration\":\n              case \"TypeParameterInstantiation\":\n                {\n                  let ee = o(L, Q, V, \"params\");\n                  if (Q.parser === \"flow\") {\n                    let ce = F(j),\n                      W = _(j),\n                      K = Q.originalText.lastIndexOf(\"/*\", ce),\n                      de = Q.originalText.indexOf(\"*/\", W);\n                    if (K !== -1 && de !== -1) {\n                      let ue = Q.originalText.slice(K + 2, de).trim();\n                      if (ue.startsWith(\"::\") && !ue.includes(\"/*\") && !ue.includes(\"*/\")) return [\"/*:: \", ee, \" */\"];\n                    }\n                  }\n                  return ee;\n                }\n              case \"InferredPredicate\":\n                return \"%checks\";\n              case \"DeclaredPredicate\":\n                return [\"%checks(\", V(\"value\"), \")\"];\n              case \"AnyTypeAnnotation\":\n                return \"any\";\n              case \"BooleanTypeAnnotation\":\n                return \"boolean\";\n              case \"BigIntTypeAnnotation\":\n                return \"bigint\";\n              case \"NullLiteralTypeAnnotation\":\n                return \"null\";\n              case \"NumberTypeAnnotation\":\n                return \"number\";\n              case \"SymbolTypeAnnotation\":\n                return \"symbol\";\n              case \"StringTypeAnnotation\":\n                return \"string\";\n              case \"VoidTypeAnnotation\":\n                return \"void\";\n              case \"ThisTypeAnnotation\":\n                return \"this\";\n              case \"Node\":\n              case \"Printable\":\n              case \"SourceLocation\":\n              case \"Position\":\n              case \"Statement\":\n              case \"Function\":\n              case \"Pattern\":\n              case \"Expression\":\n              case \"Declaration\":\n              case \"Specifier\":\n              case \"NamedSpecifier\":\n              case \"Comment\":\n              case \"MemberTypeAnnotation\":\n              case \"Type\":\n                throw new Error(\"unprintable type: \" + JSON.stringify(j.type));\n            }\n          }\n          function J(L, Q) {\n            let V = y(L);\n            return V ? (t.strictEqual(V.type, \"DeclareExportDeclaration\"), Q) : [\"declare \", Q];\n          }\n          r.exports = {\n            printFlow: q\n          };\n        }\n      }),\n      gd = te({\n        \"src/language-js/utils/is-ts-keyword-type.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s) {\n            let {\n              type: a\n            } = s;\n            return a.startsWith(\"TS\") && a.endsWith(\"Keyword\");\n          }\n          r.exports = t;\n        }\n      }),\n      Bo = te({\n        \"src/language-js/print/ternary.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              hasNewlineInRange: t\n            } = Ue(),\n            {\n              isJsxNode: s,\n              getComments: a,\n              isCallExpression: n,\n              isMemberExpression: u,\n              isTSTypeExpression: i\n            } = Ke(),\n            {\n              locStart: l,\n              locEnd: p\n            } = ut(),\n            y = Pt(),\n            {\n              builders: {\n                line: h,\n                softline: g,\n                group: c,\n                indent: f,\n                align: F,\n                ifBreak: _,\n                dedent: w,\n                breakParent: E\n              }\n            } = qe();\n          function N(D) {\n            let T = [D];\n            for (let m = 0; m < T.length; m++) {\n              let C = T[m];\n              for (let o of [\"test\", \"consequent\", \"alternate\"]) {\n                let d = C[o];\n                if (s(d)) return !0;\n                d.type === \"ConditionalExpression\" && T.push(d);\n              }\n            }\n            return !1;\n          }\n          function x(D, T, m) {\n            let C = D.getValue(),\n              o = C.type === \"ConditionalExpression\",\n              d = o ? \"alternate\" : \"falseType\",\n              v = D.getParentNode(),\n              S = o ? m(\"test\") : [m(\"checkType\"), \" \", \"extends\", \" \", m(\"extendsType\")];\n            return v.type === C.type && v[d] === C ? F(2, S) : S;\n          }\n          var I = new Map([[\"AssignmentExpression\", \"right\"], [\"VariableDeclarator\", \"init\"], [\"ReturnStatement\", \"argument\"], [\"ThrowStatement\", \"argument\"], [\"UnaryExpression\", \"argument\"], [\"YieldExpression\", \"argument\"]]);\n          function P(D) {\n            let T = D.getValue();\n            if (T.type !== \"ConditionalExpression\") return !1;\n            let m,\n              C = T;\n            for (let o = 0; !m; o++) {\n              let d = D.getParentNode(o);\n              if (n(d) && d.callee === C || u(d) && d.object === C || d.type === \"TSNonNullExpression\" && d.expression === C) {\n                C = d;\n                continue;\n              }\n              d.type === \"NewExpression\" && d.callee === C || i(d) && d.expression === C ? (m = D.getParentNode(o + 1), C = d) : m = d;\n            }\n            return C === T ? !1 : m[I.get(m.type)] === C;\n          }\n          function $(D, T, m) {\n            let C = D.getValue(),\n              o = C.type === \"ConditionalExpression\",\n              d = o ? \"consequent\" : \"trueType\",\n              v = o ? \"alternate\" : \"falseType\",\n              S = o ? [\"test\"] : [\"checkType\", \"extendsType\"],\n              b = C[d],\n              B = C[v],\n              k = [],\n              M = !1,\n              R = D.getParentNode(),\n              q = R.type === C.type && S.some(ue => R[ue] === C),\n              J = R.type === C.type && !q,\n              L,\n              Q,\n              V = 0;\n            do Q = L || C, L = D.getParentNode(V), V++; while (L && L.type === C.type && S.every(ue => L[ue] !== Q));\n            let j = L || R,\n              Y = Q;\n            if (o && (s(C[S[0]]) || s(b) || s(B) || N(Y))) {\n              M = !0, J = !0;\n              let ue = z => [_(\"(\"), f([g, z]), g, _(\")\")],\n                Fe = z => z.type === \"NullLiteral\" || z.type === \"Literal\" && z.value === null || z.type === \"Identifier\" && z.name === \"undefined\";\n              k.push(\" ? \", Fe(b) ? m(d) : ue(m(d)), \" : \", B.type === C.type || Fe(B) ? m(v) : ue(m(v)));\n            } else {\n              let ue = [h, \"? \", b.type === C.type ? _(\"\", \"(\") : \"\", F(2, m(d)), b.type === C.type ? _(\"\", \")\") : \"\", h, \": \", B.type === C.type ? m(v) : F(2, m(v))];\n              k.push(R.type !== C.type || R[v] === C || q ? ue : T.useTabs ? w(f(ue)) : F(Math.max(0, T.tabWidth - 2), ue));\n            }\n            let ee = [...S.map(ue => a(C[ue])), a(b), a(B)].flat().some(ue => y(ue) && t(T.originalText, l(ue), p(ue))),\n              ce = ue => R === j ? c(ue, {\n                shouldBreak: ee\n              }) : ee ? [ue, E] : ue,\n              W = !M && (u(R) || R.type === \"NGPipeExpression\" && R.left === C) && !R.computed,\n              K = P(D),\n              de = ce([x(D, T, m), J ? k : f(k), o && W && !K ? g : \"\"]);\n            return q || K ? c([f([g, de]), g]) : de;\n          }\n          r.exports = {\n            printTernary: $\n          };\n        }\n      }),\n      No = te({\n        \"src/language-js/print/statement.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                hardline: t\n              }\n            } = qe(),\n            s = qt(),\n            {\n              getLeftSidePathName: a,\n              hasNakedLeftSide: n,\n              isJsxNode: u,\n              isTheOnlyJsxElementInMarkdown: i,\n              hasComment: l,\n              CommentCheckFlags: p,\n              isNextLineEmpty: y\n            } = Ke(),\n            {\n              shouldPrintParamsWithoutParens: h\n            } = qr();\n          function g(x, I, P, $) {\n            let D = x.getValue(),\n              T = [],\n              m = D.type === \"ClassBody\",\n              C = c(D[$]);\n            return x.each((o, d, v) => {\n              let S = o.getValue();\n              if (S.type === \"EmptyStatement\") return;\n              let b = P();\n              !I.semi && !m && !i(I, o) && f(o, I) ? l(S, p.Leading) ? T.push(P([], {\n                needsSemi: !0\n              })) : T.push(\";\", b) : T.push(b), !I.semi && m && E(S) && N(S, v[d + 1]) && T.push(\";\"), S !== C && (T.push(t), y(S, I) && T.push(t));\n            }, $), T;\n          }\n          function c(x) {\n            for (let I = x.length - 1; I >= 0; I--) {\n              let P = x[I];\n              if (P.type !== \"EmptyStatement\") return P;\n            }\n          }\n          function f(x, I) {\n            return x.getNode().type !== \"ExpressionStatement\" ? !1 : x.call($ => F($, I), \"expression\");\n          }\n          function F(x, I) {\n            let P = x.getValue();\n            switch (P.type) {\n              case \"ParenthesizedExpression\":\n              case \"TypeCastExpression\":\n              case \"ArrayExpression\":\n              case \"ArrayPattern\":\n              case \"TemplateLiteral\":\n              case \"TemplateElement\":\n              case \"RegExpLiteral\":\n                return !0;\n              case \"ArrowFunctionExpression\":\n                {\n                  if (!h(x, I)) return !0;\n                  break;\n                }\n              case \"UnaryExpression\":\n                {\n                  let {\n                    prefix: $,\n                    operator: D\n                  } = P;\n                  if ($ && (D === \"+\" || D === \"-\")) return !0;\n                  break;\n                }\n              case \"BindExpression\":\n                {\n                  if (!P.object) return !0;\n                  break;\n                }\n              case \"Literal\":\n                {\n                  if (P.regex) return !0;\n                  break;\n                }\n              default:\n                if (u(P)) return !0;\n            }\n            return s(x, I) ? !0 : n(P) ? x.call($ => F($, I), ...a(x, P)) : !1;\n          }\n          function _(x, I, P) {\n            return g(x, I, P, \"body\");\n          }\n          function w(x, I, P) {\n            return g(x, I, P, \"consequent\");\n          }\n          var E = x => {\n            let {\n              type: I\n            } = x;\n            return I === \"ClassProperty\" || I === \"PropertyDefinition\" || I === \"ClassPrivateProperty\" || I === \"ClassAccessorProperty\" || I === \"AccessorProperty\" || I === \"TSAbstractPropertyDefinition\" || I === \"TSAbstractAccessorProperty\";\n          };\n          function N(x, I) {\n            let {\n              type: P,\n              name: $\n            } = x.key;\n            if (!x.computed && P === \"Identifier\" && ($ === \"static\" || $ === \"get\" || $ === \"set\" || $ === \"accessor\") && !x.value && !x.typeAnnotation) return !0;\n            if (!I || I.static || I.accessibility) return !1;\n            if (!I.computed) {\n              let D = I.key && I.key.name;\n              if (D === \"in\" || D === \"instanceof\") return !0;\n            }\n            if (E(I) && I.variance && !I.static && !I.declare) return !0;\n            switch (I.type) {\n              case \"ClassProperty\":\n              case \"PropertyDefinition\":\n              case \"TSAbstractPropertyDefinition\":\n                return I.computed;\n              case \"MethodDefinition\":\n              case \"TSAbstractMethodDefinition\":\n              case \"ClassMethod\":\n              case \"ClassPrivateMethod\":\n                {\n                  if ((I.value ? I.value.async : I.async) || I.kind === \"get\" || I.kind === \"set\") return !1;\n                  let T = I.value ? I.value.generator : I.generator;\n                  return !!(I.computed || T);\n                }\n              case \"TSIndexSignature\":\n                return !0;\n            }\n            return !1;\n          }\n          r.exports = {\n            printBody: _,\n            printSwitchCaseConsequent: w\n          };\n        }\n      }),\n      wo = te({\n        \"src/language-js/print/block.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              isNonEmptyArray: s\n            } = Ue(),\n            {\n              builders: {\n                hardline: a,\n                indent: n\n              }\n            } = qe(),\n            {\n              hasComment: u,\n              CommentCheckFlags: i,\n              isNextLineEmpty: l\n            } = Ke(),\n            {\n              printHardlineAfterHeritage: p\n            } = nr(),\n            {\n              printBody: y\n            } = No();\n          function h(c, f, F) {\n            let _ = c.getValue(),\n              w = [];\n            if (_.type === \"StaticBlock\" && w.push(\"static \"), _.type === \"ClassBody\" && s(_.body)) {\n              let N = c.getParentNode();\n              w.push(p(N));\n            }\n            w.push(\"{\");\n            let E = g(c, f, F);\n            if (E) w.push(n([a, E]), a);else {\n              let N = c.getParentNode(),\n                x = c.getParentNode(1);\n              N.type === \"ArrowFunctionExpression\" || N.type === \"FunctionExpression\" || N.type === \"FunctionDeclaration\" || N.type === \"ObjectMethod\" || N.type === \"ClassMethod\" || N.type === \"ClassPrivateMethod\" || N.type === \"ForStatement\" || N.type === \"WhileStatement\" || N.type === \"DoWhileStatement\" || N.type === \"DoExpression\" || N.type === \"CatchClause\" && !x.finalizer || N.type === \"TSModuleDeclaration\" || N.type === \"TSDeclareFunction\" || _.type === \"StaticBlock\" || _.type === \"ClassBody\" || w.push(a);\n            }\n            return w.push(\"}\"), w;\n          }\n          function g(c, f, F) {\n            let _ = c.getValue(),\n              w = s(_.directives),\n              E = _.body.some(I => I.type !== \"EmptyStatement\"),\n              N = u(_, i.Dangling);\n            if (!w && !E && !N) return \"\";\n            let x = [];\n            if (w && c.each((I, P, $) => {\n              x.push(F()), (P < $.length - 1 || E || N) && (x.push(a), l(I.getValue(), f) && x.push(a));\n            }, \"directives\"), E && x.push(y(c, f, F)), N && x.push(t(c, f, !0)), _.type === \"Program\") {\n              let I = c.getParentNode();\n              (!I || I.type !== \"ModuleExpression\") && x.push(a);\n            }\n            return x;\n          }\n          r.exports = {\n            printBlock: h,\n            printBlockBody: g\n          };\n        }\n      }),\n      yd = te({\n        \"src/language-js/print/typescript.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              hasNewlineInRange: s\n            } = Ue(),\n            {\n              builders: {\n                join: a,\n                line: n,\n                hardline: u,\n                softline: i,\n                group: l,\n                indent: p,\n                conditionalGroup: y,\n                ifBreak: h\n              }\n            } = qe(),\n            {\n              isStringLiteral: g,\n              getTypeScriptMappedTypeModifier: c,\n              shouldPrintComma: f,\n              isCallExpression: F,\n              isMemberExpression: _\n            } = Ke(),\n            w = gd(),\n            {\n              locStart: E,\n              locEnd: N\n            } = ut(),\n            {\n              printOptionalToken: x,\n              printTypeScriptModifiers: I\n            } = ct(),\n            {\n              printTernary: P\n            } = Bo(),\n            {\n              printFunctionParameters: $,\n              shouldGroupFunctionParameters: D\n            } = Lr(),\n            {\n              printTemplateLiteral: T\n            } = jt(),\n            {\n              printArrayItems: m\n            } = er(),\n            {\n              printObject: C\n            } = uu(),\n            {\n              printClassProperty: o,\n              printClassMethod: d\n            } = nr(),\n            {\n              printTypeParameter: v,\n              printTypeParameters: S\n            } = jr(),\n            {\n              printPropertyKey: b\n            } = rr(),\n            {\n              printFunction: B,\n              printMethodInternal: k\n            } = qr(),\n            {\n              printInterface: M\n            } = bo(),\n            {\n              printBlock: R\n            } = wo(),\n            {\n              printTypeAlias: q,\n              printIntersectionType: J,\n              printUnionType: L,\n              printFunctionType: Q,\n              printTupleType: V,\n              printIndexedAccessType: j,\n              printJSDocType: Y\n            } = Or();\n          function ie(ee, ce, W) {\n            let K = ee.getValue();\n            if (!K.type.startsWith(\"TS\")) return;\n            if (w(K)) return K.type.slice(2, -7).toLowerCase();\n            let de = ce.semi ? \";\" : \"\",\n              ue = [];\n            switch (K.type) {\n              case \"TSThisType\":\n                return \"this\";\n              case \"TSTypeAssertion\":\n                {\n                  let Fe = !(K.expression.type === \"ArrayExpression\" || K.expression.type === \"ObjectExpression\"),\n                    z = l([\"<\", p([i, W(\"typeAnnotation\")]), i, \">\"]),\n                    U = [h(\"(\"), p([i, W(\"expression\")]), i, h(\")\")];\n                  return Fe ? y([[z, W(\"expression\")], [z, l(U, {\n                    shouldBreak: !0\n                  })], [z, W(\"expression\")]]) : l([z, W(\"expression\")]);\n                }\n              case \"TSDeclareFunction\":\n                return B(ee, W, ce);\n              case \"TSExportAssignment\":\n                return [\"export = \", W(\"expression\"), de];\n              case \"TSModuleBlock\":\n                return R(ee, ce, W);\n              case \"TSInterfaceBody\":\n              case \"TSTypeLiteral\":\n                return C(ee, ce, W);\n              case \"TSTypeAliasDeclaration\":\n                return q(ee, ce, W);\n              case \"TSQualifiedName\":\n                return a(\".\", [W(\"left\"), W(\"right\")]);\n              case \"TSAbstractMethodDefinition\":\n              case \"TSDeclareMethod\":\n                return d(ee, ce, W);\n              case \"TSAbstractAccessorProperty\":\n              case \"TSAbstractPropertyDefinition\":\n                return o(ee, ce, W);\n              case \"TSInterfaceHeritage\":\n              case \"TSExpressionWithTypeArguments\":\n                return ue.push(W(\"expression\")), K.typeParameters && ue.push(W(\"typeParameters\")), ue;\n              case \"TSTemplateLiteralType\":\n                return T(ee, W, ce);\n              case \"TSNamedTupleMember\":\n                return [W(\"label\"), K.optional ? \"?\" : \"\", \": \", W(\"elementType\")];\n              case \"TSRestType\":\n                return [\"...\", W(\"typeAnnotation\")];\n              case \"TSOptionalType\":\n                return [W(\"typeAnnotation\"), \"?\"];\n              case \"TSInterfaceDeclaration\":\n                return M(ee, ce, W);\n              case \"TSClassImplements\":\n                return [W(\"expression\"), W(\"typeParameters\")];\n              case \"TSTypeParameterDeclaration\":\n              case \"TSTypeParameterInstantiation\":\n                return S(ee, ce, W, \"params\");\n              case \"TSTypeParameter\":\n                return v(ee, ce, W);\n              case \"TSSatisfiesExpression\":\n              case \"TSAsExpression\":\n                {\n                  let Fe = K.type === \"TSAsExpression\" ? \"as\" : \"satisfies\";\n                  ue.push(W(\"expression\"), ` ${Fe} `, W(\"typeAnnotation\"));\n                  let z = ee.getParentNode();\n                  return F(z) && z.callee === K || _(z) && z.object === K ? l([p([i, ...ue]), i]) : ue;\n                }\n              case \"TSArrayType\":\n                return [W(\"elementType\"), \"[]\"];\n              case \"TSPropertySignature\":\n                return K.readonly && ue.push(\"readonly \"), ue.push(b(ee, ce, W), x(ee)), K.typeAnnotation && ue.push(\": \", W(\"typeAnnotation\")), K.initializer && ue.push(\" = \", W(\"initializer\")), ue;\n              case \"TSParameterProperty\":\n                return K.accessibility && ue.push(K.accessibility + \" \"), K.export && ue.push(\"export \"), K.static && ue.push(\"static \"), K.override && ue.push(\"override \"), K.readonly && ue.push(\"readonly \"), ue.push(W(\"parameter\")), ue;\n              case \"TSTypeQuery\":\n                return [\"typeof \", W(\"exprName\"), W(\"typeParameters\")];\n              case \"TSIndexSignature\":\n                {\n                  let Fe = ee.getParentNode(),\n                    z = K.parameters.length > 1 ? h(f(ce) ? \",\" : \"\") : \"\",\n                    U = l([p([i, a([\", \", i], ee.map(W, \"parameters\"))]), z, i]);\n                  return [K.export ? \"export \" : \"\", K.accessibility ? [K.accessibility, \" \"] : \"\", K.static ? \"static \" : \"\", K.readonly ? \"readonly \" : \"\", K.declare ? \"declare \" : \"\", \"[\", K.parameters ? U : \"\", K.typeAnnotation ? \"]: \" : \"]\", K.typeAnnotation ? W(\"typeAnnotation\") : \"\", Fe.type === \"ClassBody\" ? de : \"\"];\n                }\n              case \"TSTypePredicate\":\n                return [K.asserts ? \"asserts \" : \"\", W(\"parameterName\"), K.typeAnnotation ? [\" is \", W(\"typeAnnotation\")] : \"\"];\n              case \"TSNonNullExpression\":\n                return [W(\"expression\"), \"!\"];\n              case \"TSImportType\":\n                return [K.isTypeOf ? \"typeof \" : \"\", \"import(\", W(K.parameter ? \"parameter\" : \"argument\"), \")\", K.qualifier ? [\".\", W(\"qualifier\")] : \"\", S(ee, ce, W, \"typeParameters\")];\n              case \"TSLiteralType\":\n                return W(\"literal\");\n              case \"TSIndexedAccessType\":\n                return j(ee, ce, W);\n              case \"TSConstructSignatureDeclaration\":\n              case \"TSCallSignatureDeclaration\":\n              case \"TSConstructorType\":\n                {\n                  if (K.type === \"TSConstructorType\" && K.abstract && ue.push(\"abstract \"), K.type !== \"TSCallSignatureDeclaration\" && ue.push(\"new \"), ue.push(l($(ee, W, ce, !1, !0))), K.returnType || K.typeAnnotation) {\n                    let Fe = K.type === \"TSConstructorType\";\n                    ue.push(Fe ? \" => \" : \": \", W(\"returnType\"), W(\"typeAnnotation\"));\n                  }\n                  return ue;\n                }\n              case \"TSTypeOperator\":\n                return [K.operator, \" \", W(\"typeAnnotation\")];\n              case \"TSMappedType\":\n                {\n                  let Fe = s(ce.originalText, E(K), N(K));\n                  return l([\"{\", p([ce.bracketSpacing ? n : i, W(\"typeParameter\"), K.optional ? c(K.optional, \"?\") : \"\", K.typeAnnotation ? \": \" : \"\", W(\"typeAnnotation\"), h(de)]), t(ee, ce, !0), ce.bracketSpacing ? n : i, \"}\"], {\n                    shouldBreak: Fe\n                  });\n                }\n              case \"TSMethodSignature\":\n                {\n                  let Fe = K.kind && K.kind !== \"method\" ? `${K.kind} ` : \"\";\n                  ue.push(K.accessibility ? [K.accessibility, \" \"] : \"\", Fe, K.export ? \"export \" : \"\", K.static ? \"static \" : \"\", K.readonly ? \"readonly \" : \"\", K.abstract ? \"abstract \" : \"\", K.declare ? \"declare \" : \"\", K.computed ? \"[\" : \"\", W(\"key\"), K.computed ? \"]\" : \"\", x(ee));\n                  let z = $(ee, W, ce, !1, !0),\n                    U = K.returnType ? \"returnType\" : \"typeAnnotation\",\n                    Z = K[U],\n                    se = Z ? W(U) : \"\",\n                    fe = D(K, se);\n                  return ue.push(fe ? l(z) : z), Z && ue.push(\": \", l(se)), l(ue);\n                }\n              case \"TSNamespaceExportDeclaration\":\n                return ue.push(\"export as namespace \", W(\"id\")), ce.semi && ue.push(\";\"), l(ue);\n              case \"TSEnumDeclaration\":\n                return K.declare && ue.push(\"declare \"), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push(\"const \"), ue.push(\"enum \", W(\"id\"), \" \"), K.members.length === 0 ? ue.push(l([\"{\", t(ee, ce), i, \"}\"])) : ue.push(l([\"{\", p([u, m(ee, ce, \"members\", W), f(ce, \"es5\") ? \",\" : \"\"]), t(ee, ce, !0), u, \"}\"])), ue;\n              case \"TSEnumMember\":\n                return K.computed ? ue.push(\"[\", W(\"id\"), \"]\") : ue.push(W(\"id\")), K.initializer && ue.push(\" = \", W(\"initializer\")), ue;\n              case \"TSImportEqualsDeclaration\":\n                return K.isExport && ue.push(\"export \"), ue.push(\"import \"), K.importKind && K.importKind !== \"value\" && ue.push(K.importKind, \" \"), ue.push(W(\"id\"), \" = \", W(\"moduleReference\")), ce.semi && ue.push(\";\"), l(ue);\n              case \"TSExternalModuleReference\":\n                return [\"require(\", W(\"expression\"), \")\"];\n              case \"TSModuleDeclaration\":\n                {\n                  let Fe = ee.getParentNode(),\n                    z = g(K.id),\n                    U = Fe.type === \"TSModuleDeclaration\",\n                    Z = K.body && K.body.type === \"TSModuleDeclaration\";\n                  if (U) ue.push(\".\");else {\n                    K.declare && ue.push(\"declare \"), ue.push(I(ee, ce, W));\n                    let se = ce.originalText.slice(E(K), E(K.id));\n                    K.id.type === \"Identifier\" && K.id.name === \"global\" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\\s)module(?:\\s|$)/.test(se) ? \"module \" : \"namespace \");\n                  }\n                  return ue.push(W(\"id\")), Z ? ue.push(W(\"body\")) : K.body ? ue.push(\" \", l(W(\"body\"))) : ue.push(de), ue;\n                }\n              case \"TSConditionalType\":\n                return P(ee, ce, W);\n              case \"TSInferType\":\n                return [\"infer\", \" \", W(\"typeParameter\")];\n              case \"TSIntersectionType\":\n                return J(ee, ce, W);\n              case \"TSUnionType\":\n                return L(ee, ce, W);\n              case \"TSFunctionType\":\n                return Q(ee, ce, W);\n              case \"TSTupleType\":\n                return V(ee, ce, W);\n              case \"TSTypeReference\":\n                return [W(\"typeName\"), S(ee, ce, W, \"typeParameters\")];\n              case \"TSTypeAnnotation\":\n                return W(\"typeAnnotation\");\n              case \"TSEmptyBodyFunctionExpression\":\n                return k(ee, ce, W);\n              case \"TSJSDocAllType\":\n                return \"*\";\n              case \"TSJSDocUnknownType\":\n                return \"?\";\n              case \"TSJSDocNullableType\":\n                return Y(ee, W, \"?\");\n              case \"TSJSDocNonNullableType\":\n                return Y(ee, W, \"!\");\n              case \"TSInstantiationExpression\":\n                return [W(\"expression\"), W(\"typeParameters\")];\n              default:\n                throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);\n            }\n          }\n          r.exports = {\n            printTypescript: ie\n          };\n        }\n      }),\n      hd = te({\n        \"src/language-js/print/comment.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              hasNewline: t\n            } = Ue(),\n            {\n              builders: {\n                join: s,\n                hardline: a\n              },\n              utils: {\n                replaceTextEndOfLine: n\n              }\n            } = qe(),\n            {\n              isLineComment: u\n            } = Ke(),\n            {\n              locStart: i,\n              locEnd: l\n            } = ut(),\n            p = Pt();\n          function y(c, f) {\n            let F = c.getValue();\n            if (u(F)) return f.originalText.slice(i(F), l(F)).trimEnd();\n            if (p(F)) {\n              if (h(F)) {\n                let E = g(F);\n                return F.trailing && !t(f.originalText, i(F), {\n                  backwards: !0\n                }) ? [a, E] : E;\n              }\n              let _ = l(F),\n                w = f.originalText.slice(_ - 3, _) === \"*-/\";\n              return [\"/*\", n(F.value), w ? \"*-/\" : \"*/\"];\n            }\n            throw new Error(\"Not a comment: \" + JSON.stringify(F));\n          }\n          function h(c) {\n            let f = `*${c.value}*`.split(`\n`);\n            return f.length > 1 && f.every(F => F.trim()[0] === \"*\");\n          }\n          function g(c) {\n            let f = c.value.split(`\n`);\n            return [\"/*\", s(a, f.map((F, _) => _ === 0 ? F.trimEnd() : \" \" + (_ < f.length - 1 ? F.trim() : F.trimStart()))), \"*/\"];\n          }\n          r.exports = {\n            printComment: y\n          };\n        }\n      }),\n      vd = te({\n        \"src/language-js/print/literal.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printString: t,\n              printNumber: s\n            } = Ue(),\n            {\n              replaceTextEndOfLine: a\n            } = Yt(),\n            {\n              printDirective: n\n            } = ct();\n          function u(y, h) {\n            let g = y.getNode();\n            switch (g.type) {\n              case \"RegExpLiteral\":\n                return p(g);\n              case \"BigIntLiteral\":\n                return l(g.bigint || g.extra.raw);\n              case \"NumericLiteral\":\n                return s(g.extra.raw);\n              case \"StringLiteral\":\n                return a(t(g.extra.raw, h));\n              case \"NullLiteral\":\n                return \"null\";\n              case \"BooleanLiteral\":\n                return String(g.value);\n              case \"DecimalLiteral\":\n                return s(g.value) + \"m\";\n              case \"Literal\":\n                {\n                  if (g.regex) return p(g.regex);\n                  if (g.bigint) return l(g.raw);\n                  if (g.decimal) return s(g.decimal) + \"m\";\n                  let {\n                    value: c\n                  } = g;\n                  return typeof c == \"number\" ? s(g.raw) : typeof c == \"string\" ? i(y) ? n(g.raw, h) : a(t(g.raw, h)) : String(c);\n                }\n            }\n          }\n          function i(y) {\n            if (y.getName() !== \"expression\") return;\n            let h = y.getParentNode();\n            return h.type === \"ExpressionStatement\" && h.directive;\n          }\n          function l(y) {\n            return y.toLowerCase();\n          }\n          function p(y) {\n            let {\n              pattern: h,\n              flags: g\n            } = y;\n            return g = [...g].sort().join(\"\"), `/${h}/${g}`;\n          }\n          r.exports = {\n            printLiteral: u\n          };\n        }\n      }),\n      Cd = te({\n        \"src/language-js/printer-estree.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              hasNewline: s\n            } = Ue(),\n            {\n              builders: {\n                join: a,\n                line: n,\n                hardline: u,\n                softline: i,\n                group: l,\n                indent: p\n              },\n              utils: {\n                replaceTextEndOfLine: y\n              }\n            } = qe(),\n            h = td(),\n            g = rd(),\n            {\n              insertPragma: c\n            } = Co(),\n            f = Eo(),\n            F = qt(),\n            _ = Fo(),\n            {\n              hasFlowShorthandAnnotationComment: w,\n              hasComment: E,\n              CommentCheckFlags: N,\n              isTheOnlyJsxElementInMarkdown: x,\n              isLineComment: I,\n              isNextLineEmpty: P,\n              needsHardlineAfterDanglingComment: $,\n              hasIgnoreComment: D,\n              isCallExpression: T,\n              isMemberExpression: m,\n              markerForIfWithoutBlockAndSameLineComment: C\n            } = Ke(),\n            {\n              locStart: o,\n              locEnd: d\n            } = ut(),\n            v = Pt(),\n            {\n              printHtmlBinding: S,\n              isVueEventBindingExpression: b\n            } = pd(),\n            {\n              printAngular: B\n            } = fd(),\n            {\n              printJsx: k,\n              hasJsxIgnoreComment: M\n            } = Dd(),\n            {\n              printFlow: R\n            } = dd(),\n            {\n              printTypescript: q\n            } = yd(),\n            {\n              printOptionalToken: J,\n              printBindExpressionCallee: L,\n              printTypeAnnotation: Q,\n              adjustClause: V,\n              printRestSpread: j,\n              printDefiniteToken: Y,\n              printDirective: ie\n            } = ct(),\n            {\n              printImportDeclaration: ee,\n              printExportDeclaration: ce,\n              printExportAllDeclaration: W,\n              printModuleSpecifier: K\n            } = To(),\n            {\n              printTernary: de\n            } = Bo(),\n            {\n              printTemplateLiteral: ue\n            } = jt(),\n            {\n              printArray: Fe\n            } = er(),\n            {\n              printObject: z\n            } = uu(),\n            {\n              printClass: U,\n              printClassMethod: Z,\n              printClassProperty: se\n            } = nr(),\n            {\n              printProperty: fe\n            } = rr(),\n            {\n              printFunction: ge,\n              printArrowFunction: he,\n              printMethod: we,\n              printReturnStatement: ke,\n              printThrowStatement: Re\n            } = qr(),\n            {\n              printCallExpression: Ne\n            } = xo(),\n            {\n              printVariableDeclarator: Pe,\n              printAssignmentExpression: oe\n            } = tr(),\n            {\n              printBinaryishExpression: H\n            } = ru(),\n            {\n              printSwitchCaseConsequent: pe\n            } = No(),\n            {\n              printMemberExpression: X\n            } = So(),\n            {\n              printBlock: le,\n              printBlockBody: Ae\n            } = wo(),\n            {\n              printComment: Ee\n            } = hd(),\n            {\n              printLiteral: De\n            } = vd(),\n            {\n              printDecorators: A\n            } = nu();\n          function G(Ce, Be, ve, ze) {\n            let be = re(Ce, Be, ve, ze);\n            if (!be) return \"\";\n            let Ye = Ce.getValue(),\n              {\n                type: Se\n              } = Ye;\n            if (Se === \"ClassMethod\" || Se === \"ClassPrivateMethod\" || Se === \"ClassProperty\" || Se === \"ClassAccessorProperty\" || Se === \"AccessorProperty\" || Se === \"TSAbstractAccessorProperty\" || Se === \"PropertyDefinition\" || Se === \"TSAbstractPropertyDefinition\" || Se === \"ClassPrivateProperty\" || Se === \"MethodDefinition\" || Se === \"TSAbstractMethodDefinition\" || Se === \"TSDeclareMethod\") return be;\n            let Ie = [be],\n              Oe = A(Ce, Be, ve),\n              Je = Ye.type === \"ClassExpression\" && Oe;\n            if (Oe && (Ie = [...Oe, be], !Je)) return l(Ie);\n            if (!F(Ce, Be)) return ze && ze.needsSemi && Ie.unshift(\";\"), Ie.length === 1 && Ie[0] === be ? be : Ie;\n            if (Je && (Ie = [p([n, ...Ie])]), Ie.unshift(\"(\"), ze && ze.needsSemi && Ie.unshift(\";\"), w(Ye)) {\n              let [je] = Ye.trailingComments;\n              Ie.push(\" /*\", je.value.trimStart(), \"*/\"), je.printed = !0;\n            }\n            return Je && Ie.push(n), Ie.push(\")\"), Ie;\n          }\n          function re(Ce, Be, ve, ze) {\n            let be = Ce.getValue(),\n              Ye = Be.semi ? \";\" : \"\";\n            if (!be) return \"\";\n            if (typeof be == \"string\") return be;\n            for (let Ie of [De, S, B, k, R, q]) {\n              let Oe = Ie(Ce, Be, ve);\n              if (typeof Oe < \"u\") return Oe;\n            }\n            let Se = [];\n            switch (be.type) {\n              case \"JsExpressionRoot\":\n                return ve(\"node\");\n              case \"JsonRoot\":\n                return [ve(\"node\"), u];\n              case \"File\":\n                return be.program && be.program.interpreter && Se.push(ve([\"program\", \"interpreter\"])), Se.push(ve(\"program\")), Se;\n              case \"Program\":\n                return Ae(Ce, Be, ve);\n              case \"EmptyStatement\":\n                return \"\";\n              case \"ExpressionStatement\":\n                {\n                  if (Be.parser === \"__vue_event_binding\" || Be.parser === \"__vue_ts_event_binding\") {\n                    let Oe = Ce.getParentNode();\n                    if (Oe.type === \"Program\" && Oe.body.length === 1 && Oe.body[0] === be) return [ve(\"expression\"), b(be.expression) ? \";\" : \"\"];\n                  }\n                  let Ie = t(Ce, Be, !0, Oe => {\n                    let {\n                      marker: Je\n                    } = Oe;\n                    return Je === C;\n                  });\n                  return [ve(\"expression\"), x(Be, Ce) ? \"\" : Ye, Ie ? [\" \", Ie] : \"\"];\n                }\n              case \"ParenthesizedExpression\":\n                return !E(be.expression) && (be.expression.type === \"ObjectExpression\" || be.expression.type === \"ArrayExpression\") ? [\"(\", ve(\"expression\"), \")\"] : l([\"(\", p([i, ve(\"expression\")]), i, \")\"]);\n              case \"AssignmentExpression\":\n                return oe(Ce, Be, ve);\n              case \"VariableDeclarator\":\n                return Pe(Ce, Be, ve);\n              case \"BinaryExpression\":\n              case \"LogicalExpression\":\n                return H(Ce, Be, ve);\n              case \"AssignmentPattern\":\n                return [ve(\"left\"), \" = \", ve(\"right\")];\n              case \"OptionalMemberExpression\":\n              case \"MemberExpression\":\n                return X(Ce, Be, ve);\n              case \"MetaProperty\":\n                return [ve(\"meta\"), \".\", ve(\"property\")];\n              case \"BindExpression\":\n                return be.object && Se.push(ve(\"object\")), Se.push(l(p([i, L(Ce, Be, ve)]))), Se;\n              case \"Identifier\":\n                return [be.name, J(Ce), Y(Ce), Q(Ce, Be, ve)];\n              case \"V8IntrinsicIdentifier\":\n                return [\"%\", be.name];\n              case \"SpreadElement\":\n              case \"SpreadElementPattern\":\n              case \"SpreadProperty\":\n              case \"SpreadPropertyPattern\":\n              case \"RestElement\":\n                return j(Ce, Be, ve);\n              case \"FunctionDeclaration\":\n              case \"FunctionExpression\":\n                return ge(Ce, ve, Be, ze);\n              case \"ArrowFunctionExpression\":\n                return he(Ce, Be, ve, ze);\n              case \"YieldExpression\":\n                return Se.push(\"yield\"), be.delegate && Se.push(\"*\"), be.argument && Se.push(\" \", ve(\"argument\")), Se;\n              case \"AwaitExpression\":\n                {\n                  if (Se.push(\"await\"), be.argument) {\n                    Se.push(\" \", ve(\"argument\"));\n                    let Ie = Ce.getParentNode();\n                    if (T(Ie) && Ie.callee === be || m(Ie) && Ie.object === be) {\n                      Se = [p([i, ...Se]), i];\n                      let Oe = Ce.findAncestor(Je => Je.type === \"AwaitExpression\" || Je.type === \"BlockStatement\");\n                      if (!Oe || Oe.type !== \"AwaitExpression\") return l(Se);\n                    }\n                  }\n                  return Se;\n                }\n              case \"ExportDefaultDeclaration\":\n              case \"ExportNamedDeclaration\":\n                return ce(Ce, Be, ve);\n              case \"ExportAllDeclaration\":\n                return W(Ce, Be, ve);\n              case \"ImportDeclaration\":\n                return ee(Ce, Be, ve);\n              case \"ImportSpecifier\":\n              case \"ExportSpecifier\":\n              case \"ImportNamespaceSpecifier\":\n              case \"ExportNamespaceSpecifier\":\n              case \"ImportDefaultSpecifier\":\n              case \"ExportDefaultSpecifier\":\n                return K(Ce, Be, ve);\n              case \"ImportAttribute\":\n                return [ve(\"key\"), \": \", ve(\"value\")];\n              case \"Import\":\n                return \"import\";\n              case \"BlockStatement\":\n              case \"StaticBlock\":\n              case \"ClassBody\":\n                return le(Ce, Be, ve);\n              case \"ThrowStatement\":\n                return Re(Ce, Be, ve);\n              case \"ReturnStatement\":\n                return ke(Ce, Be, ve);\n              case \"NewExpression\":\n              case \"ImportExpression\":\n              case \"OptionalCallExpression\":\n              case \"CallExpression\":\n                return Ne(Ce, Be, ve);\n              case \"ObjectExpression\":\n              case \"ObjectPattern\":\n              case \"RecordExpression\":\n                return z(Ce, Be, ve);\n              case \"ObjectProperty\":\n              case \"Property\":\n                return be.method || be.kind === \"get\" || be.kind === \"set\" ? we(Ce, Be, ve) : fe(Ce, Be, ve);\n              case \"ObjectMethod\":\n                return we(Ce, Be, ve);\n              case \"Decorator\":\n                return [\"@\", ve(\"expression\")];\n              case \"ArrayExpression\":\n              case \"ArrayPattern\":\n              case \"TupleExpression\":\n                return Fe(Ce, Be, ve);\n              case \"SequenceExpression\":\n                {\n                  let Ie = Ce.getParentNode(0);\n                  if (Ie.type === \"ExpressionStatement\" || Ie.type === \"ForStatement\") {\n                    let Oe = [];\n                    return Ce.each((Je, Te) => {\n                      Te === 0 ? Oe.push(ve()) : Oe.push(\",\", p([n, ve()]));\n                    }, \"expressions\"), l(Oe);\n                  }\n                  return l(a([\",\", n], Ce.map(ve, \"expressions\")));\n                }\n              case \"ThisExpression\":\n                return \"this\";\n              case \"Super\":\n                return \"super\";\n              case \"Directive\":\n                return [ve(\"value\"), Ye];\n              case \"DirectiveLiteral\":\n                return ie(be.extra.raw, Be);\n              case \"UnaryExpression\":\n                return Se.push(be.operator), /[a-z]$/.test(be.operator) && Se.push(\" \"), E(be.argument) ? Se.push(l([\"(\", p([i, ve(\"argument\")]), i, \")\"])) : Se.push(ve(\"argument\")), Se;\n              case \"UpdateExpression\":\n                return Se.push(ve(\"argument\"), be.operator), be.prefix && Se.reverse(), Se;\n              case \"ConditionalExpression\":\n                return de(Ce, Be, ve);\n              case \"VariableDeclaration\":\n                {\n                  let Ie = Ce.map(ve, \"declarations\"),\n                    Oe = Ce.getParentNode(),\n                    Je = Oe.type === \"ForStatement\" || Oe.type === \"ForInStatement\" || Oe.type === \"ForOfStatement\",\n                    Te = be.declarations.some(Me => Me.init),\n                    je;\n                  return Ie.length === 1 && !E(be.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p(Ie[0])), Se = [be.declare ? \"declare \" : \"\", be.kind, je ? [\" \", je] : \"\", p(Ie.slice(1).map(Me => [\",\", Te && !Je ? u : n, Me]))], Je && Oe.body !== be || Se.push(Ye), l(Se);\n                }\n              case \"WithStatement\":\n                return l([\"with (\", ve(\"object\"), \")\", V(be.body, ve(\"body\"))]);\n              case \"IfStatement\":\n                {\n                  let Ie = V(be.consequent, ve(\"consequent\")),\n                    Oe = l([\"if (\", l([p([i, ve(\"test\")]), i]), \")\", Ie]);\n                  if (Se.push(Oe), be.alternate) {\n                    let Je = E(be.consequent, N.Trailing | N.Line) || $(be),\n                      Te = be.consequent.type === \"BlockStatement\" && !Je;\n                    Se.push(Te ? \" \" : u), E(be, N.Dangling) && Se.push(t(Ce, Be, !0), Je ? u : \" \"), Se.push(\"else\", l(V(be.alternate, ve(\"alternate\"), be.alternate.type === \"IfStatement\")));\n                  }\n                  return Se;\n                }\n              case \"ForStatement\":\n                {\n                  let Ie = V(be.body, ve(\"body\")),\n                    Oe = t(Ce, Be, !0),\n                    Je = Oe ? [Oe, i] : \"\";\n                  return !be.init && !be.test && !be.update ? [Je, l([\"for (;;)\", Ie])] : [Je, l([\"for (\", l([p([i, ve(\"init\"), \";\", n, ve(\"test\"), \";\", n, ve(\"update\")]), i]), \")\", Ie])];\n                }\n              case \"WhileStatement\":\n                return l([\"while (\", l([p([i, ve(\"test\")]), i]), \")\", V(be.body, ve(\"body\"))]);\n              case \"ForInStatement\":\n                return l([\"for (\", ve(\"left\"), \" in \", ve(\"right\"), \")\", V(be.body, ve(\"body\"))]);\n              case \"ForOfStatement\":\n                return l([\"for\", be.await ? \" await\" : \"\", \" (\", ve(\"left\"), \" of \", ve(\"right\"), \")\", V(be.body, ve(\"body\"))]);\n              case \"DoWhileStatement\":\n                {\n                  let Ie = V(be.body, ve(\"body\"));\n                  return Se = [l([\"do\", Ie])], be.body.type === \"BlockStatement\" ? Se.push(\" \") : Se.push(u), Se.push(\"while (\", l([p([i, ve(\"test\")]), i]), \")\", Ye), Se;\n                }\n              case \"DoExpression\":\n                return [be.async ? \"async \" : \"\", \"do \", ve(\"body\")];\n              case \"BreakStatement\":\n                return Se.push(\"break\"), be.label && Se.push(\" \", ve(\"label\")), Se.push(Ye), Se;\n              case \"ContinueStatement\":\n                return Se.push(\"continue\"), be.label && Se.push(\" \", ve(\"label\")), Se.push(Ye), Se;\n              case \"LabeledStatement\":\n                return be.body.type === \"EmptyStatement\" ? [ve(\"label\"), \":;\"] : [ve(\"label\"), \": \", ve(\"body\")];\n              case \"TryStatement\":\n                return [\"try \", ve(\"block\"), be.handler ? [\" \", ve(\"handler\")] : \"\", be.finalizer ? [\" finally \", ve(\"finalizer\")] : \"\"];\n              case \"CatchClause\":\n                if (be.param) {\n                  let Ie = E(be.param, Je => !v(Je) || Je.leading && s(Be.originalText, d(Je)) || Je.trailing && s(Be.originalText, o(Je), {\n                      backwards: !0\n                    })),\n                    Oe = ve(\"param\");\n                  return [\"catch \", Ie ? [\"(\", p([i, Oe]), i, \") \"] : [\"(\", Oe, \") \"], ve(\"body\")];\n                }\n                return [\"catch \", ve(\"body\")];\n              case \"SwitchStatement\":\n                return [l([\"switch (\", p([i, ve(\"discriminant\")]), i, \")\"]), \" {\", be.cases.length > 0 ? p([u, a(u, Ce.map((Ie, Oe, Je) => {\n                  let Te = Ie.getValue();\n                  return [ve(), Oe !== Je.length - 1 && P(Te, Be) ? u : \"\"];\n                }, \"cases\"))]) : \"\", u, \"}\"];\n              case \"SwitchCase\":\n                {\n                  be.test ? Se.push(\"case \", ve(\"test\"), \":\") : Se.push(\"default:\"), E(be, N.Dangling) && Se.push(\" \", t(Ce, Be, !0));\n                  let Ie = be.consequent.filter(Oe => Oe.type !== \"EmptyStatement\");\n                  if (Ie.length > 0) {\n                    let Oe = pe(Ce, Be, ve);\n                    Se.push(Ie.length === 1 && Ie[0].type === \"BlockStatement\" ? [\" \", Oe] : p([u, Oe]));\n                  }\n                  return Se;\n                }\n              case \"DebuggerStatement\":\n                return [\"debugger\", Ye];\n              case \"ClassDeclaration\":\n              case \"ClassExpression\":\n                return U(Ce, Be, ve);\n              case \"ClassMethod\":\n              case \"ClassPrivateMethod\":\n              case \"MethodDefinition\":\n                return Z(Ce, Be, ve);\n              case \"ClassProperty\":\n              case \"PropertyDefinition\":\n              case \"ClassPrivateProperty\":\n              case \"ClassAccessorProperty\":\n              case \"AccessorProperty\":\n                return se(Ce, Be, ve);\n              case \"TemplateElement\":\n                return y(be.value.raw);\n              case \"TemplateLiteral\":\n                return ue(Ce, ve, Be);\n              case \"TaggedTemplateExpression\":\n                return [ve(\"tag\"), ve(\"typeParameters\"), ve(\"quasi\")];\n              case \"PrivateIdentifier\":\n                return [\"#\", ve(\"name\")];\n              case \"PrivateName\":\n                return [\"#\", ve(\"id\")];\n              case \"InterpreterDirective\":\n                return Se.push(\"#!\", be.value, u), P(be, Be) && Se.push(u), Se;\n              case \"TopicReference\":\n                return \"%\";\n              case \"ArgumentPlaceholder\":\n                return \"?\";\n              case \"ModuleExpression\":\n                {\n                  Se.push(\"module {\");\n                  let Ie = ve(\"body\");\n                  return Ie && Se.push(p([u, Ie]), u), Se.push(\"}\"), Se;\n                }\n              default:\n                throw new Error(\"unknown type: \" + JSON.stringify(be.type));\n            }\n          }\n          function ye(Ce) {\n            return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== \"EmptyStatement\" && Ce.type !== \"TemplateElement\" && Ce.type !== \"Import\" && Ce.type !== \"TSEmptyBodyFunctionExpression\";\n          }\n          r.exports = {\n            preprocess: _,\n            print: G,\n            embed: h,\n            insertPragma: c,\n            massageAstNode: g,\n            hasPrettierIgnore(Ce) {\n              return D(Ce) || M(Ce);\n            },\n            willPrintOwnComments: f.willPrintOwnComments,\n            canAttachComment: ye,\n            printComment: Ee,\n            isBlockComment: v,\n            handleComments: {\n              avoidAstMutation: !0,\n              ownLine: f.handleOwnLineComment,\n              endOfLine: f.handleEndOfLineComment,\n              remaining: f.handleRemainingComment\n            },\n            getCommentChildNodes: f.getCommentChildNodes\n          };\n        }\n      }),\n      Ed = te({\n        \"src/language-js/printer-estree-json.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                hardline: t,\n                indent: s,\n                join: a\n              }\n            } = qe(),\n            n = Fo();\n          function u(y, h, g) {\n            let c = y.getValue();\n            switch (c.type) {\n              case \"JsonRoot\":\n                return [g(\"node\"), t];\n              case \"ArrayExpression\":\n                {\n                  if (c.elements.length === 0) return \"[]\";\n                  let f = y.map(() => y.getValue() === null ? \"null\" : g(), \"elements\");\n                  return [\"[\", s([t, a([\",\", t], f)]), t, \"]\"];\n                }\n              case \"ObjectExpression\":\n                return c.properties.length === 0 ? \"{}\" : [\"{\", s([t, a([\",\", t], y.map(g, \"properties\"))]), t, \"}\"];\n              case \"ObjectProperty\":\n                return [g(\"key\"), \": \", g(\"value\")];\n              case \"UnaryExpression\":\n                return [c.operator === \"+\" ? \"\" : c.operator, g(\"argument\")];\n              case \"NullLiteral\":\n                return \"null\";\n              case \"BooleanLiteral\":\n                return c.value ? \"true\" : \"false\";\n              case \"StringLiteral\":\n                return JSON.stringify(c.value);\n              case \"NumericLiteral\":\n                return i(y) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);\n              case \"Identifier\":\n                return i(y) ? JSON.stringify(c.name) : c.name;\n              case \"TemplateLiteral\":\n                return g([\"quasis\", 0]);\n              case \"TemplateElement\":\n                return JSON.stringify(c.value.cooked);\n              default:\n                throw new Error(\"unknown type: \" + JSON.stringify(c.type));\n            }\n          }\n          function i(y) {\n            return y.getName() === \"key\" && y.getParentNode().type === \"ObjectProperty\";\n          }\n          var l = new Set([\"start\", \"end\", \"extra\", \"loc\", \"comments\", \"leadingComments\", \"trailingComments\", \"innerComments\", \"errors\", \"range\", \"tokens\"]);\n          function p(y, h) {\n            let {\n              type: g\n            } = y;\n            if (g === \"ObjectProperty\") {\n              let {\n                key: c\n              } = y;\n              c.type === \"Identifier\" ? h.key = {\n                type: \"StringLiteral\",\n                value: c.name\n              } : c.type === \"NumericLiteral\" && (h.key = {\n                type: \"StringLiteral\",\n                value: String(c.value)\n              });\n              return;\n            }\n            if (g === \"UnaryExpression\" && y.operator === \"+\") return h.argument;\n            if (g === \"ArrayExpression\") {\n              for (let [c, f] of y.elements.entries()) f === null && h.elements.splice(c, 0, {\n                type: \"NullLiteral\"\n              });\n              return;\n            }\n            if (g === \"TemplateLiteral\") return {\n              type: \"StringLiteral\",\n              value: y.quasis[0].value.cooked\n            };\n          }\n          p.ignoredProperties = l, r.exports = {\n            preprocess: n,\n            print: u,\n            massageAstNode: p\n          };\n        }\n      }),\n      Mt = te({\n        \"src/common/common-options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = \"Common\";\n          r.exports = {\n            bracketSpacing: {\n              since: \"0.0.0\",\n              category: t,\n              type: \"boolean\",\n              default: !0,\n              description: \"Print spaces between brackets.\",\n              oppositeDescription: \"Do not print spaces between brackets.\"\n            },\n            singleQuote: {\n              since: \"0.0.0\",\n              category: t,\n              type: \"boolean\",\n              default: !1,\n              description: \"Use single quotes instead of double quotes.\"\n            },\n            proseWrap: {\n              since: \"1.8.2\",\n              category: t,\n              type: \"choice\",\n              default: [{\n                since: \"1.8.2\",\n                value: !0\n              }, {\n                since: \"1.9.0\",\n                value: \"preserve\"\n              }],\n              description: \"How to wrap prose.\",\n              choices: [{\n                since: \"1.9.0\",\n                value: \"always\",\n                description: \"Wrap prose if it exceeds the print width.\"\n              }, {\n                since: \"1.9.0\",\n                value: \"never\",\n                description: \"Do not wrap prose.\"\n              }, {\n                since: \"1.9.0\",\n                value: \"preserve\",\n                description: \"Wrap prose as-is.\"\n              }]\n            },\n            bracketSameLine: {\n              since: \"2.4.0\",\n              category: t,\n              type: \"boolean\",\n              default: !1,\n              description: \"Put > of opening tags on the last line instead of on a new line.\"\n            },\n            singleAttributePerLine: {\n              since: \"2.6.0\",\n              category: t,\n              type: \"boolean\",\n              default: !1,\n              description: \"Enforce single attribute per line in HTML, Vue and JSX.\"\n            }\n          };\n        }\n      }),\n      Fd = te({\n        \"src/language-js/options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Mt(),\n            s = \"JavaScript\";\n          r.exports = {\n            arrowParens: {\n              since: \"1.9.0\",\n              category: s,\n              type: \"choice\",\n              default: [{\n                since: \"1.9.0\",\n                value: \"avoid\"\n              }, {\n                since: \"2.0.0\",\n                value: \"always\"\n              }],\n              description: \"Include parentheses around a sole arrow function parameter.\",\n              choices: [{\n                value: \"always\",\n                description: \"Always include parens. Example: `(x) => x`\"\n              }, {\n                value: \"avoid\",\n                description: \"Omit parens when possible. Example: `x => x`\"\n              }]\n            },\n            bracketSameLine: t.bracketSameLine,\n            bracketSpacing: t.bracketSpacing,\n            jsxBracketSameLine: {\n              since: \"0.17.0\",\n              category: s,\n              type: \"boolean\",\n              description: \"Put > on the last line instead of at a new line.\",\n              deprecated: \"2.4.0\"\n            },\n            semi: {\n              since: \"1.0.0\",\n              category: s,\n              type: \"boolean\",\n              default: !0,\n              description: \"Print semicolons.\",\n              oppositeDescription: \"Do not print semicolons, except at the beginning of lines which may need them.\"\n            },\n            singleQuote: t.singleQuote,\n            jsxSingleQuote: {\n              since: \"1.15.0\",\n              category: s,\n              type: \"boolean\",\n              default: !1,\n              description: \"Use single quotes in JSX.\"\n            },\n            quoteProps: {\n              since: \"1.17.0\",\n              category: s,\n              type: \"choice\",\n              default: \"as-needed\",\n              description: \"Change when properties in objects are quoted.\",\n              choices: [{\n                value: \"as-needed\",\n                description: \"Only add quotes around object properties where required.\"\n              }, {\n                value: \"consistent\",\n                description: \"If at least one property in an object requires quotes, quote all properties.\"\n              }, {\n                value: \"preserve\",\n                description: \"Respect the input use of quotes in object properties.\"\n              }]\n            },\n            trailingComma: {\n              since: \"0.0.0\",\n              category: s,\n              type: \"choice\",\n              default: [{\n                since: \"0.0.0\",\n                value: !1\n              }, {\n                since: \"0.19.0\",\n                value: \"none\"\n              }, {\n                since: \"2.0.0\",\n                value: \"es5\"\n              }],\n              description: \"Print trailing commas wherever possible when multi-line.\",\n              choices: [{\n                value: \"es5\",\n                description: \"Trailing commas where valid in ES5 (objects, arrays, etc.)\"\n              }, {\n                value: \"none\",\n                description: \"No trailing commas.\"\n              }, {\n                value: \"all\",\n                description: \"Trailing commas wherever possible (including function arguments).\"\n              }]\n            },\n            singleAttributePerLine: t.singleAttributePerLine\n          };\n        }\n      }),\n      Ad = te({\n        \"src/language-js/parse/parsers.js\"() {\n          ne();\n        }\n      }),\n      Ln = te({\n        \"node_modules/linguist-languages/data/JavaScript.json\"(e, r) {\n          r.exports = {\n            name: \"JavaScript\",\n            type: \"programming\",\n            tmScope: \"source.js\",\n            aceMode: \"javascript\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"text/javascript\",\n            color: \"#f1e05a\",\n            aliases: [\"js\", \"node\"],\n            extensions: [\".js\", \"._js\", \".bones\", \".cjs\", \".es\", \".es6\", \".frag\", \".gs\", \".jake\", \".javascript\", \".jsb\", \".jscad\", \".jsfl\", \".jslib\", \".jsm\", \".jspre\", \".jss\", \".jsx\", \".mjs\", \".njs\", \".pac\", \".sjs\", \".ssjs\", \".xsjs\", \".xsjslib\"],\n            filenames: [\"Jakefile\"],\n            interpreters: [\"chakra\", \"d8\", \"gjs\", \"js\", \"node\", \"nodejs\", \"qjs\", \"rhino\", \"v8\", \"v8-shell\"],\n            languageId: 183\n          };\n        }\n      }),\n      Sd = te({\n        \"node_modules/linguist-languages/data/TypeScript.json\"(e, r) {\n          r.exports = {\n            name: \"TypeScript\",\n            type: \"programming\",\n            color: \"#3178c6\",\n            aliases: [\"ts\"],\n            interpreters: [\"deno\", \"ts-node\"],\n            extensions: [\".ts\", \".cts\", \".mts\"],\n            tmScope: \"source.ts\",\n            aceMode: \"typescript\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"application/typescript\",\n            languageId: 378\n          };\n        }\n      }),\n      xd = te({\n        \"node_modules/linguist-languages/data/TSX.json\"(e, r) {\n          r.exports = {\n            name: \"TSX\",\n            type: \"programming\",\n            color: \"#3178c6\",\n            group: \"TypeScript\",\n            extensions: [\".tsx\"],\n            tmScope: \"source.tsx\",\n            aceMode: \"javascript\",\n            codemirrorMode: \"jsx\",\n            codemirrorMimeType: \"text/jsx\",\n            languageId: 94901924\n          };\n        }\n      }),\n      wa = te({\n        \"node_modules/linguist-languages/data/JSON.json\"(e, r) {\n          r.exports = {\n            name: \"JSON\",\n            type: \"data\",\n            color: \"#292929\",\n            tmScope: \"source.json\",\n            aceMode: \"json\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"application/json\",\n            aliases: [\"geojson\", \"jsonl\", \"topojson\"],\n            extensions: [\".json\", \".4DForm\", \".4DProject\", \".avsc\", \".geojson\", \".gltf\", \".har\", \".ice\", \".JSON-tmLanguage\", \".jsonl\", \".mcmeta\", \".tfstate\", \".tfstate.backup\", \".topojson\", \".webapp\", \".webmanifest\", \".yy\", \".yyp\"],\n            filenames: [\".arcconfig\", \".auto-changelog\", \".c8rc\", \".htmlhintrc\", \".imgbotconfig\", \".nycrc\", \".tern-config\", \".tern-project\", \".watchmanconfig\", \"Pipfile.lock\", \"composer.lock\", \"mcmod.info\"],\n            languageId: 174\n          };\n        }\n      }),\n      bd = te({\n        \"node_modules/linguist-languages/data/JSON with Comments.json\"(e, r) {\n          r.exports = {\n            name: \"JSON with Comments\",\n            type: \"data\",\n            color: \"#292929\",\n            group: \"JSON\",\n            tmScope: \"source.js\",\n            aceMode: \"javascript\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"text/javascript\",\n            aliases: [\"jsonc\"],\n            extensions: [\".jsonc\", \".code-snippets\", \".sublime-build\", \".sublime-commands\", \".sublime-completions\", \".sublime-keymap\", \".sublime-macro\", \".sublime-menu\", \".sublime-mousemap\", \".sublime-project\", \".sublime-settings\", \".sublime-theme\", \".sublime-workspace\", \".sublime_metrics\", \".sublime_session\"],\n            filenames: [\".babelrc\", \".devcontainer.json\", \".eslintrc.json\", \".jscsrc\", \".jshintrc\", \".jslintrc\", \"api-extractor.json\", \"devcontainer.json\", \"jsconfig.json\", \"language-configuration.json\", \"tsconfig.json\", \"tslint.json\"],\n            languageId: 423\n          };\n        }\n      }),\n      Td = te({\n        \"node_modules/linguist-languages/data/JSON5.json\"(e, r) {\n          r.exports = {\n            name: \"JSON5\",\n            type: \"data\",\n            color: \"#267CB9\",\n            extensions: [\".json5\"],\n            tmScope: \"source.js\",\n            aceMode: \"javascript\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"application/json\",\n            languageId: 175\n          };\n        }\n      }),\n      Bd = te({\n        \"src/language-js/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = _t(),\n            s = Cd(),\n            a = Ed(),\n            n = Fd(),\n            u = Ad(),\n            i = [t(Ln(), p => ({\n              since: \"0.0.0\",\n              parsers: [\"babel\", \"acorn\", \"espree\", \"meriyah\", \"babel-flow\", \"babel-ts\", \"flow\", \"typescript\"],\n              vscodeLanguageIds: [\"javascript\", \"mongo\"],\n              interpreters: [...p.interpreters, \"zx\"],\n              extensions: [...p.extensions.filter(y => y !== \".jsx\"), \".wxs\"]\n            })), t(Ln(), () => ({\n              name: \"Flow\",\n              since: \"0.0.0\",\n              parsers: [\"flow\", \"babel-flow\"],\n              vscodeLanguageIds: [\"javascript\"],\n              aliases: [],\n              filenames: [],\n              extensions: [\".js.flow\"]\n            })), t(Ln(), () => ({\n              name: \"JSX\",\n              since: \"0.0.0\",\n              parsers: [\"babel\", \"babel-flow\", \"babel-ts\", \"flow\", \"typescript\", \"espree\", \"meriyah\"],\n              vscodeLanguageIds: [\"javascriptreact\"],\n              aliases: void 0,\n              filenames: void 0,\n              extensions: [\".jsx\"],\n              group: \"JavaScript\",\n              interpreters: void 0,\n              tmScope: \"source.js.jsx\",\n              aceMode: \"javascript\",\n              codemirrorMode: \"jsx\",\n              codemirrorMimeType: \"text/jsx\",\n              color: void 0\n            })), t(Sd(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"typescript\", \"babel-ts\"],\n              vscodeLanguageIds: [\"typescript\"]\n            })), t(xd(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"typescript\", \"babel-ts\"],\n              vscodeLanguageIds: [\"typescriptreact\"]\n            })), t(wa(), () => ({\n              name: \"JSON.stringify\",\n              since: \"1.13.0\",\n              parsers: [\"json-stringify\"],\n              vscodeLanguageIds: [\"json\"],\n              extensions: [\".importmap\"],\n              filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"]\n            })), t(wa(), p => ({\n              since: \"1.5.0\",\n              parsers: [\"json\"],\n              vscodeLanguageIds: [\"json\"],\n              extensions: p.extensions.filter(y => y !== \".jsonl\")\n            })), t(bd(), p => ({\n              since: \"1.5.0\",\n              parsers: [\"json\"],\n              vscodeLanguageIds: [\"jsonc\"],\n              filenames: [...p.filenames, \".eslintrc\", \".swcrc\"]\n            })), t(Td(), () => ({\n              since: \"1.13.0\",\n              parsers: [\"json5\"],\n              vscodeLanguageIds: [\"json5\"]\n            }))],\n            l = {\n              estree: s,\n              \"estree-json\": a\n            };\n          r.exports = {\n            languages: i,\n            options: n,\n            printers: l,\n            parsers: u\n          };\n        }\n      }),\n      Nd = te({\n        \"src/language-css/clean.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isFrontMatterNode: t\n            } = Ue(),\n            s = lt(),\n            a = new Set([\"raw\", \"raws\", \"sourceIndex\", \"source\", \"before\", \"after\", \"trailingComma\"]);\n          function n(i, l, p) {\n            if (t(i) && i.lang === \"yaml\" && delete l.value, i.type === \"css-comment\" && p.type === \"css-root\" && p.nodes.length > 0 && ((p.nodes[0] === i || t(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\\*\\s*@(?:format|prettier)\\s*$/.test(i.text)) || p.type === \"css-root\" && s(p.nodes) === i)) return null;\n            if (i.type === \"value-root\" && delete l.text, (i.type === \"media-query\" || i.type === \"media-query-list\" || i.type === \"media-feature-expression\") && delete l.value, i.type === \"css-rule\" && delete l.params, i.type === \"selector-combinator\" && (l.value = l.value.replace(/\\s+/g, \" \")), i.type === \"media-feature\" && (l.value = l.value.replace(/ /g, \"\")), (i.type === \"value-word\" && (i.isColor && i.isHex || [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(l.value.replace().toLowerCase())) || i.type === \"media-feature\" || i.type === \"selector-root-invalid\" || i.type === \"selector-pseudo\") && (l.value = l.value.toLowerCase()), i.type === \"css-decl\" && (l.prop = l.prop.toLowerCase()), (i.type === \"css-atrule\" || i.type === \"css-import\") && (l.name = l.name.toLowerCase()), i.type === \"value-number\" && (l.unit = l.unit.toLowerCase()), (i.type === \"media-feature\" || i.type === \"media-keyword\" || i.type === \"media-type\" || i.type === \"media-unknown\" || i.type === \"media-url\" || i.type === \"media-value\" || i.type === \"selector-attribute\" || i.type === \"selector-string\" || i.type === \"selector-class\" || i.type === \"selector-combinator\" || i.type === \"value-string\") && l.value && (l.value = u(l.value)), i.type === \"selector-attribute\" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == \"string\" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = !0)), l.value && (l.value = l.value.trim().replace(/^[\"']|[\"']$/g, \"\"), delete l.quoted)), (i.type === \"media-value\" || i.type === \"media-type\" || i.type === \"value-number\" || i.type === \"selector-root-invalid\" || i.type === \"selector-class\" || i.type === \"selector-combinator\" || i.type === \"selector-tag\") && l.value && (l.value = l.value.replace(/([\\d+.Ee-]+)([A-Za-z]*)/g, (y, h, g) => {\n              let c = Number(h);\n              return Number.isNaN(c) ? y : c + g.toLowerCase();\n            })), i.type === \"selector-tag\") {\n              let y = i.value.toLowerCase();\n              [\"from\", \"to\"].includes(y) && (l.value = y);\n            }\n            if (i.type === \"css-atrule\" && i.name.toLowerCase() === \"supports\" && delete l.value, i.type === \"selector-unknown\" && delete l.value, i.type === \"value-comma_group\") {\n              let y = i.groups.findIndex(h => h.type === \"value-number\" && h.unit === \"...\");\n              y !== -1 && (l.groups[y].unit = \"\", l.groups.splice(y + 1, 0, {\n                type: \"value-word\",\n                value: \"...\",\n                isColor: !1,\n                isHex: !1\n              }));\n            }\n            if (i.type === \"value-comma_group\" && i.groups.some(y => y.type === \"value-atword\" && y.value.endsWith(\"[\") || y.type === \"value-word\" && y.value.startsWith(\"]\"))) return {\n              type: \"value-atword\",\n              value: i.groups.map(y => y.value).join(\"\"),\n              group: {\n                open: null,\n                close: null,\n                groups: [],\n                type: \"value-paren_group\"\n              }\n            };\n          }\n          n.ignoredProperties = a;\n          function u(i) {\n            return i.replace(/'/g, '\"').replace(/\\\\([^\\dA-Fa-f])/g, \"$1\");\n          }\n          r.exports = n;\n        }\n      }),\n      su = te({\n        \"src/utils/front-matter/print.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            builders: {\n              hardline: t,\n              markAsRoot: s\n            }\n          } = qe();\n          function a(n, u) {\n            if (n.lang === \"yaml\") {\n              let i = n.value.trim(),\n                l = i ? u(i, {\n                  parser: \"yaml\"\n                }, {\n                  stripTrailingHardline: !0\n                }) : \"\";\n              return s([n.startDelimiter, t, l, l ? t : \"\", n.endDelimiter]);\n            }\n          }\n          r.exports = a;\n        }\n      }),\n      wd = te({\n        \"src/language-css/embed.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                hardline: t\n              }\n            } = qe(),\n            s = su();\n          function a(n, u, i) {\n            let l = n.getValue();\n            if (l.type === \"front-matter\") {\n              let p = s(l, i);\n              return p ? [p, t] : \"\";\n            }\n          }\n          r.exports = a;\n        }\n      }),\n      _o = te({\n        \"src/utils/front-matter/parse.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = new RegExp(\"^(?<startDelimiter>-{3}|\\\\+{3})(?<language>[^\\\\n]*)\\\\n(?:|(?<value>.*?)\\\\n)(?<endDelimiter>\\\\k<startDelimiter>|\\\\.{3})[^\\\\S\\\\n]*(?:\\\\n|$)\", \"s\");\n          function s(a) {\n            let n = a.match(t);\n            if (!n) return {\n              content: a\n            };\n            let {\n                startDelimiter: u,\n                language: i,\n                value: l = \"\",\n                endDelimiter: p\n              } = n.groups,\n              y = i.trim() || \"yaml\";\n            if (u === \"+++\" && (y = \"toml\"), y !== \"yaml\" && u !== p) return {\n              content: a\n            };\n            let [h] = n;\n            return {\n              frontMatter: {\n                type: \"front-matter\",\n                lang: y,\n                value: l,\n                startDelimiter: u,\n                endDelimiter: p,\n                raw: h.replace(/\\n$/, \"\")\n              },\n              content: h.replace(/[^\\n]/g, \" \") + a.slice(h.length)\n            };\n          }\n          r.exports = s;\n        }\n      }),\n      _d = te({\n        \"src/language-css/pragma.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Co(),\n            s = _o();\n          function a(u) {\n            return t.hasPragma(s(u).content);\n          }\n          function n(u) {\n            let {\n              frontMatter: i,\n              content: l\n            } = s(u);\n            return (i ? i.raw + `\n\n` : \"\") + t.insertPragma(l);\n          }\n          r.exports = {\n            hasPragma: a,\n            insertPragma: n\n          };\n        }\n      }),\n      Pd = te({\n        \"src/language-css/utils/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = new Set([\"red\", \"green\", \"blue\", \"alpha\", \"a\", \"rgb\", \"hue\", \"h\", \"saturation\", \"s\", \"lightness\", \"l\", \"whiteness\", \"w\", \"blackness\", \"b\", \"tint\", \"shade\", \"blend\", \"blenda\", \"contrast\", \"hsl\", \"hsla\", \"hwb\", \"hwba\"]);\n          function s(z, U) {\n            let Z = Array.isArray(U) ? U : [U],\n              se = -1,\n              fe;\n            for (; fe = z.getParentNode(++se);) if (Z.includes(fe.type)) return se;\n            return -1;\n          }\n          function a(z, U) {\n            let Z = s(z, U);\n            return Z === -1 ? null : z.getParentNode(Z);\n          }\n          function n(z) {\n            var U;\n            let Z = a(z, \"css-decl\");\n            return Z == null || (U = Z.prop) === null || U === void 0 ? void 0 : U.toLowerCase();\n          }\n          var u = new Set([\"initial\", \"inherit\", \"unset\", \"revert\"]);\n          function i(z) {\n            return u.has(z.toLowerCase());\n          }\n          function l(z, U) {\n            let Z = a(z, \"css-atrule\");\n            return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith(\"keyframes\") && [\"from\", \"to\"].includes(U.toLowerCase());\n          }\n          function p(z) {\n            return z.includes(\"$\") || z.includes(\"@\") || z.includes(\"#\") || z.startsWith(\"%\") || z.startsWith(\"--\") || z.startsWith(\":--\") || z.includes(\"(\") && z.includes(\")\") ? z : z.toLowerCase();\n          }\n          function y(z, U) {\n            var Z;\n            let se = a(z, \"value-func\");\n            return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U;\n          }\n          function h(z) {\n            var U;\n            let Z = a(z, \"css-rule\"),\n              se = Z == null || (U = Z.raws) === null || U === void 0 ? void 0 : U.selector;\n            return se && (se.startsWith(\":import\") || se.startsWith(\":export\"));\n          }\n          function g(z, U) {\n            let Z = Array.isArray(U) ? U : [U],\n              se = a(z, \"css-atrule\");\n            return se && Z.includes(se.name.toLowerCase());\n          }\n          function c(z) {\n            let U = z.getValue(),\n              Z = a(z, \"css-atrule\");\n            return (Z == null ? void 0 : Z.name) === \"import\" && U.groups[0].value === \"url\" && U.groups.length === 2;\n          }\n          function f(z) {\n            return z.type === \"value-func\" && z.value.toLowerCase() === \"url\";\n          }\n          function F(z, U) {\n            var Z;\n            let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;\n            return se && se.indexOf(U) === se.length - 1;\n          }\n          function _(z) {\n            let {\n              selector: U\n            } = z;\n            return U ? typeof U == \"string\" && /^@.+:.*$/.test(U) || U.value && /^@.+:.*$/.test(U.value) : !1;\n          }\n          function w(z) {\n            return z.type === \"value-word\" && [\"from\", \"through\", \"end\"].includes(z.value);\n          }\n          function E(z) {\n            return z.type === \"value-word\" && [\"and\", \"or\", \"not\"].includes(z.value);\n          }\n          function N(z) {\n            return z.type === \"value-word\" && z.value === \"in\";\n          }\n          function x(z) {\n            return z.type === \"value-operator\" && z.value === \"*\";\n          }\n          function I(z) {\n            return z.type === \"value-operator\" && z.value === \"/\";\n          }\n          function P(z) {\n            return z.type === \"value-operator\" && z.value === \"+\";\n          }\n          function $(z) {\n            return z.type === \"value-operator\" && z.value === \"-\";\n          }\n          function D(z) {\n            return z.type === \"value-operator\" && z.value === \"%\";\n          }\n          function T(z) {\n            return x(z) || I(z) || P(z) || $(z) || D(z);\n          }\n          function m(z) {\n            return z.type === \"value-word\" && [\"==\", \"!=\"].includes(z.value);\n          }\n          function C(z) {\n            return z.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].includes(z.value);\n          }\n          function o(z) {\n            return z.type === \"css-atrule\" && [\"if\", \"else\", \"for\", \"each\", \"while\"].includes(z.name);\n          }\n          function d(z) {\n            var U;\n            return ((U = z.raws) === null || U === void 0 ? void 0 : U.params) && /^\\(\\s*\\)$/.test(z.raws.params);\n          }\n          function v(z) {\n            return z.name.startsWith(\"prettier-placeholder\");\n          }\n          function S(z) {\n            return z.prop.startsWith(\"@prettier-placeholder\");\n          }\n          function b(z, U) {\n            return z.value === \"$$\" && z.type === \"value-func\" && (U == null ? void 0 : U.type) === \"value-word\" && !U.raws.before;\n          }\n          function B(z) {\n            var U, Z;\n            return ((U = z.value) === null || U === void 0 ? void 0 : U.type) === \"value-root\" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === \"value-value\" && z.prop.toLowerCase() === \"composes\";\n          }\n          function k(z) {\n            var U, Z, se;\n            return ((U = z.value) === null || U === void 0 || (Z = U.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === \"value-paren_group\" && z.value.group.group.open !== null && z.value.group.group.close !== null;\n          }\n          function M(z) {\n            var U;\n            return ((U = z.raws) === null || U === void 0 ? void 0 : U.before) === \"\";\n          }\n          function R(z) {\n            var U, Z;\n            return z.type === \"value-comma_group\" && ((U = z.groups) === null || U === void 0 || (Z = U[1]) === null || Z === void 0 ? void 0 : Z.type) === \"value-colon\";\n          }\n          function q(z) {\n            var U;\n            return z.type === \"value-paren_group\" && ((U = z.groups) === null || U === void 0 ? void 0 : U[0]) && R(z.groups[0]);\n          }\n          function J(z) {\n            var U;\n            let Z = z.getValue();\n            if (Z.groups.length === 0) return !1;\n            let se = z.getParentNode(1);\n            if (!q(Z) && !(se && q(se))) return !1;\n            let fe = a(z, \"css-decl\");\n            return !!(fe != null && (U = fe.prop) !== null && U !== void 0 && U.startsWith(\"$\") || q(se) || se.type === \"value-func\");\n          }\n          function L(z) {\n            return z.type === \"value-comment\" && z.inline;\n          }\n          function Q(z) {\n            return z.type === \"value-word\" && z.value === \"#\";\n          }\n          function V(z) {\n            return z.type === \"value-word\" && z.value === \"{\";\n          }\n          function j(z) {\n            return z.type === \"value-word\" && z.value === \"}\";\n          }\n          function Y(z) {\n            return [\"value-word\", \"value-atword\"].includes(z.type);\n          }\n          function ie(z) {\n            return (z == null ? void 0 : z.type) === \"value-colon\";\n          }\n          function ee(z, U) {\n            if (!R(U)) return !1;\n            let {\n                groups: Z\n              } = U,\n              se = Z.indexOf(z);\n            return se === -1 ? !1 : ie(Z[se + 1]);\n          }\n          function ce(z) {\n            return z.value && [\"not\", \"and\", \"or\"].includes(z.value.toLowerCase());\n          }\n          function W(z) {\n            return z.type !== \"value-func\" ? !1 : t.has(z.value.toLowerCase());\n          }\n          function K(z) {\n            return /\\/\\//.test(z.split(/[\\n\\r]/).pop());\n          }\n          function de(z) {\n            return (z == null ? void 0 : z.type) === \"value-atword\" && z.value.startsWith(\"prettier-placeholder-\");\n          }\n          function ue(z, U) {\n            var Z, se;\n            if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== \"(\" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== \")\" || z.groups.some(fe => fe.type !== \"value-comma_group\")) return !1;\n            if (U.type === \"value-comma_group\") {\n              let fe = U.groups.indexOf(z) - 1,\n                ge = U.groups[fe];\n              if ((ge == null ? void 0 : ge.type) === \"value-word\" && ge.value === \"with\") return !0;\n            }\n            return !1;\n          }\n          function Fe(z) {\n            var U, Z;\n            return z.type === \"value-paren_group\" && ((U = z.open) === null || U === void 0 ? void 0 : U.value) === \"(\" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === \")\";\n          }\n          r.exports = {\n            getAncestorCounter: s,\n            getAncestorNode: a,\n            getPropOfDeclNode: n,\n            maybeToLowerCase: p,\n            insideValueFunctionNode: y,\n            insideICSSRuleNode: h,\n            insideAtRuleNode: g,\n            insideURLFunctionInImportAtRuleNode: c,\n            isKeyframeAtRuleKeywords: l,\n            isWideKeywords: i,\n            isLastNode: F,\n            isSCSSControlDirectiveNode: o,\n            isDetachedRulesetDeclarationNode: _,\n            isRelationalOperatorNode: C,\n            isEqualityOperatorNode: m,\n            isMultiplicationNode: x,\n            isDivisionNode: I,\n            isAdditionNode: P,\n            isSubtractionNode: $,\n            isModuloNode: D,\n            isMathOperatorNode: T,\n            isEachKeywordNode: N,\n            isForKeywordNode: w,\n            isURLFunctionNode: f,\n            isIfElseKeywordNode: E,\n            hasComposesNode: B,\n            hasParensAroundNode: k,\n            hasEmptyRawBefore: M,\n            isDetachedRulesetCallNode: d,\n            isTemplatePlaceholderNode: v,\n            isTemplatePropNode: S,\n            isPostcssSimpleVarNode: b,\n            isKeyValuePairNode: R,\n            isKeyValuePairInParenGroupNode: q,\n            isKeyInValuePairNode: ee,\n            isSCSSMapItemNode: J,\n            isInlineValueCommentNode: L,\n            isHashNode: Q,\n            isLeftCurlyBraceNode: V,\n            isRightCurlyBraceNode: j,\n            isWordNode: Y,\n            isColonNode: ie,\n            isMediaAndSupportsKeywords: ce,\n            isColorAdjusterFuncNode: W,\n            lastLineHasInlineComment: K,\n            isAtWordPlaceholderNode: de,\n            isConfigurationNode: ue,\n            isParenGroupNode: Fe\n          };\n        }\n      }),\n      Id = te({\n        \"src/utils/line-column-to-index.js\"(e, r) {\n          \"use strict\";\n\n          ne(), r.exports = function (t, s) {\n            let a = 0;\n            for (let n = 0; n < t.line - 1; ++n) a = s.indexOf(`\n`, a) + 1;\n            return a + t.column;\n          };\n        }\n      }),\n      kd = te({\n        \"src/language-css/loc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              skipEverythingButNewLine: t\n            } = Pr(),\n            s = lt(),\n            a = Id();\n          function n(c, f) {\n            return typeof c.sourceIndex == \"number\" ? c.sourceIndex : c.source ? a(c.source.start, f) - 1 : null;\n          }\n          function u(c, f) {\n            if (c.type === \"css-comment\" && c.inline) return t(f, c.source.startOffset);\n            let F = c.nodes && s(c.nodes);\n            return F && c.source && !c.source.end && (c = F), c.source && c.source.end ? a(c.source.end, f) : null;\n          }\n          function i(c, f) {\n            c.source && (c.source.startOffset = n(c, f), c.source.endOffset = u(c, f));\n            for (let F in c) {\n              let _ = c[F];\n              F === \"source\" || !_ || typeof _ != \"object\" || (_.type === \"value-root\" || _.type === \"value-unknown\" ? l(_, p(c), _.text || _.value) : i(_, f));\n            }\n          }\n          function l(c, f, F) {\n            c.source && (c.source.startOffset = n(c, F) + f, c.source.endOffset = u(c, F) + f);\n            for (let _ in c) {\n              let w = c[_];\n              _ === \"source\" || !w || typeof w != \"object\" || l(w, f, F);\n            }\n          }\n          function p(c) {\n            let f = c.source.startOffset;\n            return typeof c.prop == \"string\" && (f += c.prop.length), c.type === \"css-atrule\" && typeof c.name == \"string\" && (f += 1 + c.name.length + c.raws.afterName.match(/^\\s*:?\\s*/)[0].length), c.type !== \"css-atrule\" && c.raws && typeof c.raws.between == \"string\" && (f += c.raws.between.length), f;\n          }\n          function y(c) {\n            let f = \"initial\",\n              F = \"initial\",\n              _,\n              w = !1,\n              E = [];\n            for (let N = 0; N < c.length; N++) {\n              let x = c[N];\n              switch (f) {\n                case \"initial\":\n                  if (x === \"'\") {\n                    f = \"single-quotes\";\n                    continue;\n                  }\n                  if (x === '\"') {\n                    f = \"double-quotes\";\n                    continue;\n                  }\n                  if ((x === \"u\" || x === \"U\") && c.slice(N, N + 4).toLowerCase() === \"url(\") {\n                    f = \"url\", N += 3;\n                    continue;\n                  }\n                  if (x === \"*\" && c[N - 1] === \"/\") {\n                    f = \"comment-block\";\n                    continue;\n                  }\n                  if (x === \"/\" && c[N - 1] === \"/\") {\n                    f = \"comment-inline\", _ = N - 1;\n                    continue;\n                  }\n                  continue;\n                case \"single-quotes\":\n                  if (x === \"'\" && c[N - 1] !== \"\\\\\" && (f = F, F = \"initial\"), x === `\n` || x === \"\\r\") return c;\n                  continue;\n                case \"double-quotes\":\n                  if (x === '\"' && c[N - 1] !== \"\\\\\" && (f = F, F = \"initial\"), x === `\n` || x === \"\\r\") return c;\n                  continue;\n                case \"url\":\n                  if (x === \")\" && (f = \"initial\"), x === `\n` || x === \"\\r\") return c;\n                  if (x === \"'\") {\n                    f = \"single-quotes\", F = \"url\";\n                    continue;\n                  }\n                  if (x === '\"') {\n                    f = \"double-quotes\", F = \"url\";\n                    continue;\n                  }\n                  continue;\n                case \"comment-block\":\n                  x === \"/\" && c[N - 1] === \"*\" && (f = \"initial\");\n                  continue;\n                case \"comment-inline\":\n                  (x === '\"' || x === \"'\" || x === \"*\") && (w = !0), (x === `\n` || x === \"\\r\") && (w && E.push([_, N]), f = \"initial\", w = !1);\n                  continue;\n              }\n            }\n            for (let [N, x] of E) c = c.slice(0, N) + c.slice(N, x).replace(/[\"'*]/g, \" \") + c.slice(x);\n            return c;\n          }\n          function h(c) {\n            return c.source.startOffset;\n          }\n          function g(c) {\n            return c.source.endOffset;\n          }\n          r.exports = {\n            locStart: h,\n            locEnd: g,\n            calculateLoc: i,\n            replaceQuotesInInlineComments: y\n          };\n        }\n      }),\n      Ld = te({\n        \"src/language-css/utils/is-less-parser.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s) {\n            return s.parser === \"css\" || s.parser === \"less\";\n          }\n          r.exports = t;\n        }\n      }),\n      Od = te({\n        \"src/language-css/utils/is-scss.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s, a) {\n            return s === \"less\" || s === \"scss\" ? s === \"scss\" : /(?:\\w\\s*:\\s*[^:}]+|#){|@import[^\\n]+(?:url|,)/.test(a);\n          }\n          r.exports = t;\n        }\n      }),\n      jd = te({\n        \"src/language-css/utils/css-units.evaluate.js\"(e, r) {\n          r.exports = {\n            em: \"em\",\n            rem: \"rem\",\n            ex: \"ex\",\n            rex: \"rex\",\n            cap: \"cap\",\n            rcap: \"rcap\",\n            ch: \"ch\",\n            rch: \"rch\",\n            ic: \"ic\",\n            ric: \"ric\",\n            lh: \"lh\",\n            rlh: \"rlh\",\n            vw: \"vw\",\n            svw: \"svw\",\n            lvw: \"lvw\",\n            dvw: \"dvw\",\n            vh: \"vh\",\n            svh: \"svh\",\n            lvh: \"lvh\",\n            dvh: \"dvh\",\n            vi: \"vi\",\n            svi: \"svi\",\n            lvi: \"lvi\",\n            dvi: \"dvi\",\n            vb: \"vb\",\n            svb: \"svb\",\n            lvb: \"lvb\",\n            dvb: \"dvb\",\n            vmin: \"vmin\",\n            svmin: \"svmin\",\n            lvmin: \"lvmin\",\n            dvmin: \"dvmin\",\n            vmax: \"vmax\",\n            svmax: \"svmax\",\n            lvmax: \"lvmax\",\n            dvmax: \"dvmax\",\n            cm: \"cm\",\n            mm: \"mm\",\n            q: \"Q\",\n            in: \"in\",\n            pt: \"pt\",\n            pc: \"pc\",\n            px: \"px\",\n            deg: \"deg\",\n            grad: \"grad\",\n            rad: \"rad\",\n            turn: \"turn\",\n            s: \"s\",\n            ms: \"ms\",\n            hz: \"Hz\",\n            khz: \"kHz\",\n            dpi: \"dpi\",\n            dpcm: \"dpcm\",\n            dppx: \"dppx\",\n            x: \"x\"\n          };\n        }\n      }),\n      qd = te({\n        \"src/language-css/utils/print-unit.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = jd();\n          function s(a) {\n            let n = a.toLowerCase();\n            return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a;\n          }\n          r.exports = s;\n        }\n      }),\n      Md = te({\n        \"src/language-css/printer-postcss.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = lt(),\n            {\n              printNumber: s,\n              printString: a,\n              hasNewline: n,\n              isFrontMatterNode: u,\n              isNextLineEmpty: i,\n              isNonEmptyArray: l\n            } = Ue(),\n            {\n              builders: {\n                join: p,\n                line: y,\n                hardline: h,\n                softline: g,\n                group: c,\n                fill: f,\n                indent: F,\n                dedent: _,\n                ifBreak: w,\n                breakParent: E\n              },\n              utils: {\n                removeLines: N,\n                getDocParts: x\n              }\n            } = qe(),\n            I = Nd(),\n            P = wd(),\n            {\n              insertPragma: $\n            } = _d(),\n            {\n              getAncestorNode: D,\n              getPropOfDeclNode: T,\n              maybeToLowerCase: m,\n              insideValueFunctionNode: C,\n              insideICSSRuleNode: o,\n              insideAtRuleNode: d,\n              insideURLFunctionInImportAtRuleNode: v,\n              isKeyframeAtRuleKeywords: S,\n              isWideKeywords: b,\n              isLastNode: B,\n              isSCSSControlDirectiveNode: k,\n              isDetachedRulesetDeclarationNode: M,\n              isRelationalOperatorNode: R,\n              isEqualityOperatorNode: q,\n              isMultiplicationNode: J,\n              isDivisionNode: L,\n              isAdditionNode: Q,\n              isSubtractionNode: V,\n              isMathOperatorNode: j,\n              isEachKeywordNode: Y,\n              isForKeywordNode: ie,\n              isURLFunctionNode: ee,\n              isIfElseKeywordNode: ce,\n              hasComposesNode: W,\n              hasParensAroundNode: K,\n              hasEmptyRawBefore: de,\n              isKeyValuePairNode: ue,\n              isKeyInValuePairNode: Fe,\n              isDetachedRulesetCallNode: z,\n              isTemplatePlaceholderNode: U,\n              isTemplatePropNode: Z,\n              isPostcssSimpleVarNode: se,\n              isSCSSMapItemNode: fe,\n              isInlineValueCommentNode: ge,\n              isHashNode: he,\n              isLeftCurlyBraceNode: we,\n              isRightCurlyBraceNode: ke,\n              isWordNode: Re,\n              isColonNode: Ne,\n              isMediaAndSupportsKeywords: Pe,\n              isColorAdjusterFuncNode: oe,\n              lastLineHasInlineComment: H,\n              isAtWordPlaceholderNode: pe,\n              isConfigurationNode: X,\n              isParenGroupNode: le\n            } = Pd(),\n            {\n              locStart: Ae,\n              locEnd: Ee\n            } = kd(),\n            De = Ld(),\n            A = Od(),\n            G = qd();\n          function re(Te) {\n            return Te.trailingComma === \"es5\" || Te.trailingComma === \"all\";\n          }\n          function ye(Te, je, Me) {\n            let ae = Te.getValue();\n            if (!ae) return \"\";\n            if (typeof ae == \"string\") return ae;\n            switch (ae.type) {\n              case \"front-matter\":\n                return [ae.raw, h];\n              case \"css-root\":\n                {\n                  let Ve = Ce(Te, je, Me),\n                    We = ae.raws.after.trim();\n                  return We.startsWith(\";\") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : \"\", x(Ve).length > 0 ? h : \"\"];\n                }\n              case \"css-comment\":\n                {\n                  let Ve = ae.inline || ae.raws.inline,\n                    We = je.originalText.slice(Ae(ae), Ee(ae));\n                  return Ve ? We.trimEnd() : We;\n                }\n              case \"css-rule\":\n                return [Me(\"selector\"), ae.important ? \" !important\" : \"\", ae.nodes ? [ae.selector && ae.selector.type === \"selector-unknown\" && H(ae.selector.value) ? y : \" \", \"{\", ae.nodes.length > 0 ? F([h, Ce(Te, je, Me)]) : \"\", h, \"}\", M(ae) ? \";\" : \"\"] : \";\"];\n              case \"css-decl\":\n                {\n                  let Ve = Te.getParentNode(),\n                    {\n                      between: We\n                    } = ae.raws,\n                    Xe = We.trim(),\n                    st = Xe === \":\",\n                    O = W(ae) ? N(Me(\"value\")) : Me(\"value\");\n                  return !st && H(Xe) && (O = F([h, _(O)])), [ae.raws.before.replace(/[\\s;]/g, \"\"), Ve.type === \"css-atrule\" && Ve.variable || o(Te) ? ae.prop : m(ae.prop), Xe.startsWith(\"//\") ? \" \" : \"\", Xe, ae.extend ? \"\" : \" \", De(je) && ae.extend && ae.selector ? [\"extend(\", Me(\"selector\"), \")\"] : \"\", O, ae.raws.important ? ae.raws.important.replace(/\\s*!\\s*important/i, \" !important\") : ae.important ? \" !important\" : \"\", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\\s*!default/i, \" !default\") : ae.scssDefault ? \" !default\" : \"\", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\\s*!global/i, \" !global\") : ae.scssGlobal ? \" !global\" : \"\", ae.nodes ? [\" {\", F([g, Ce(Te, je, Me)]), g, \"}\"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== \";\" ? \"\" : je.__isHTMLStyleAttribute && B(Te, ae) ? w(\";\") : \";\"];\n                }\n              case \"css-atrule\":\n                {\n                  let Ve = Te.getParentNode(),\n                    We = U(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== \";\";\n                  if (De(je)) {\n                    if (ae.mixin) return [Me(\"selector\"), ae.important ? \" !important\" : \"\", We ? \"\" : \";\"];\n                    if (ae.function) return [ae.name, Me(\"params\"), We ? \"\" : \";\"];\n                    if (ae.variable) return [\"@\", ae.name, \": \", ae.value ? Me(\"value\") : \"\", ae.raws.between.trim() ? ae.raws.between.trim() + \" \" : \"\", ae.nodes ? [\"{\", F([ae.nodes.length > 0 ? g : \"\", Ce(Te, je, Me)]), g, \"}\"] : \"\", We ? \"\" : \";\"];\n                  }\n                  return [\"@\", z(ae) || ae.name.endsWith(\":\") ? ae.name : m(ae.name), ae.params ? [z(ae) ? \"\" : U(ae) ? ae.raws.afterName === \"\" ? \"\" : ae.name.endsWith(\":\") ? \" \" : /^\\s*\\n\\s*\\n/.test(ae.raws.afterName) ? [h, h] : /^\\s*\\n/.test(ae.raws.afterName) ? h : \" \" : \" \", Me(\"params\")] : \"\", ae.selector ? F([\" \", Me(\"selector\")]) : \"\", ae.value ? c([\" \", Me(\"value\"), k(ae) ? K(ae) ? \" \" : y : \"\"]) : ae.name === \"else\" ? \" \" : \"\", ae.nodes ? [k(ae) ? \"\" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == \"string\" && H(ae.selector.value) || !ae.selector && typeof ae.params == \"string\" && H(ae.params) ? y : \" \", \"{\", F([ae.nodes.length > 0 ? g : \"\", Ce(Te, je, Me)]), g, \"}\"] : We ? \"\" : \";\"];\n                }\n              case \"media-query-list\":\n                {\n                  let Ve = [];\n                  return Te.each(We => {\n                    let Xe = We.getValue();\n                    Xe.type === \"media-query\" && Xe.value === \"\" || Ve.push(Me());\n                  }, \"nodes\"), c(F(p(y, Ve)));\n                }\n              case \"media-query\":\n                return [p(\" \", Te.map(Me, \"nodes\")), B(Te, ae) ? \"\" : \",\"];\n              case \"media-type\":\n                return Oe(Se(ae.value, je));\n              case \"media-feature-expression\":\n                return ae.nodes ? [\"(\", ...Te.map(Me, \"nodes\"), \")\"] : ae.value;\n              case \"media-feature\":\n                return m(Se(ae.value.replace(/ +/g, \" \"), je));\n              case \"media-colon\":\n                return [ae.value, \" \"];\n              case \"media-value\":\n                return Oe(Se(ae.value, je));\n              case \"media-keyword\":\n                return Se(ae.value, je);\n              case \"media-url\":\n                return Se(ae.value.replace(/^url\\(\\s+/gi, \"url(\").replace(/\\s+\\)$/g, \")\"), je);\n              case \"media-unknown\":\n                return ae.value;\n              case \"selector-root\":\n                return c([d(Te, \"custom-selector\") ? [D(Te, \"css-atrule\").customSelector, y] : \"\", p([\",\", d(Te, [\"extend\", \"custom-selector\", \"nest\"]) ? y : h], Te.map(Me, \"nodes\"))]);\n              case \"selector-selector\":\n                return c(F(Te.map(Me, \"nodes\")));\n              case \"selector-comment\":\n                return ae.value;\n              case \"selector-string\":\n                return Se(ae.value, je);\n              case \"selector-tag\":\n                {\n                  let Ve = Te.getParentNode(),\n                    We = Ve && Ve.nodes.indexOf(ae),\n                    Xe = We && Ve.nodes[We - 1];\n                  return [ae.namespace ? [ae.namespace === !0 ? \"\" : ae.namespace.trim(), \"|\"] : \"\", Xe.type === \"selector-nesting\" ? ae.value : Oe(S(Te, ae.value) ? ae.value.toLowerCase() : ae.value)];\n                }\n              case \"selector-id\":\n                return [\"#\", ae.value];\n              case \"selector-class\":\n                return [\".\", Oe(Se(ae.value, je))];\n              case \"selector-attribute\":\n                {\n                  var nt;\n                  return [\"[\", ae.namespace ? [ae.namespace === !0 ? \"\" : ae.namespace.trim(), \"|\"] : \"\", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : \"\", ae.value ? Ie(Se(ae.value.trim(), je), je) : \"\", ae.insensitive ? \" i\" : \"\", \"]\"];\n                }\n              case \"selector-combinator\":\n                {\n                  if (ae.value === \"+\" || ae.value === \">\" || ae.value === \"~\" || ae.value === \">>>\") {\n                    let Xe = Te.getParentNode();\n                    return [Xe.type === \"selector-selector\" && Xe.nodes[0] === ae ? \"\" : y, ae.value, B(Te, ae) ? \"\" : \" \"];\n                  }\n                  let Ve = ae.value.trim().startsWith(\"(\") ? y : \"\",\n                    We = Oe(Se(ae.value.trim(), je)) || y;\n                  return [Ve, We];\n                }\n              case \"selector-universal\":\n                return [ae.namespace ? [ae.namespace === !0 ? \"\" : ae.namespace.trim(), \"|\"] : \"\", ae.value];\n              case \"selector-pseudo\":\n                return [m(ae.value), l(ae.nodes) ? c([\"(\", F([g, p([\",\", y], Te.map(Me, \"nodes\"))]), g, \")\"]) : \"\"];\n              case \"selector-nesting\":\n                return ae.value;\n              case \"selector-unknown\":\n                {\n                  let Ve = D(Te, \"css-rule\");\n                  if (Ve && Ve.isSCSSNesterProperty) return Oe(Se(m(ae.value), je));\n                  let We = Te.getParentNode();\n                  if (We.raws && We.raws.selector) {\n                    let st = Ae(We),\n                      O = st + We.raws.selector.length;\n                    return je.originalText.slice(st, O).trim();\n                  }\n                  let Xe = Te.getParentNode(1);\n                  if (We.type === \"value-paren_group\" && Xe && Xe.type === \"value-func\" && Xe.value === \"selector\") {\n                    let st = Ee(We.open) + 1,\n                      O = Ae(We.close),\n                      me = je.originalText.slice(st, O).trim();\n                    return H(me) ? [E, me] : me;\n                  }\n                  return ae.value;\n                }\n              case \"value-value\":\n              case \"value-root\":\n                return Me(\"group\");\n              case \"value-comment\":\n                return je.originalText.slice(Ae(ae), Ee(ae));\n              case \"value-comma_group\":\n                {\n                  let Ve = Te.getParentNode(),\n                    We = Te.getParentNode(1),\n                    Xe = T(Te),\n                    st = Xe && Ve.type === \"value-value\" && (Xe === \"grid\" || Xe.startsWith(\"grid-template\")),\n                    O = D(Te, \"css-atrule\"),\n                    me = O && k(O),\n                    _e = ae.groups.some(at => ge(at)),\n                    He = Te.map(Me, \"groups\"),\n                    Ge = [],\n                    it = C(Te, \"url\"),\n                    Qe = !1,\n                    rt = !1;\n                  for (let at = 0; at < ae.groups.length; ++at) {\n                    var tt;\n                    Ge.push(He[at]);\n                    let Ze = ae.groups[at - 1],\n                      Le = ae.groups[at],\n                      $e = ae.groups[at + 1],\n                      sr = ae.groups[at + 2];\n                    if (it) {\n                      ($e && Q($e) || Q(Le)) && Ge.push(\" \");\n                      continue;\n                    }\n                    if (d(Te, \"forward\") && Le.type === \"value-word\" && Le.value && Ze !== void 0 && Ze.type === \"value-word\" && Ze.value === \"as\" && $e.type === \"value-operator\" && $e.value === \"*\" || !$e || Le.type === \"value-word\" && Le.value.endsWith(\"-\") && pe($e)) continue;\n                    if (Le.type === \"value-string\" && Le.quoted) {\n                      let $r = Le.value.lastIndexOf(\"#{\"),\n                        Vr = Le.value.lastIndexOf(\"}\");\n                      $r !== -1 && Vr !== -1 ? Qe = $r > Vr : $r !== -1 ? Qe = !0 : Vr !== -1 && (Qe = !1);\n                    }\n                    if (Qe || Ne(Le) || Ne($e) || Le.type === \"value-atword\" && (Le.value === \"\" || Le.value.endsWith(\"[\")) || $e.type === \"value-word\" && $e.value.startsWith(\"]\") || Le.value === \"~\" || Le.value && Le.value.includes(\"\\\\\") && $e && $e.type !== \"value-comment\" || Ze && Ze.value && Ze.value.indexOf(\"\\\\\") === Ze.value.length - 1 && Le.type === \"value-operator\" && Le.value === \"/\" || Le.value === \"\\\\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === \"--\" && he($e)) continue;\n                    let Rr = j(Le),\n                      ou = j($e);\n                    if ((Rr && he($e) || ou && ke(Le)) && de($e) || !Ze && L(Le) || C(Te, \"calc\") && (Q(Le) || Q($e) || V(Le) || V($e)) && de($e)) continue;\n                    let qo = (Q(Le) || V(Le)) && at === 0 && ($e.type === \"value-number\" || $e.isHex) && We && oe(We) && !de($e),\n                      lu = sr && sr.type === \"value-func\" || sr && Re(sr) || Le.type === \"value-func\" || Re(Le),\n                      cu = $e.type === \"value-func\" || Re($e) || Ze && Ze.type === \"value-func\" || Ze && Re(Ze);\n                    if (!(!(J($e) || J(Le)) && !C(Te, \"calc\") && !qo && (L($e) && !lu || L(Le) && !cu || Q($e) && !lu || Q(Le) && !cu || V($e) || V(Le)) && (de($e) || Rr && (!Ze || Ze && j(Ze)))) && !((je.parser === \"scss\" || je.parser === \"less\") && Rr && Le.value === \"-\" && le($e) && Ee(Le) === Ae($e.open) && $e.open.value === \"(\")) {\n                      if (ge(Le)) {\n                        if (Ve.type === \"value-paren_group\") {\n                          Ge.push(_(h));\n                          continue;\n                        }\n                        Ge.push(h);\n                        continue;\n                      }\n                      if (me && (q($e) || R($e) || ce($e) || Y(Le) || ie(Le))) {\n                        Ge.push(\" \");\n                        continue;\n                      }\n                      if (O && O.name.toLowerCase() === \"namespace\") {\n                        Ge.push(\" \");\n                        continue;\n                      }\n                      if (st) {\n                        Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(h), rt = !0) : Ge.push(\" \");\n                        continue;\n                      }\n                      if (ou) {\n                        Ge.push(\" \");\n                        continue;\n                      }\n                      if (!($e && $e.value === \"...\") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {\n                        if (pe(Le) && le($e) && Ee(Le) === Ae($e.open)) {\n                          Ge.push(g);\n                          continue;\n                        }\n                        if (Le.value === \"with\" && le($e)) {\n                          Ge.push(\" \");\n                          continue;\n                        }\n                        (tt = Le.value) !== null && tt !== void 0 && tt.endsWith(\"#\") && $e.value === \"{\" && le($e.group) || Ge.push(y);\n                      }\n                    }\n                  }\n                  return _e && Ge.push(E), rt && Ge.unshift(h), me ? c(F(Ge)) : v(Te) ? c(f(Ge)) : c(F(f(Ge)));\n                }\n              case \"value-paren_group\":\n                {\n                  let Ve = Te.getParentNode();\n                  if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === \"value-comma_group\" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === \"value-word\" && ae.groups[0].groups[0].value.startsWith(\"data:\"))) return [ae.open ? Me(\"open\") : \"\", p(\",\", Te.map(Me, \"groups\")), ae.close ? Me(\"close\") : \"\"];\n                  if (!ae.open) {\n                    let it = Te.map(Me, \"groups\"),\n                      Qe = [];\n                    for (let rt = 0; rt < it.length; rt++) rt !== 0 && Qe.push([\",\", y]), Qe.push(it[rt]);\n                    return c(F(f(Qe)));\n                  }\n                  let We = fe(Te),\n                    Xe = t(ae.groups),\n                    st = Xe && Xe.type === \"value-comment\",\n                    O = Fe(ae, Ve),\n                    me = X(ae, Ve),\n                    _e = me || We && !O,\n                    He = me || O,\n                    Ge = c([ae.open ? Me(\"open\") : \"\", F([g, p([y], Te.map((it, Qe) => {\n                      let rt = it.getValue(),\n                        at = Qe === ae.groups.length - 1,\n                        Ze = [Me(), at ? \"\" : \",\"];\n                      if (ue(rt) && rt.type === \"value-comma_group\" && rt.groups && rt.groups[0].type !== \"value-paren_group\" && rt.groups[2] && rt.groups[2].type === \"value-paren_group\") {\n                        let Le = x(Ze[0].contents.contents);\n                        Le[1] = c(Le[1]), Ze = [c(_(Ze))];\n                      }\n                      if (!at && rt.type === \"value-comma_group\" && l(rt.groups)) {\n                        let Le = t(rt.groups);\n                        !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(h);\n                      }\n                      return Ze;\n                    }, \"groups\"))]), w(!st && A(je.parser, je.originalText) && We && re(je) ? \",\" : \"\"), g, ae.close ? Me(\"close\") : \"\"], {\n                      shouldBreak: _e\n                    });\n                  return He ? _(Ge) : Ge;\n                }\n              case \"value-func\":\n                return [ae.value, d(Te, \"supports\") && Pe(ae) ? \" \" : \"\", Me(\"group\")];\n              case \"value-paren\":\n                return ae.value;\n              case \"value-number\":\n                return [Je(ae.value), G(ae.unit)];\n              case \"value-operator\":\n                return ae.value;\n              case \"value-word\":\n                return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;\n              case \"value-colon\":\n                {\n                  let Ve = Te.getParentNode(),\n                    We = Ve && Ve.groups.indexOf(ae),\n                    Xe = We && Ve.groups[We - 1];\n                  return [ae.value, Xe && typeof Xe.value == \"string\" && t(Xe.value) === \"\\\\\" || C(Te, \"url\") ? \"\" : y];\n                }\n              case \"value-comma\":\n                return [ae.value, \" \"];\n              case \"value-string\":\n                return a(ae.raws.quote + ae.value + ae.raws.quote, je);\n              case \"value-atword\":\n                return [\"@\", ae.value];\n              case \"value-unicode-range\":\n                return ae.value;\n              case \"value-unknown\":\n                return ae.value;\n              default:\n                throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);\n            }\n          }\n          function Ce(Te, je, Me) {\n            let ae = [];\n            return Te.each((nt, tt, Ve) => {\n              let We = Ve[tt - 1];\n              if (We && We.type === \"css-comment\" && We.text.trim() === \"prettier-ignore\") {\n                let Xe = nt.getValue();\n                ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));\n              } else ae.push(Me());\n              tt !== Ve.length - 1 && (Ve[tt + 1].type === \"css-comment\" && !n(je.originalText, Ae(Ve[tt + 1]), {\n                backwards: !0\n              }) && !u(Ve[tt]) || Ve[tt + 1].type === \"css-atrule\" && Ve[tt + 1].name === \"else\" && Ve[tt].type !== \"css-comment\" ? ae.push(\" \") : (ae.push(je.__isHTMLStyleAttribute ? y : h), i(je.originalText, nt.getValue(), Ee) && !u(Ve[tt]) && ae.push(h)));\n            }, \"nodes\"), ae;\n          }\n          var Be = /([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*\\1/gs,\n            ve = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g,\n            ze = /[A-Za-z]+/g,\n            be = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g,\n            Ye = new RegExp(Be.source + `|(${be.source})?(${ve.source})(${ze.source})?`, \"g\");\n          function Se(Te, je) {\n            return Te.replace(Be, Me => a(Me, je));\n          }\n          function Ie(Te, je) {\n            let Me = je.singleQuote ? \"'\" : '\"';\n            return Te.includes('\"') || Te.includes(\"'\") ? Te : Me + Te + Me;\n          }\n          function Oe(Te) {\n            return Te.replace(Ye, (je, Me, ae, nt, tt) => !ae && nt ? Je(nt) + m(tt || \"\") : je);\n          }\n          function Je(Te) {\n            return s(Te).replace(/\\.0(?=$|e)/, \"\");\n          }\n          r.exports = {\n            print: ye,\n            embed: P,\n            insertPragma: $,\n            massageAstNode: I\n          };\n        }\n      }),\n      Rd = te({\n        \"src/language-css/options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Mt();\n          r.exports = {\n            singleQuote: t.singleQuote\n          };\n        }\n      }),\n      $d = te({\n        \"src/language-css/parsers.js\"() {\n          ne();\n        }\n      }),\n      Vd = te({\n        \"node_modules/linguist-languages/data/CSS.json\"(e, r) {\n          r.exports = {\n            name: \"CSS\",\n            type: \"markup\",\n            tmScope: \"source.css\",\n            aceMode: \"css\",\n            codemirrorMode: \"css\",\n            codemirrorMimeType: \"text/css\",\n            color: \"#563d7c\",\n            extensions: [\".css\"],\n            languageId: 50\n          };\n        }\n      }),\n      Wd = te({\n        \"node_modules/linguist-languages/data/PostCSS.json\"(e, r) {\n          r.exports = {\n            name: \"PostCSS\",\n            type: \"markup\",\n            color: \"#dc3a0c\",\n            tmScope: \"source.postcss\",\n            group: \"CSS\",\n            extensions: [\".pcss\", \".postcss\"],\n            aceMode: \"text\",\n            languageId: 262764437\n          };\n        }\n      }),\n      Hd = te({\n        \"node_modules/linguist-languages/data/Less.json\"(e, r) {\n          r.exports = {\n            name: \"Less\",\n            type: \"markup\",\n            color: \"#1d365d\",\n            aliases: [\"less-css\"],\n            extensions: [\".less\"],\n            tmScope: \"source.css.less\",\n            aceMode: \"less\",\n            codemirrorMode: \"css\",\n            codemirrorMimeType: \"text/css\",\n            languageId: 198\n          };\n        }\n      }),\n      Gd = te({\n        \"node_modules/linguist-languages/data/SCSS.json\"(e, r) {\n          r.exports = {\n            name: \"SCSS\",\n            type: \"markup\",\n            color: \"#c6538c\",\n            tmScope: \"source.css.scss\",\n            aceMode: \"scss\",\n            codemirrorMode: \"css\",\n            codemirrorMimeType: \"text/x-scss\",\n            extensions: [\".scss\"],\n            languageId: 329\n          };\n        }\n      }),\n      Ud = te({\n        \"src/language-css/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = _t(),\n            s = Md(),\n            a = Rd(),\n            n = $d(),\n            u = [t(Vd(), l => ({\n              since: \"1.4.0\",\n              parsers: [\"css\"],\n              vscodeLanguageIds: [\"css\"],\n              extensions: [...l.extensions, \".wxss\"]\n            })), t(Wd(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"css\"],\n              vscodeLanguageIds: [\"postcss\"]\n            })), t(Hd(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"less\"],\n              vscodeLanguageIds: [\"less\"]\n            })), t(Gd(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"scss\"],\n              vscodeLanguageIds: [\"scss\"]\n            }))],\n            i = {\n              postcss: s\n            };\n          r.exports = {\n            languages: u,\n            options: a,\n            printers: i,\n            parsers: n\n          };\n        }\n      }),\n      Jd = te({\n        \"src/language-handlebars/loc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(a) {\n            return a.loc.start.offset;\n          }\n          function s(a) {\n            return a.loc.end.offset;\n          }\n          r.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      zd = te({\n        \"src/language-handlebars/clean.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s, a) {\n            if (s.type === \"TextNode\") {\n              let n = s.chars.trim();\n              if (!n) return null;\n              a.chars = n.replace(/[\\t\\n\\f\\r ]+/g, \" \");\n            }\n            s.type === \"AttrNode\" && s.name.toLowerCase() === \"class\" && delete a.value;\n          }\n          t.ignoredProperties = new Set([\"loc\", \"selfClosing\"]), r.exports = t;\n        }\n      }),\n      Xd = te({\n        \"src/language-handlebars/html-void-elements.evaluate.js\"(e, r) {\n          r.exports = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"];\n        }\n      }),\n      Kd = te({\n        \"src/language-handlebars/utils.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = lt(),\n            s = Xd();\n          function a(x) {\n            let I = x.getValue(),\n              P = x.getParentNode(0);\n            return !!(g(x, [\"ElementNode\"]) && t(P.children) === I || g(x, [\"Block\"]) && t(P.body) === I);\n          }\n          function n(x) {\n            return x.toUpperCase() === x;\n          }\n          function u(x) {\n            return h(x, [\"ElementNode\"]) && typeof x.tag == \"string\" && !x.tag.startsWith(\":\") && (n(x.tag[0]) || x.tag.includes(\".\"));\n          }\n          var i = new Set(s);\n          function l(x) {\n            return i.has(x.toLowerCase()) && !n(x[0]);\n          }\n          function p(x) {\n            return x.selfClosing === !0 || l(x.tag) || u(x) && x.children.every(I => y(I));\n          }\n          function y(x) {\n            return h(x, [\"TextNode\"]) && !/\\S/.test(x.chars);\n          }\n          function h(x, I) {\n            return x && I.includes(x.type);\n          }\n          function g(x, I) {\n            let P = x.getParentNode(0);\n            return h(P, I);\n          }\n          function c(x, I) {\n            let P = _(x);\n            return h(P, I);\n          }\n          function f(x, I) {\n            let P = w(x);\n            return h(P, I);\n          }\n          function F(x, I) {\n            var P, $, D, T;\n            let m = x.getValue(),\n              C = (P = x.getParentNode(0)) !== null && P !== void 0 ? P : {},\n              o = ($ = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $ !== void 0 ? $ : [],\n              d = o.indexOf(m);\n            return d !== -1 && o[d + I];\n          }\n          function _(x) {\n            let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n            return F(x, -I);\n          }\n          function w(x) {\n            return F(x, 1);\n          }\n          function E(x) {\n            return h(x, [\"MustacheCommentStatement\"]) && typeof x.value == \"string\" && x.value.trim() === \"prettier-ignore\";\n          }\n          function N(x) {\n            let I = x.getValue(),\n              P = _(x, 2);\n            return E(I) || E(P);\n          }\n          r.exports = {\n            getNextNode: w,\n            getPreviousNode: _,\n            hasPrettierIgnore: N,\n            isLastNodeOfSiblings: a,\n            isNextNodeOfSomeType: f,\n            isNodeOfSomeType: h,\n            isParentOfSomeType: g,\n            isPreviousNodeOfSomeType: c,\n            isVoid: p,\n            isWhitespaceNode: y\n          };\n        }\n      }),\n      Yd = te({\n        \"src/language-handlebars/printer-glimmer.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                dedent: t,\n                fill: s,\n                group: a,\n                hardline: n,\n                ifBreak: u,\n                indent: i,\n                join: l,\n                line: p,\n                softline: y\n              },\n              utils: {\n                getDocParts: h,\n                replaceTextEndOfLine: g\n              }\n            } = qe(),\n            {\n              getPreferredQuote: c,\n              isNonEmptyArray: f\n            } = Ue(),\n            {\n              locStart: F,\n              locEnd: _\n            } = Jd(),\n            w = zd(),\n            {\n              getNextNode: E,\n              getPreviousNode: N,\n              hasPrettierIgnore: x,\n              isLastNodeOfSiblings: I,\n              isNextNodeOfSomeType: P,\n              isNodeOfSomeType: $,\n              isParentOfSomeType: D,\n              isPreviousNodeOfSomeType: T,\n              isVoid: m,\n              isWhitespaceNode: C\n            } = Kd(),\n            o = 2;\n          function d(H, pe, X) {\n            let le = H.getValue();\n            if (!le) return \"\";\n            if (x(H)) return pe.originalText.slice(F(le), _(le));\n            let Ae = pe.singleQuote ? \"'\" : '\"';\n            switch (le.type) {\n              case \"Block\":\n              case \"Program\":\n              case \"Template\":\n                return a(H.map(X, \"body\"));\n              case \"ElementNode\":\n                {\n                  let Ee = a(S(H, X)),\n                    De = pe.htmlWhitespaceSensitivity === \"ignore\" && P(H, [\"ElementNode\"]) ? y : \"\";\n                  if (m(le)) return [Ee, De];\n                  let A = [\"</\", le.tag, \">\"];\n                  return le.children.length === 0 ? [Ee, i(A), De] : pe.htmlWhitespaceSensitivity === \"ignore\" ? [Ee, i(b(H, pe, X)), n, i(A), De] : [Ee, i(a(b(H, pe, X))), i(A), De];\n                }\n              case \"BlockStatement\":\n                {\n                  let Ee = H.getParentNode(1);\n                  return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];\n                }\n              case \"ElementModifierStatement\":\n                return a([\"{{\", Re(H, X), \"}}\"]);\n              case \"MustacheStatement\":\n                return a([k(le), Re(H, X), M(le)]);\n              case \"SubExpression\":\n                return a([\"(\", ke(H, X), y, \")\"]);\n              case \"AttrNode\":\n                {\n                  let Ee = le.value.type === \"TextNode\";\n                  if (Ee && le.value.chars === \"\" && F(le.value) === _(le.value)) return le.name;\n                  let A = Ee ? c(le.value.chars, Ae).quote : le.value.type === \"ConcatStatement\" ? c(le.value.parts.filter(re => re.type === \"TextNode\").map(re => re.chars).join(\"\"), Ae).quote : \"\",\n                    G = X(\"value\");\n                  return [le.name, \"=\", A, le.name === \"class\" && A ? a(i(G)) : G, A];\n                }\n              case \"ConcatStatement\":\n                return H.map(X, \"parts\");\n              case \"Hash\":\n                return l(p, H.map(X, \"pairs\"));\n              case \"HashPair\":\n                return [le.key, \"=\", X(\"value\")];\n              case \"TextNode\":\n                {\n                  let Ee = le.chars.replace(/{{/g, \"\\\\{{\"),\n                    De = U(H);\n                  if (De) {\n                    if (De === \"class\") {\n                      let Ye = Ee.trim().split(/\\s+/).join(\" \"),\n                        Se = !1,\n                        Ie = !1;\n                      return D(H, [\"ConcatStatement\"]) && (T(H, [\"MustacheStatement\"]) && /^\\s/.test(Ee) && (Se = !0), P(H, [\"MustacheStatement\"]) && /\\s$/.test(Ee) && Ye !== \"\" && (Ie = !0)), [Se ? p : \"\", Ye, Ie ? p : \"\"];\n                    }\n                    return g(Ee);\n                  }\n                  let G = /^[\\t\\n\\f\\r ]*$/.test(Ee),\n                    re = !N(H),\n                    ye = !E(H);\n                  if (pe.htmlWhitespaceSensitivity !== \"ignore\") {\n                    let Ye = /^[\\t\\n\\f\\r ]*/,\n                      Se = /[\\t\\n\\f\\r ]*$/,\n                      Ie = ye && D(H, [\"Template\"]),\n                      Oe = re && D(H, [\"Template\"]);\n                    if (G) {\n                      if (Oe || Ie) return \"\";\n                      let ae = [p],\n                        nt = Z(Ee);\n                      return nt && (ae = ge(nt)), I(H) && (ae = ae.map(tt => t(tt))), ae;\n                    }\n                    let [Je] = Ee.match(Ye),\n                      [Te] = Ee.match(Se),\n                      je = [];\n                    if (Je) {\n                      je = [p];\n                      let ae = Z(Je);\n                      ae && (je = ge(ae)), Ee = Ee.replace(Ye, \"\");\n                    }\n                    let Me = [];\n                    if (Te) {\n                      if (!Ie) {\n                        Me = [p];\n                        let ae = Z(Te);\n                        ae && (Me = ge(ae)), I(H) && (Me = Me.map(nt => t(nt)));\n                      }\n                      Ee = Ee.replace(Se, \"\");\n                    }\n                    return [...je, s(Fe(Ee)), ...Me];\n                  }\n                  let Ce = Z(Ee),\n                    Be = se(Ee),\n                    ve = fe(Ee);\n                  if ((re || ye) && G && D(H, [\"Block\", \"ElementNode\", \"Template\"])) return \"\";\n                  G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, [\"BlockStatement\", \"ElementNode\"]) && (ve = Math.max(ve, 1)), T(H, [\"BlockStatement\", \"ElementNode\"]) && (Be = Math.max(Be, 1)));\n                  let ze = \"\",\n                    be = \"\";\n                  return ve === 0 && P(H, [\"MustacheStatement\"]) && (be = \" \"), Be === 0 && T(H, [\"MustacheStatement\"]) && (ze = \" \"), re && (Be = 0, ze = \"\"), ye && (ve = 0, be = \"\"), Ee = Ee.replace(/^[\\t\\n\\f\\r ]+/g, ze).replace(/[\\t\\n\\f\\r ]+$/, be), [...ge(Be), s(Fe(Ee)), ...ge(ve)];\n                }\n              case \"MustacheCommentStatement\":\n                {\n                  let Ee = F(le),\n                    De = _(le),\n                    A = pe.originalText.charAt(Ee + 2) === \"~\",\n                    G = pe.originalText.charAt(De - 3) === \"~\",\n                    re = le.value.includes(\"}}\") ? \"--\" : \"\";\n                  return [\"{{\", A ? \"~\" : \"\", \"!\", re, le.value, re, G ? \"~\" : \"\", \"}}\"];\n                }\n              case \"PathExpression\":\n                return le.original;\n              case \"BooleanLiteral\":\n                return String(le.value);\n              case \"CommentStatement\":\n                return [\"<!--\", le.value, \"-->\"];\n              case \"StringLiteral\":\n                {\n                  if (we(H)) {\n                    let Ee = pe.singleQuote ? '\"' : \"'\";\n                    return he(le.value, Ee);\n                  }\n                  return he(le.value, Ae);\n                }\n              case \"NumberLiteral\":\n                return String(le.value);\n              case \"UndefinedLiteral\":\n                return \"undefined\";\n              case \"NullLiteral\":\n                return \"null\";\n              default:\n                throw new Error(\"unknown glimmer type: \" + JSON.stringify(le.type));\n            }\n          }\n          function v(H, pe) {\n            return F(H) - F(pe);\n          }\n          function S(H, pe) {\n            let X = H.getValue(),\n              le = [\"attributes\", \"modifiers\", \"comments\"].filter(Ee => f(X[Ee])),\n              Ae = le.flatMap(Ee => X[Ee]).sort(v);\n            for (let Ee of le) H.each(De => {\n              let A = Ae.indexOf(De.getValue());\n              Ae.splice(A, 1, [p, pe()]);\n            }, Ee);\n            return f(X.blockParams) && Ae.push(p, oe(X)), [\"<\", X.tag, i(Ae), B(X)];\n          }\n          function b(H, pe, X) {\n            let Ae = H.getValue().children.every(Ee => C(Ee));\n            return pe.htmlWhitespaceSensitivity === \"ignore\" && Ae ? \"\" : H.map((Ee, De) => {\n              let A = X();\n              return De === 0 && pe.htmlWhitespaceSensitivity === \"ignore\" ? [y, A] : A;\n            }, \"children\");\n          }\n          function B(H) {\n            return m(H) ? u([y, \"/>\"], [\" />\", y]) : u([y, \">\"], \">\");\n          }\n          function k(H) {\n            let pe = H.escaped === !1 ? \"{{{\" : \"{{\",\n              X = H.strip && H.strip.open ? \"~\" : \"\";\n            return [pe, X];\n          }\n          function M(H) {\n            let pe = H.escaped === !1 ? \"}}}\" : \"}}\";\n            return [H.strip && H.strip.close ? \"~\" : \"\", pe];\n          }\n          function R(H) {\n            let pe = k(H),\n              X = H.openStrip.open ? \"~\" : \"\";\n            return [pe, X, \"#\"];\n          }\n          function q(H) {\n            let pe = M(H);\n            return [H.openStrip.close ? \"~\" : \"\", pe];\n          }\n          function J(H) {\n            let pe = k(H),\n              X = H.closeStrip.open ? \"~\" : \"\";\n            return [pe, X, \"/\"];\n          }\n          function L(H) {\n            let pe = M(H);\n            return [H.closeStrip.close ? \"~\" : \"\", pe];\n          }\n          function Q(H) {\n            let pe = k(H),\n              X = H.inverseStrip.open ? \"~\" : \"\";\n            return [pe, X];\n          }\n          function V(H) {\n            let pe = M(H);\n            return [H.inverseStrip.close ? \"~\" : \"\", pe];\n          }\n          function j(H, pe) {\n            let X = H.getValue(),\n              le = [],\n              Ae = Pe(H, pe);\n            return Ae && le.push(a(Ae)), f(X.program.blockParams) && le.push(oe(X.program)), a([R(X), Ne(H, pe), le.length > 0 ? i([p, l(p, le)]) : \"\", y, q(X)]);\n          }\n          function Y(H, pe) {\n            return [pe.htmlWhitespaceSensitivity === \"ignore\" ? n : \"\", Q(H), \"else\", V(H)];\n          }\n          function ie(H, pe, X) {\n            let le = H.getValue(),\n              Ae = H.getParentNode(1);\n            return a([Q(Ae), [\"else\", \" \", X], i([p, a(Pe(H, pe)), ...(f(le.program.blockParams) ? [p, oe(le.program)] : [])]), y, V(Ae)]);\n          }\n          function ee(H, pe, X) {\n            let le = H.getValue();\n            return X.htmlWhitespaceSensitivity === \"ignore\" ? [ce(le) ? y : n, J(le), pe(\"path\"), L(le)] : [J(le), pe(\"path\"), L(le)];\n          }\n          function ce(H) {\n            return $(H, [\"BlockStatement\"]) && H.program.body.every(pe => C(pe));\n          }\n          function W(H) {\n            return K(H) && H.inverse.body.length === 1 && $(H.inverse.body[0], [\"BlockStatement\"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];\n          }\n          function K(H) {\n            return $(H, [\"BlockStatement\"]) && H.inverse;\n          }\n          function de(H, pe, X) {\n            let le = H.getValue();\n            if (ce(le)) return \"\";\n            let Ae = pe(\"program\");\n            return X.htmlWhitespaceSensitivity === \"ignore\" ? i([n, Ae]) : i(Ae);\n          }\n          function ue(H, pe, X) {\n            let le = H.getValue(),\n              Ae = pe(\"inverse\"),\n              Ee = X.htmlWhitespaceSensitivity === \"ignore\" ? [n, Ae] : Ae;\n            return W(le) ? Ee : K(le) ? [Y(le, X), i(Ee)] : \"\";\n          }\n          function Fe(H) {\n            return h(l(p, z(H)));\n          }\n          function z(H) {\n            return H.split(/[\\t\\n\\f\\r ]+/);\n          }\n          function U(H) {\n            for (let pe = 0; pe < 2; pe++) {\n              let X = H.getParentNode(pe);\n              if (X && X.type === \"AttrNode\") return X.name.toLowerCase();\n            }\n          }\n          function Z(H) {\n            return H = typeof H == \"string\" ? H : \"\", H.split(`\n`).length - 1;\n          }\n          function se(H) {\n            H = typeof H == \"string\" ? H : \"\";\n            let pe = (H.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || \"\";\n            return Z(pe);\n          }\n          function fe(H) {\n            H = typeof H == \"string\" ? H : \"\";\n            let pe = (H.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || \"\";\n            return Z(pe);\n          }\n          function ge() {\n            let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n            return Array.from({\n              length: Math.min(H, o)\n            }).fill(n);\n          }\n          function he(H, pe) {\n            let {\n              quote: X,\n              regex: le\n            } = c(H, pe);\n            return [X, H.replace(le, `\\\\${X}`), X];\n          }\n          function we(H) {\n            let pe = 0,\n              X = H.getParentNode(pe);\n            for (; X && $(X, [\"SubExpression\"]);) pe++, X = H.getParentNode(pe);\n            return !!(X && $(H.getParentNode(pe + 1), [\"ConcatStatement\"]) && $(H.getParentNode(pe + 2), [\"AttrNode\"]));\n          }\n          function ke(H, pe) {\n            let X = Ne(H, pe),\n              le = Pe(H, pe);\n            return le ? i([X, p, a(le)]) : X;\n          }\n          function Re(H, pe) {\n            let X = Ne(H, pe),\n              le = Pe(H, pe);\n            return le ? [i([X, p, le]), y] : X;\n          }\n          function Ne(H, pe) {\n            return pe(\"path\");\n          }\n          function Pe(H, pe) {\n            let X = H.getValue(),\n              le = [];\n            if (X.params.length > 0) {\n              let Ae = H.map(pe, \"params\");\n              le.push(...Ae);\n            }\n            if (X.hash && X.hash.pairs.length > 0) {\n              let Ae = pe(\"hash\");\n              le.push(Ae);\n            }\n            return le.length === 0 ? \"\" : l(p, le);\n          }\n          function oe(H) {\n            return [\"as |\", H.blockParams.join(\" \"), \"|\"];\n          }\n          r.exports = {\n            print: d,\n            massageAstNode: w\n          };\n        }\n      }),\n      Qd = te({\n        \"src/language-handlebars/parsers.js\"() {\n          ne();\n        }\n      }),\n      Zd = te({\n        \"node_modules/linguist-languages/data/Handlebars.json\"(e, r) {\n          r.exports = {\n            name: \"Handlebars\",\n            type: \"markup\",\n            color: \"#f7931e\",\n            aliases: [\"hbs\", \"htmlbars\"],\n            extensions: [\".handlebars\", \".hbs\"],\n            tmScope: \"text.html.handlebars\",\n            aceMode: \"handlebars\",\n            languageId: 155\n          };\n        }\n      }),\n      eg = te({\n        \"src/language-handlebars/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = _t(),\n            s = Yd(),\n            a = Qd(),\n            n = [t(Zd(), () => ({\n              since: \"2.3.0\",\n              parsers: [\"glimmer\"],\n              vscodeLanguageIds: [\"handlebars\"]\n            }))],\n            u = {\n              glimmer: s\n            };\n          r.exports = {\n            languages: n,\n            printers: u,\n            parsers: a\n          };\n        }\n      }),\n      tg = te({\n        \"src/language-graphql/pragma.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(a) {\n            return /^\\s*#[^\\S\\n]*@(?:format|prettier)\\s*(?:\\n|$)/.test(a);\n          }\n          function s(a) {\n            return `# @format\n\n` + a;\n          }\n          r.exports = {\n            hasPragma: t,\n            insertPragma: s\n          };\n        }\n      }),\n      rg = te({\n        \"src/language-graphql/loc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(a) {\n            return typeof a.start == \"number\" ? a.start : a.loc && a.loc.start;\n          }\n          function s(a) {\n            return typeof a.end == \"number\" ? a.end : a.loc && a.loc.end;\n          }\n          r.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      ng = te({\n        \"src/language-graphql/printer-graphql.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                join: t,\n                hardline: s,\n                line: a,\n                softline: n,\n                group: u,\n                indent: i,\n                ifBreak: l\n              }\n            } = qe(),\n            {\n              isNextLineEmpty: p,\n              isNonEmptyArray: y\n            } = Ue(),\n            {\n              insertPragma: h\n            } = tg(),\n            {\n              locStart: g,\n              locEnd: c\n            } = rg();\n          function f(P, $, D) {\n            let T = P.getValue();\n            if (!T) return \"\";\n            if (typeof T == \"string\") return T;\n            switch (T.kind) {\n              case \"Document\":\n                {\n                  let m = [];\n                  return P.each((C, o, d) => {\n                    m.push(D()), o !== d.length - 1 && (m.push(s), p($.originalText, C.getValue(), c) && m.push(s));\n                  }, \"definitions\"), [...m, s];\n                }\n              case \"OperationDefinition\":\n                {\n                  let m = $.originalText[g(T)] !== \"{\",\n                    C = Boolean(T.name);\n                  return [m ? T.operation : \"\", m && C ? [\" \", D(\"name\")] : \"\", m && !C && y(T.variableDefinitions) ? \" \" : \"\", y(T.variableDefinitions) ? u([\"(\", i([n, t([l(\"\", \", \"), n], P.map(D, \"variableDefinitions\"))]), n, \")\"]) : \"\", F(P, D, T), T.selectionSet ? !m && !C ? \"\" : \" \" : \"\", D(\"selectionSet\")];\n                }\n              case \"FragmentDefinition\":\n                return [\"fragment \", D(\"name\"), y(T.variableDefinitions) ? u([\"(\", i([n, t([l(\"\", \", \"), n], P.map(D, \"variableDefinitions\"))]), n, \")\"]) : \"\", \" on \", D(\"typeCondition\"), F(P, D, T), \" \", D(\"selectionSet\")];\n              case \"SelectionSet\":\n                return [\"{\", i([s, t(s, _(P, $, D, \"selections\"))]), s, \"}\"];\n              case \"Field\":\n                return u([T.alias ? [D(\"alias\"), \": \"] : \"\", D(\"name\"), T.arguments.length > 0 ? u([\"(\", i([n, t([l(\"\", \", \"), n], _(P, $, D, \"arguments\"))]), n, \")\"]) : \"\", F(P, D, T), T.selectionSet ? \" \" : \"\", D(\"selectionSet\")]);\n              case \"Name\":\n                return T.value;\n              case \"StringValue\":\n                {\n                  if (T.block) {\n                    let m = T.value.replace(/\"\"\"/g, \"\\\\$&\").split(`\n`);\n                    return m.length === 1 && (m[0] = m[0].trim()), m.every(C => C === \"\") && (m.length = 0), t(s, ['\"\"\"', ...m, '\"\"\"']);\n                  }\n                  return ['\"', T.value.replace(/[\"\\\\]/g, \"\\\\$&\").replace(/\\n/g, \"\\\\n\"), '\"'];\n                }\n              case \"IntValue\":\n              case \"FloatValue\":\n              case \"EnumValue\":\n                return T.value;\n              case \"BooleanValue\":\n                return T.value ? \"true\" : \"false\";\n              case \"NullValue\":\n                return \"null\";\n              case \"Variable\":\n                return [\"$\", D(\"name\")];\n              case \"ListValue\":\n                return u([\"[\", i([n, t([l(\"\", \", \"), n], P.map(D, \"values\"))]), n, \"]\"]);\n              case \"ObjectValue\":\n                return u([\"{\", $.bracketSpacing && T.fields.length > 0 ? \" \" : \"\", i([n, t([l(\"\", \", \"), n], P.map(D, \"fields\"))]), n, l(\"\", $.bracketSpacing && T.fields.length > 0 ? \" \" : \"\"), \"}\"]);\n              case \"ObjectField\":\n              case \"Argument\":\n                return [D(\"name\"), \": \", D(\"value\")];\n              case \"Directive\":\n                return [\"@\", D(\"name\"), T.arguments.length > 0 ? u([\"(\", i([n, t([l(\"\", \", \"), n], _(P, $, D, \"arguments\"))]), n, \")\"]) : \"\"];\n              case \"NamedType\":\n                return D(\"name\");\n              case \"VariableDefinition\":\n                return [D(\"variable\"), \": \", D(\"type\"), T.defaultValue ? [\" = \", D(\"defaultValue\")] : \"\", F(P, D, T)];\n              case \"ObjectTypeExtension\":\n              case \"ObjectTypeDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", T.kind === \"ObjectTypeExtension\" ? \"extend \" : \"\", \"type \", D(\"name\"), T.interfaces.length > 0 ? [\" implements \", ...N(P, $, D)] : \"\", F(P, D, T), T.fields.length > 0 ? [\" {\", i([s, t(s, _(P, $, D, \"fields\"))]), s, \"}\"] : \"\"];\n              case \"FieldDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", D(\"name\"), T.arguments.length > 0 ? u([\"(\", i([n, t([l(\"\", \", \"), n], _(P, $, D, \"arguments\"))]), n, \")\"]) : \"\", \": \", D(\"type\"), F(P, D, T)];\n              case \"DirectiveDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", \"directive \", \"@\", D(\"name\"), T.arguments.length > 0 ? u([\"(\", i([n, t([l(\"\", \", \"), n], _(P, $, D, \"arguments\"))]), n, \")\"]) : \"\", T.repeatable ? \" repeatable\" : \"\", \" on \", t(\" | \", P.map(D, \"locations\"))];\n              case \"EnumTypeExtension\":\n              case \"EnumTypeDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", T.kind === \"EnumTypeExtension\" ? \"extend \" : \"\", \"enum \", D(\"name\"), F(P, D, T), T.values.length > 0 ? [\" {\", i([s, t(s, _(P, $, D, \"values\"))]), s, \"}\"] : \"\"];\n              case \"EnumValueDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", D(\"name\"), F(P, D, T)];\n              case \"InputValueDefinition\":\n                return [D(\"description\"), T.description ? T.description.block ? s : a : \"\", D(\"name\"), \": \", D(\"type\"), T.defaultValue ? [\" = \", D(\"defaultValue\")] : \"\", F(P, D, T)];\n              case \"InputObjectTypeExtension\":\n              case \"InputObjectTypeDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", T.kind === \"InputObjectTypeExtension\" ? \"extend \" : \"\", \"input \", D(\"name\"), F(P, D, T), T.fields.length > 0 ? [\" {\", i([s, t(s, _(P, $, D, \"fields\"))]), s, \"}\"] : \"\"];\n              case \"SchemaExtension\":\n                return [\"extend schema\", F(P, D, T), ...(T.operationTypes.length > 0 ? [\" {\", i([s, t(s, _(P, $, D, \"operationTypes\"))]), s, \"}\"] : [])];\n              case \"SchemaDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", \"schema\", F(P, D, T), \" {\", T.operationTypes.length > 0 ? i([s, t(s, _(P, $, D, \"operationTypes\"))]) : \"\", s, \"}\"];\n              case \"OperationTypeDefinition\":\n                return [D(\"operation\"), \": \", D(\"type\")];\n              case \"InterfaceTypeExtension\":\n              case \"InterfaceTypeDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", T.kind === \"InterfaceTypeExtension\" ? \"extend \" : \"\", \"interface \", D(\"name\"), T.interfaces.length > 0 ? [\" implements \", ...N(P, $, D)] : \"\", F(P, D, T), T.fields.length > 0 ? [\" {\", i([s, t(s, _(P, $, D, \"fields\"))]), s, \"}\"] : \"\"];\n              case \"FragmentSpread\":\n                return [\"...\", D(\"name\"), F(P, D, T)];\n              case \"InlineFragment\":\n                return [\"...\", T.typeCondition ? [\" on \", D(\"typeCondition\")] : \"\", F(P, D, T), \" \", D(\"selectionSet\")];\n              case \"UnionTypeExtension\":\n              case \"UnionTypeDefinition\":\n                return u([D(\"description\"), T.description ? s : \"\", u([T.kind === \"UnionTypeExtension\" ? \"extend \" : \"\", \"union \", D(\"name\"), F(P, D, T), T.types.length > 0 ? [\" =\", l(\"\", \" \"), i([l([a, \"  \"]), t([a, \"| \"], P.map(D, \"types\"))])] : \"\"])]);\n              case \"ScalarTypeExtension\":\n              case \"ScalarTypeDefinition\":\n                return [D(\"description\"), T.description ? s : \"\", T.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\", \"scalar \", D(\"name\"), F(P, D, T)];\n              case \"NonNullType\":\n                return [D(\"type\"), \"!\"];\n              case \"ListType\":\n                return [\"[\", D(\"type\"), \"]\"];\n              default:\n                throw new Error(\"unknown graphql type: \" + JSON.stringify(T.kind));\n            }\n          }\n          function F(P, $, D) {\n            if (D.directives.length === 0) return \"\";\n            let T = t(a, P.map($, \"directives\"));\n            return D.kind === \"FragmentDefinition\" || D.kind === \"OperationDefinition\" ? u([a, T]) : [\" \", u(i([n, T]))];\n          }\n          function _(P, $, D, T) {\n            return P.map((m, C, o) => {\n              let d = D();\n              return C < o.length - 1 && p($.originalText, m.getValue(), c) ? [d, s] : d;\n            }, T);\n          }\n          function w(P) {\n            return P.kind && P.kind !== \"Comment\";\n          }\n          function E(P) {\n            let $ = P.getValue();\n            if ($.kind === \"Comment\") return \"#\" + $.value.trimEnd();\n            throw new Error(\"Not a comment: \" + JSON.stringify($));\n          }\n          function N(P, $, D) {\n            let T = P.getNode(),\n              m = [],\n              {\n                interfaces: C\n              } = T,\n              o = P.map(d => D(d), \"interfaces\");\n            for (let d = 0; d < C.length; d++) {\n              let v = C[d];\n              m.push(o[d]);\n              let S = C[d + 1];\n              if (S) {\n                let b = $.originalText.slice(v.loc.end, S.loc.start),\n                  B = b.includes(\"#\"),\n                  k = b.replace(/#.*/g, \"\").trim();\n                m.push(k === \",\" ? \",\" : \" &\", B ? a : \" \");\n              }\n            }\n            return m;\n          }\n          function x(P, $) {\n            P.kind === \"StringValue\" && P.block && !P.value.includes(`\n`) && ($.value = $.value.trim());\n          }\n          x.ignoredProperties = new Set([\"loc\", \"comments\"]);\n          function I(P) {\n            var $;\n            let D = P.getValue();\n            return D == null || ($ = D.comments) === null || $ === void 0 ? void 0 : $.some(T => T.value.trim() === \"prettier-ignore\");\n          }\n          r.exports = {\n            print: f,\n            massageAstNode: x,\n            hasPrettierIgnore: I,\n            insertPragma: h,\n            printComment: E,\n            canAttachComment: w\n          };\n        }\n      }),\n      ug = te({\n        \"src/language-graphql/options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Mt();\n          r.exports = {\n            bracketSpacing: t.bracketSpacing\n          };\n        }\n      }),\n      sg = te({\n        \"src/language-graphql/parsers.js\"() {\n          ne();\n        }\n      }),\n      ig = te({\n        \"node_modules/linguist-languages/data/GraphQL.json\"(e, r) {\n          r.exports = {\n            name: \"GraphQL\",\n            type: \"data\",\n            color: \"#e10098\",\n            extensions: [\".graphql\", \".gql\", \".graphqls\"],\n            tmScope: \"source.graphql\",\n            aceMode: \"text\",\n            languageId: 139\n          };\n        }\n      }),\n      ag = te({\n        \"src/language-graphql/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = _t(),\n            s = ng(),\n            a = ug(),\n            n = sg(),\n            u = [t(ig(), () => ({\n              since: \"1.5.0\",\n              parsers: [\"graphql\"],\n              vscodeLanguageIds: [\"graphql\"]\n            }))],\n            i = {\n              graphql: s\n            };\n          r.exports = {\n            languages: u,\n            options: a,\n            printers: i,\n            parsers: n\n          };\n        }\n      }),\n      Po = te({\n        \"node_modules/collapse-white-space/index.js\"(e, r) {\n          \"use strict\";\n\n          ne(), r.exports = t;\n          function t(s) {\n            return String(s).replace(/\\s+/g, \" \");\n          }\n        }\n      }),\n      Io = te({\n        \"src/language-markdown/loc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(a) {\n            return a.position.start.offset;\n          }\n          function s(a) {\n            return a.position.end.offset;\n          }\n          r.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      og = te({\n        \"src/language-markdown/constants.evaluate.js\"(e, r) {\n          r.exports = {\n            cjkPattern: \"(?:[\\\\u02ea-\\\\u02eb\\\\u1100-\\\\u11ff\\\\u2e80-\\\\u2e99\\\\u2e9b-\\\\u2ef3\\\\u2f00-\\\\u2fd5\\\\u2ff0-\\\\u303f\\\\u3041-\\\\u3096\\\\u3099-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312f\\\\u3131-\\\\u318e\\\\u3190-\\\\u3191\\\\u3196-\\\\u31ba\\\\u31c0-\\\\u31e3\\\\u31f0-\\\\u321e\\\\u322a-\\\\u3247\\\\u3260-\\\\u327e\\\\u328a-\\\\u32b0\\\\u32c0-\\\\u32cb\\\\u32d0-\\\\u3370\\\\u337b-\\\\u337f\\\\u33e0-\\\\u33fe\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fef\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufe10-\\\\ufe1f\\\\ufe30-\\\\ufe6f\\\\uff00-\\\\uffef]|[\\\\ud840-\\\\ud868\\\\ud86a-\\\\ud86c\\\\ud86f-\\\\ud872\\\\ud874-\\\\ud879][\\\\udc00-\\\\udfff]|\\\\ud82c[\\\\udc00-\\\\udd1e\\\\udd50-\\\\udd52\\\\udd64-\\\\udd67]|\\\\ud83c[\\\\ude00\\\\ude50-\\\\ude51]|\\\\ud869[\\\\udc00-\\\\uded6\\\\udf00-\\\\udfff]|\\\\ud86d[\\\\udc00-\\\\udf34\\\\udf40-\\\\udfff]|\\\\ud86e[\\\\udc00-\\\\udc1d\\\\udc20-\\\\udfff]|\\\\ud873[\\\\udc00-\\\\udea1\\\\udeb0-\\\\udfff]|\\\\ud87a[\\\\udc00-\\\\udfe0]|\\\\ud87e[\\\\udc00-\\\\ude1d])(?:[\\\\ufe00-\\\\ufe0f]|\\\\udb40[\\\\udd00-\\\\uddef])?\",\n            kPattern: \"[\\\\u1100-\\\\u11ff\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3013-\\\\u301f\\\\u302e-\\\\u3030\\\\u3037\\\\u30fb\\\\u3131-\\\\u318e\\\\u3200-\\\\u321e\\\\u3260-\\\\u327e\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\ufe45-\\\\ufe46\\\\uff61-\\\\uff65\\\\uffa0-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc]\",\n            punctuationPattern: \"[\\\\u0021-\\\\u002f\\\\u003a-\\\\u0040\\\\u005b-\\\\u0060\\\\u007b-\\\\u007e\\\\u00a1\\\\u00a7\\\\u00ab\\\\u00b6-\\\\u00b7\\\\u00bb\\\\u00bf\\\\u037e\\\\u0387\\\\u055a-\\\\u055f\\\\u0589-\\\\u058a\\\\u05be\\\\u05c0\\\\u05c3\\\\u05c6\\\\u05f3-\\\\u05f4\\\\u0609-\\\\u060a\\\\u060c-\\\\u060d\\\\u061b\\\\u061e-\\\\u061f\\\\u066a-\\\\u066d\\\\u06d4\\\\u0700-\\\\u070d\\\\u07f7-\\\\u07f9\\\\u0830-\\\\u083e\\\\u085e\\\\u0964-\\\\u0965\\\\u0970\\\\u09fd\\\\u0a76\\\\u0af0\\\\u0c77\\\\u0c84\\\\u0df4\\\\u0e4f\\\\u0e5a-\\\\u0e5b\\\\u0f04-\\\\u0f12\\\\u0f14\\\\u0f3a-\\\\u0f3d\\\\u0f85\\\\u0fd0-\\\\u0fd4\\\\u0fd9-\\\\u0fda\\\\u104a-\\\\u104f\\\\u10fb\\\\u1360-\\\\u1368\\\\u1400\\\\u166e\\\\u169b-\\\\u169c\\\\u16eb-\\\\u16ed\\\\u1735-\\\\u1736\\\\u17d4-\\\\u17d6\\\\u17d8-\\\\u17da\\\\u1800-\\\\u180a\\\\u1944-\\\\u1945\\\\u1a1e-\\\\u1a1f\\\\u1aa0-\\\\u1aa6\\\\u1aa8-\\\\u1aad\\\\u1b5a-\\\\u1b60\\\\u1bfc-\\\\u1bff\\\\u1c3b-\\\\u1c3f\\\\u1c7e-\\\\u1c7f\\\\u1cc0-\\\\u1cc7\\\\u1cd3\\\\u2010-\\\\u2027\\\\u2030-\\\\u2043\\\\u2045-\\\\u2051\\\\u2053-\\\\u205e\\\\u207d-\\\\u207e\\\\u208d-\\\\u208e\\\\u2308-\\\\u230b\\\\u2329-\\\\u232a\\\\u2768-\\\\u2775\\\\u27c5-\\\\u27c6\\\\u27e6-\\\\u27ef\\\\u2983-\\\\u2998\\\\u29d8-\\\\u29db\\\\u29fc-\\\\u29fd\\\\u2cf9-\\\\u2cfc\\\\u2cfe-\\\\u2cff\\\\u2d70\\\\u2e00-\\\\u2e2e\\\\u2e30-\\\\u2e4f\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3014-\\\\u301f\\\\u3030\\\\u303d\\\\u30a0\\\\u30fb\\\\ua4fe-\\\\ua4ff\\\\ua60d-\\\\ua60f\\\\ua673\\\\ua67e\\\\ua6f2-\\\\ua6f7\\\\ua874-\\\\ua877\\\\ua8ce-\\\\ua8cf\\\\ua8f8-\\\\ua8fa\\\\ua8fc\\\\ua92e-\\\\ua92f\\\\ua95f\\\\ua9c1-\\\\ua9cd\\\\ua9de-\\\\ua9df\\\\uaa5c-\\\\uaa5f\\\\uaade-\\\\uaadf\\\\uaaf0-\\\\uaaf1\\\\uabeb\\\\ufd3e-\\\\ufd3f\\\\ufe10-\\\\ufe19\\\\ufe30-\\\\ufe52\\\\ufe54-\\\\ufe61\\\\ufe63\\\\ufe68\\\\ufe6a-\\\\ufe6b\\\\uff01-\\\\uff03\\\\uff05-\\\\uff0a\\\\uff0c-\\\\uff0f\\\\uff1a-\\\\uff1b\\\\uff1f-\\\\uff20\\\\uff3b-\\\\uff3d\\\\uff3f\\\\uff5b\\\\uff5d\\\\uff5f-\\\\uff65]|\\\\ud800[\\\\udd00-\\\\udd02\\\\udf9f\\\\udfd0]|\\\\ud801[\\\\udd6f]|\\\\ud802[\\\\udc57\\\\udd1f\\\\udd3f\\\\ude50-\\\\ude58\\\\ude7f\\\\udef0-\\\\udef6\\\\udf39-\\\\udf3f\\\\udf99-\\\\udf9c]|\\\\ud803[\\\\udf55-\\\\udf59]|\\\\ud804[\\\\udc47-\\\\udc4d\\\\udcbb-\\\\udcbc\\\\udcbe-\\\\udcc1\\\\udd40-\\\\udd43\\\\udd74-\\\\udd75\\\\uddc5-\\\\uddc8\\\\uddcd\\\\udddb\\\\udddd-\\\\udddf\\\\ude38-\\\\ude3d\\\\udea9]|\\\\ud805[\\\\udc4b-\\\\udc4f\\\\udc5b\\\\udc5d\\\\udcc6\\\\uddc1-\\\\uddd7\\\\ude41-\\\\ude43\\\\ude60-\\\\ude6c\\\\udf3c-\\\\udf3e]|\\\\ud806[\\\\udc3b\\\\udde2\\\\ude3f-\\\\ude46\\\\ude9a-\\\\ude9c\\\\ude9e-\\\\udea2]|\\\\ud807[\\\\udc41-\\\\udc45\\\\udc70-\\\\udc71\\\\udef7-\\\\udef8\\\\udfff]|\\\\ud809[\\\\udc70-\\\\udc74]|\\\\ud81a[\\\\ude6e-\\\\ude6f\\\\udef5\\\\udf37-\\\\udf3b\\\\udf44]|\\\\ud81b[\\\\ude97-\\\\ude9a\\\\udfe2]|\\\\ud82f[\\\\udc9f]|\\\\ud836[\\\\ude87-\\\\ude8b]|\\\\ud83a[\\\\udd5e-\\\\udd5f]\"\n          };\n        }\n      }),\n      iu = te({\n        \"src/language-markdown/utils.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              getLast: t\n            } = Ue(),\n            {\n              locStart: s,\n              locEnd: a\n            } = Io(),\n            {\n              cjkPattern: n,\n              kPattern: u,\n              punctuationPattern: i\n            } = og(),\n            l = [\"liquidNode\", \"inlineCode\", \"emphasis\", \"esComment\", \"strong\", \"delete\", \"wikiLink\", \"link\", \"linkReference\", \"image\", \"imageReference\", \"footnote\", \"footnoteReference\", \"sentence\", \"whitespace\", \"word\", \"break\", \"inlineMath\"],\n            p = [...l, \"tableCell\", \"paragraph\", \"heading\"],\n            y = new RegExp(u),\n            h = new RegExp(i);\n          function g(E, N) {\n            let x = \"non-cjk\",\n              I = \"cj-letter\",\n              P = \"k-letter\",\n              $ = \"cjk-punctuation\",\n              D = [],\n              T = (N.proseWrap === \"preserve\" ? E : E.replace(new RegExp(`(${n})\n(${n})`, \"g\"), \"$1$2\")).split(/([\\t\\n ]+)/);\n            for (let [C, o] of T.entries()) {\n              if (C % 2 === 1) {\n                D.push({\n                  type: \"whitespace\",\n                  value: /\\n/.test(o) ? `\n` : \" \"\n                });\n                continue;\n              }\n              if ((C === 0 || C === T.length - 1) && o === \"\") continue;\n              let d = o.split(new RegExp(`(${n})`));\n              for (let [v, S] of d.entries()) if (!((v === 0 || v === d.length - 1) && S === \"\")) {\n                if (v % 2 === 0) {\n                  S !== \"\" && m({\n                    type: \"word\",\n                    value: S,\n                    kind: x,\n                    hasLeadingPunctuation: h.test(S[0]),\n                    hasTrailingPunctuation: h.test(t(S))\n                  });\n                  continue;\n                }\n                m(h.test(S) ? {\n                  type: \"word\",\n                  value: S,\n                  kind: $,\n                  hasLeadingPunctuation: !0,\n                  hasTrailingPunctuation: !0\n                } : {\n                  type: \"word\",\n                  value: S,\n                  kind: y.test(S) ? P : I,\n                  hasLeadingPunctuation: !1,\n                  hasTrailingPunctuation: !1\n                });\n              }\n            }\n            return D;\n            function m(C) {\n              let o = t(D);\n              o && o.type === \"word\" && (o.kind === x && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x && !C.hasLeadingPunctuation ? D.push({\n                type: \"whitespace\",\n                value: \" \"\n              }) : !d(x, $) && ![o.value, C.value].some(v => /\\u3000/.test(v)) && D.push({\n                type: \"whitespace\",\n                value: \"\"\n              })), D.push(C);\n              function d(v, S) {\n                return o.kind === v && C.kind === S || o.kind === S && C.kind === v;\n              }\n            }\n          }\n          function c(E, N) {\n            let [, x, I, P] = N.slice(E.position.start.offset, E.position.end.offset).match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);\n            return {\n              numberText: x,\n              marker: I,\n              leadingSpaces: P\n            };\n          }\n          function f(E, N) {\n            if (!E.ordered || E.children.length < 2) return !1;\n            let x = Number(c(E.children[0], N.originalText).numberText),\n              I = Number(c(E.children[1], N.originalText).numberText);\n            if (x === 0 && E.children.length > 2) {\n              let P = Number(c(E.children[2], N.originalText).numberText);\n              return I === 1 && P === 1;\n            }\n            return I === 1;\n          }\n          function F(E, N) {\n            let {\n              value: x\n            } = E;\n            return E.position.end.offset === N.length && x.endsWith(`\n`) && N.endsWith(`\n`) ? x.slice(0, -1) : x;\n          }\n          function _(E, N) {\n            return function x(I, P, $) {\n              let D = Object.assign({}, N(I, P, $));\n              return D.children && (D.children = D.children.map((T, m) => x(T, m, [D, ...$]))), D;\n            }(E, null, []);\n          }\n          function w(E) {\n            if ((E == null ? void 0 : E.type) !== \"link\" || E.children.length !== 1) return !1;\n            let [N] = E.children;\n            return s(E) === s(N) && a(E) === a(N);\n          }\n          r.exports = {\n            mapAst: _,\n            splitText: g,\n            punctuationPattern: i,\n            getFencedCodeBlockValue: F,\n            getOrderedListItemInfo: c,\n            hasGitDiffFriendlyOrderedList: f,\n            INLINE_NODE_TYPES: l,\n            INLINE_NODE_WRAPPER_TYPES: p,\n            isAutolink: w\n          };\n        }\n      }),\n      lg = te({\n        \"src/language-markdown/embed.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              inferParserByLanguage: t,\n              getMaxContinuousCount: s\n            } = Ue(),\n            {\n              builders: {\n                hardline: a,\n                markAsRoot: n\n              },\n              utils: {\n                replaceEndOfLine: u\n              }\n            } = qe(),\n            i = su(),\n            {\n              getFencedCodeBlockValue: l\n            } = iu();\n          function p(y, h, g, c) {\n            let f = y.getValue();\n            if (f.type === \"code\" && f.lang !== null) {\n              let F = t(f.lang, c);\n              if (F) {\n                let _ = c.__inJsTemplate ? \"~\" : \"`\",\n                  w = _.repeat(Math.max(3, s(f.value, _) + 1)),\n                  E = {\n                    parser: F\n                  };\n                f.lang === \"tsx\" && (E.filepath = \"dummy.tsx\");\n                let N = g(l(f, c.originalText), E, {\n                  stripTrailingHardline: !0\n                });\n                return n([w, f.lang, f.meta ? \" \" + f.meta : \"\", a, u(N), a, w]);\n              }\n            }\n            switch (f.type) {\n              case \"front-matter\":\n                return i(f, g);\n              case \"importExport\":\n                return [g(f.value, {\n                  parser: \"babel\"\n                }, {\n                  stripTrailingHardline: !0\n                }), a];\n              case \"jsx\":\n                return g(`<$>${f.value}</$>`, {\n                  parser: \"__js_expression\",\n                  rootMarker: \"mdx\"\n                }, {\n                  stripTrailingHardline: !0\n                });\n            }\n            return null;\n          }\n          r.exports = p;\n        }\n      }),\n      ko = te({\n        \"src/language-markdown/pragma.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = _o(),\n            s = [\"format\", \"prettier\"];\n          function a(n) {\n            let u = `@(${s.join(\"|\")})`,\n              i = new RegExp([`<!--\\\\s*${u}\\\\s*-->`, `{\\\\s*\\\\/\\\\*\\\\s*${u}\\\\s*\\\\*\\\\/\\\\s*}`, `<!--.*\\r?\n[\\\\s\\\\S]*(^|\n)[^\\\\S\n]*${u}[^\\\\S\n]*($|\n)[\\\\s\\\\S]*\n.*-->`].join(\"|\"), \"m\"),\n              l = n.match(i);\n            return (l == null ? void 0 : l.index) === 0;\n          }\n          r.exports = {\n            startWithPragma: a,\n            hasPragma: n => a(t(n).content.trimStart()),\n            insertPragma: n => {\n              let u = t(n),\n                i = `<!-- @${s[0]} -->`;\n              return u.frontMatter ? `${u.frontMatter.raw}\n\n${i}\n\n${u.content}` : `${i}\n\n${u.content}`;\n            }\n          };\n        }\n      }),\n      cg = te({\n        \"src/language-markdown/print-preprocess.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = lt(),\n            {\n              getOrderedListItemInfo: s,\n              mapAst: a,\n              splitText: n\n            } = iu(),\n            u = /^.$/su;\n          function i(w, E) {\n            return w = y(w, E), w = c(w), w = p(w, E), w = F(w, E), w = _(w, E), w = f(w, E), w = l(w), w = h(w), w;\n          }\n          function l(w) {\n            return a(w, E => E.type !== \"import\" && E.type !== \"export\" ? E : Object.assign(Object.assign({}, E), {}, {\n              type: \"importExport\"\n            }));\n          }\n          function p(w, E) {\n            return a(w, N => N.type !== \"inlineCode\" || E.proseWrap === \"preserve\" ? N : Object.assign(Object.assign({}, N), {}, {\n              value: N.value.replace(/\\s+/g, \" \")\n            }));\n          }\n          function y(w, E) {\n            return a(w, N => N.type !== \"text\" || N.value === \"*\" || N.value === \"_\" || !u.test(N.value) || N.position.end.offset - N.position.start.offset === N.value.length ? N : Object.assign(Object.assign({}, N), {}, {\n              value: E.originalText.slice(N.position.start.offset, N.position.end.offset)\n            }));\n          }\n          function h(w) {\n            return g(w, (E, N) => E.type === \"importExport\" && N.type === \"importExport\", (E, N) => ({\n              type: \"importExport\",\n              value: E.value + `\n\n` + N.value,\n              position: {\n                start: E.position.start,\n                end: N.position.end\n              }\n            }));\n          }\n          function g(w, E, N) {\n            return a(w, x => {\n              if (!x.children) return x;\n              let I = x.children.reduce((P, $) => {\n                let D = t(P);\n                return D && E(D, $) ? P.splice(-1, 1, N(D, $)) : P.push($), P;\n              }, []);\n              return Object.assign(Object.assign({}, x), {}, {\n                children: I\n              });\n            });\n          }\n          function c(w) {\n            return g(w, (E, N) => E.type === \"text\" && N.type === \"text\", (E, N) => ({\n              type: \"text\",\n              value: E.value + N.value,\n              position: {\n                start: E.position.start,\n                end: N.position.end\n              }\n            }));\n          }\n          function f(w, E) {\n            return a(w, (N, x, I) => {\n              let [P] = I;\n              if (N.type !== \"text\") return N;\n              let {\n                value: $\n              } = N;\n              return P.type === \"paragraph\" && (x === 0 && ($ = $.trimStart()), x === P.children.length - 1 && ($ = $.trimEnd())), {\n                type: \"sentence\",\n                position: N.position,\n                children: n($, E)\n              };\n            });\n          }\n          function F(w, E) {\n            return a(w, (N, x, I) => {\n              if (N.type === \"code\") {\n                let P = /^\\n?(?: {4,}|\\t)/.test(E.originalText.slice(N.position.start.offset, N.position.end.offset));\n                if (N.isIndented = P, P) for (let $ = 0; $ < I.length; $++) {\n                  let D = I[$];\n                  if (D.hasIndentedCodeblock) break;\n                  D.type === \"list\" && (D.hasIndentedCodeblock = !0);\n                }\n              }\n              return N;\n            });\n          }\n          function _(w, E) {\n            return a(w, (I, P, $) => {\n              if (I.type === \"list\" && I.children.length > 0) {\n                for (let D = 0; D < $.length; D++) {\n                  let T = $[D];\n                  if (T.type === \"list\" && !T.isAligned) return I.isAligned = !1, I;\n                }\n                I.isAligned = x(I);\n              }\n              return I;\n            });\n            function N(I) {\n              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;\n            }\n            function x(I) {\n              if (!I.ordered) return !0;\n              let [P, $] = I.children;\n              if (s(P, E.originalText).leadingSpaces.length > 1) return !0;\n              let T = N(P);\n              if (T === -1) return !1;\n              if (I.children.length === 1) return T % E.tabWidth === 0;\n              let m = N($);\n              return T !== m ? !1 : T % E.tabWidth === 0 ? !0 : s($, E.originalText).leadingSpaces.length > 1;\n            }\n          }\n          r.exports = i;\n        }\n      }),\n      pg = te({\n        \"src/language-markdown/clean.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Po(),\n            {\n              isFrontMatterNode: s\n            } = Ue(),\n            {\n              startWithPragma: a\n            } = ko(),\n            n = new Set([\"position\", \"raw\"]);\n          function u(i, l, p) {\n            if ((i.type === \"front-matter\" || i.type === \"code\" || i.type === \"yaml\" || i.type === \"import\" || i.type === \"export\" || i.type === \"jsx\") && delete l.value, i.type === \"list\" && delete l.isAligned, (i.type === \"list\" || i.type === \"listItem\") && (delete l.spread, delete l.loose), i.type === \"text\" || (i.type === \"inlineCode\" && (l.value = i.value.replace(/[\\t\\n ]+/g, \" \")), i.type === \"wikiLink\" && (l.value = i.value.trim().replace(/[\\t\\n]+/g, \" \")), (i.type === \"definition\" || i.type === \"linkReference\" || i.type === \"imageReference\") && (l.label = t(i.label)), (i.type === \"definition\" || i.type === \"link\" || i.type === \"image\") && i.title && (l.title = i.title.replace(/\\\\([\"')])/g, \"$1\")), p && p.type === \"root\" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === \"html\" && a(i.value))) return null;\n          }\n          u.ignoredProperties = n, r.exports = u;\n        }\n      }),\n      fg = te({\n        \"src/language-markdown/printer-markdown.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Po(),\n            {\n              getLast: s,\n              getMinNotPresentContinuousCount: a,\n              getMaxContinuousCount: n,\n              getStringWidth: u,\n              isNonEmptyArray: i\n            } = Ue(),\n            {\n              builders: {\n                breakParent: l,\n                join: p,\n                line: y,\n                literalline: h,\n                markAsRoot: g,\n                hardline: c,\n                softline: f,\n                ifBreak: F,\n                fill: _,\n                align: w,\n                indent: E,\n                group: N,\n                hardlineWithoutBreakParent: x\n              },\n              utils: {\n                normalizeDoc: I,\n                replaceTextEndOfLine: P\n              },\n              printer: {\n                printDocToString: $\n              }\n            } = qe(),\n            D = lg(),\n            {\n              insertPragma: T\n            } = ko(),\n            {\n              locStart: m,\n              locEnd: C\n            } = Io(),\n            o = cg(),\n            d = pg(),\n            {\n              getFencedCodeBlockValue: v,\n              hasGitDiffFriendlyOrderedList: S,\n              splitText: b,\n              punctuationPattern: B,\n              INLINE_NODE_TYPES: k,\n              INLINE_NODE_WRAPPER_TYPES: M,\n              isAutolink: R\n            } = iu(),\n            q = new Set([\"importExport\"]),\n            J = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"],\n            L = new Set([\"listItem\", \"definition\", \"footnoteDefinition\"]);\n          function Q(oe, H, pe) {\n            let X = oe.getValue();\n            if (ge(oe)) return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map(le => le.type === \"word\" ? le.value : le.value === \"\" ? \"\" : W(oe, le.value, H));\n            switch (X.type) {\n              case \"front-matter\":\n                return H.originalText.slice(X.position.start.offset, X.position.end.offset);\n              case \"root\":\n                return X.children.length === 0 ? \"\" : [I(de(oe, H, pe)), q.has(z(X).type) ? \"\" : c];\n              case \"paragraph\":\n                return ue(oe, H, pe, {\n                  postprocessor: _\n                });\n              case \"sentence\":\n                return ue(oe, H, pe);\n              case \"word\":\n                {\n                  let le = X.value.replace(/\\*/g, \"\\\\$&\").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join(\"|\"), \"g\"), (De, A, G, re, ye) => (G ? `${A}${G}` : `${re}${ye}`).replace(/_/g, \"\\\\_\")),\n                    Ae = (De, A, G) => De.type === \"sentence\" && G === 0,\n                    Ee = (De, A, G) => R(De.children[G - 1]);\n                  return le !== X.value && (oe.match(void 0, Ae, Ee) || oe.match(void 0, Ae, (De, A, G) => De.type === \"emphasis\" && G === 0, Ee)) && (le = le.replace(/^(\\\\?[*_])+/, De => De.replace(/\\\\/g, \"\"))), le;\n                }\n              case \"whitespace\":\n                {\n                  let le = oe.getParentNode(),\n                    Ae = le.children.indexOf(X),\n                    Ee = le.children[Ae + 1],\n                    De = Ee && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(Ee.value) ? \"never\" : H.proseWrap;\n                  return W(oe, X.value, {\n                    proseWrap: De\n                  });\n                }\n              case \"emphasis\":\n                {\n                  let le;\n                  if (R(X.children[0])) le = H.originalText[X.position.start.offset];else {\n                    let Ae = oe.getParentNode(),\n                      Ee = Ae.children.indexOf(X),\n                      De = Ae.children[Ee - 1],\n                      A = Ae.children[Ee + 1];\n                    le = De && De.type === \"sentence\" && De.children.length > 0 && s(De.children).type === \"word\" && !s(De.children).hasTrailingPunctuation || A && A.type === \"sentence\" && A.children.length > 0 && A.children[0].type === \"word\" && !A.children[0].hasLeadingPunctuation || ce(oe, \"emphasis\") ? \"*\" : \"_\";\n                  }\n                  return [le, ue(oe, H, pe), le];\n                }\n              case \"strong\":\n                return [\"**\", ue(oe, H, pe), \"**\"];\n              case \"delete\":\n                return [\"~~\", ue(oe, H, pe), \"~~\"];\n              case \"inlineCode\":\n                {\n                  let le = a(X.value, \"`\"),\n                    Ae = \"`\".repeat(le || 1),\n                    Ee = le && !/^\\s/.test(X.value) ? \" \" : \"\";\n                  return [Ae, Ee, X.value, Ee, Ae];\n                }\n              case \"wikiLink\":\n                {\n                  let le = \"\";\n                  return H.proseWrap === \"preserve\" ? le = X.value : le = X.value.replace(/[\\t\\n]+/g, \" \"), [\"[[\", le, \"]]\"];\n                }\n              case \"link\":\n                switch (H.originalText[X.position.start.offset]) {\n                  case \"<\":\n                    {\n                      let le = \"mailto:\";\n                      return [\"<\", X.url.startsWith(le) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le.length) !== le ? X.url.slice(le.length) : X.url, \">\"];\n                    }\n                  case \"[\":\n                    return [\"[\", ue(oe, H, pe), \"](\", he(X.url, \")\"), we(X.title, H), \")\"];\n                  default:\n                    return H.originalText.slice(X.position.start.offset, X.position.end.offset);\n                }\n              case \"image\":\n                return [\"![\", X.alt || \"\", \"](\", he(X.url, \")\"), we(X.title, H), \")\"];\n              case \"blockquote\":\n                return [\"> \", w(\"> \", ue(oe, H, pe))];\n              case \"heading\":\n                return [\"#\".repeat(X.depth) + \" \", ue(oe, H, pe)];\n              case \"code\":\n                {\n                  if (X.isIndented) {\n                    let Ee = \" \".repeat(4);\n                    return w(Ee, [Ee, ...P(X.value, c)]);\n                  }\n                  let le = H.__inJsTemplate ? \"~\" : \"`\",\n                    Ae = le.repeat(Math.max(3, n(X.value, le) + 1));\n                  return [Ae, X.lang || \"\", X.meta ? \" \" + X.meta : \"\", c, ...P(v(X, H.originalText), c), c, Ae];\n                }\n              case \"html\":\n                {\n                  let le = oe.getParentNode(),\n                    Ae = le.type === \"root\" && s(le.children) === X ? X.value.trimEnd() : X.value,\n                    Ee = /^<!--.*-->$/s.test(Ae);\n                  return P(Ae, Ee ? c : g(h));\n                }\n              case \"list\":\n                {\n                  let le = Y(X, oe.getParentNode()),\n                    Ae = S(X, H);\n                  return ue(oe, H, pe, {\n                    processor: (Ee, De) => {\n                      let A = re(),\n                        G = Ee.getValue();\n                      if (G.children.length === 2 && G.children[1].type === \"html\" && G.children[0].position.start.column !== G.children[1].position.start.column) return [A, V(Ee, H, pe, A)];\n                      return [A, w(\" \".repeat(A.length), V(Ee, H, pe, A))];\n                      function re() {\n                        let ye = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le % 2 === 0 ? \". \" : \") \") : le % 2 === 0 ? \"- \" : \"* \";\n                        return X.isAligned || X.hasIndentedCodeblock ? j(ye, H) : ye;\n                      }\n                    }\n                  });\n                }\n              case \"thematicBreak\":\n                {\n                  let le = ee(oe, \"list\");\n                  return le === -1 ? \"---\" : Y(oe.getParentNode(le), oe.getParentNode(le + 1)) % 2 === 0 ? \"***\" : \"---\";\n                }\n              case \"linkReference\":\n                return [\"[\", ue(oe, H, pe), \"]\", X.referenceType === \"full\" ? Ne(X) : X.referenceType === \"collapsed\" ? \"[]\" : \"\"];\n              case \"imageReference\":\n                switch (X.referenceType) {\n                  case \"full\":\n                    return [\"![\", X.alt || \"\", \"]\", Ne(X)];\n                  default:\n                    return [\"![\", X.alt, \"]\", X.referenceType === \"collapsed\" ? \"[]\" : \"\"];\n                }\n              case \"definition\":\n                {\n                  let le = H.proseWrap === \"always\" ? y : \" \";\n                  return N([Ne(X), \":\", E([le, he(X.url), X.title === null ? \"\" : [le, we(X.title, H, !1)]])]);\n                }\n              case \"footnote\":\n                return [\"[^\", ue(oe, H, pe), \"]\"];\n              case \"footnoteReference\":\n                return Pe(X);\n              case \"footnoteDefinition\":\n                {\n                  let le = oe.getParentNode().children[oe.getName() + 1],\n                    Ae = X.children.length === 1 && X.children[0].type === \"paragraph\" && (H.proseWrap === \"never\" || H.proseWrap === \"preserve\" && X.children[0].position.start.line === X.children[0].position.end.line);\n                  return [Pe(X), \": \", Ae ? ue(oe, H, pe) : N([w(\" \".repeat(4), ue(oe, H, pe, {\n                    processor: (Ee, De) => De === 0 ? N([f, pe()]) : pe()\n                  })), le && le.type === \"footnoteDefinition\" ? f : \"\"])];\n                }\n              case \"table\":\n                return K(oe, H, pe);\n              case \"tableCell\":\n                return ue(oe, H, pe);\n              case \"break\":\n                return /\\s/.test(H.originalText[X.position.start.offset]) ? [\"  \", g(h)] : [\"\\\\\", c];\n              case \"liquidNode\":\n                return P(X.value, c);\n              case \"importExport\":\n                return [X.value, c];\n              case \"esComment\":\n                return [\"{/* \", X.value, \" */}\"];\n              case \"jsx\":\n                return X.value;\n              case \"math\":\n                return [\"$$\", c, X.value ? [...P(X.value, c), c] : \"\", \"$$\"];\n              case \"inlineMath\":\n                return H.originalText.slice(m(X), C(X));\n              case \"tableRow\":\n              case \"listItem\":\n              default:\n                throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);\n            }\n          }\n          function V(oe, H, pe, X) {\n            let le = oe.getValue(),\n              Ae = le.checked === null ? \"\" : le.checked ? \"[x] \" : \"[ ] \";\n            return [Ae, ue(oe, H, pe, {\n              processor: (Ee, De) => {\n                if (De === 0 && Ee.getValue().type !== \"list\") return w(\" \".repeat(Ae.length), pe());\n                let A = \" \".repeat(ke(H.tabWidth - X.length, 0, 3));\n                return [A, w(A, pe())];\n              }\n            })];\n          }\n          function j(oe, H) {\n            let pe = X();\n            return oe + \" \".repeat(pe >= 4 ? 0 : pe);\n            function X() {\n              let le = oe.length % H.tabWidth;\n              return le === 0 ? 0 : H.tabWidth - le;\n            }\n          }\n          function Y(oe, H) {\n            return ie(oe, H, pe => pe.ordered === oe.ordered);\n          }\n          function ie(oe, H, pe) {\n            let X = -1;\n            for (let le of H.children) if (le.type === oe.type && pe(le) ? X++ : X = -1, le === oe) return X;\n          }\n          function ee(oe, H) {\n            let pe = Array.isArray(H) ? H : [H],\n              X = -1,\n              le;\n            for (; le = oe.getParentNode(++X);) if (pe.includes(le.type)) return X;\n            return -1;\n          }\n          function ce(oe, H) {\n            let pe = ee(oe, H);\n            return pe === -1 ? null : oe.getParentNode(pe);\n          }\n          function W(oe, H, pe) {\n            if (pe.proseWrap === \"preserve\" && H === `\n`) return c;\n            let X = pe.proseWrap === \"always\" && !ce(oe, J);\n            return H !== \"\" ? X ? y : \" \" : X ? f : \"\";\n          }\n          function K(oe, H, pe) {\n            let X = oe.getValue(),\n              le = [],\n              Ae = oe.map(ye => ye.map((Ce, Be) => {\n                let ve = $(pe(), H).formatted,\n                  ze = u(ve);\n                return le[Be] = Math.max(le[Be] || 3, ze), {\n                  text: ve,\n                  width: ze\n                };\n              }, \"children\"), \"children\"),\n              Ee = A(!1);\n            if (H.proseWrap !== \"never\") return [l, Ee];\n            let De = A(!0);\n            return [l, N(F(De, Ee))];\n            function A(ye) {\n              let Ce = [re(Ae[0], ye), G(ye)];\n              return Ae.length > 1 && Ce.push(p(x, Ae.slice(1).map(Be => re(Be, ye)))), p(x, Ce);\n            }\n            function G(ye) {\n              return `| ${le.map((Be, ve) => {\n                let ze = X.align[ve],\n                  be = ze === \"center\" || ze === \"left\" ? \":\" : \"-\",\n                  Ye = ze === \"center\" || ze === \"right\" ? \":\" : \"-\",\n                  Se = ye ? \"-\" : \"-\".repeat(Be - 2);\n                return `${be}${Se}${Ye}`;\n              }).join(\" | \")} |`;\n            }\n            function re(ye, Ce) {\n              return `| ${ye.map((ve, ze) => {\n                let {\n                  text: be,\n                  width: Ye\n                } = ve;\n                if (Ce) return be;\n                let Se = le[ze] - Ye,\n                  Ie = X.align[ze],\n                  Oe = 0;\n                Ie === \"right\" ? Oe = Se : Ie === \"center\" && (Oe = Math.floor(Se / 2));\n                let Je = Se - Oe;\n                return `${\" \".repeat(Oe)}${be}${\" \".repeat(Je)}`;\n              }).join(\" | \")} |`;\n            }\n          }\n          function de(oe, H, pe) {\n            let X = [],\n              le = null,\n              {\n                children: Ae\n              } = oe.getValue();\n            for (let [Ee, De] of Ae.entries()) switch (U(De)) {\n              case \"start\":\n                le === null && (le = {\n                  index: Ee,\n                  offset: De.position.end.offset\n                });\n                break;\n              case \"end\":\n                le !== null && (X.push({\n                  start: le,\n                  end: {\n                    index: Ee,\n                    offset: De.position.start.offset\n                  }\n                }), le = null);\n                break;\n              default:\n                break;\n            }\n            return ue(oe, H, pe, {\n              processor: (Ee, De) => {\n                if (X.length > 0) {\n                  let A = X[0];\n                  if (De === A.start.index) return [Fe(Ae[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe(Ae[A.end.index])];\n                  if (A.start.index < De && De < A.end.index) return !1;\n                  if (De === A.end.index) return X.shift(), !1;\n                }\n                return pe();\n              }\n            });\n          }\n          function ue(oe, H, pe) {\n            let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},\n              {\n                postprocessor: le\n              } = X,\n              Ae = X.processor || (() => pe()),\n              Ee = oe.getValue(),\n              De = [],\n              A;\n            return oe.each((G, re) => {\n              let ye = G.getValue(),\n                Ce = Ae(G, re);\n              if (Ce !== !1) {\n                let Be = {\n                  parts: De,\n                  prevNode: A,\n                  parentNode: Ee,\n                  options: H\n                };\n                Z(ye, Be) && (De.push(c), A && q.has(A.type) || (se(ye, Be) || fe(ye, Be)) && De.push(c), fe(ye, Be) && De.push(c)), De.push(Ce), A = ye;\n              }\n            }, \"children\"), le ? le(De) : De;\n          }\n          function Fe(oe) {\n            if (oe.type === \"html\") return oe.value;\n            if (oe.type === \"paragraph\" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === \"esComment\") return [\"{/* \", oe.children[0].value, \" */}\"];\n          }\n          function z(oe) {\n            let H = oe;\n            for (; i(H.children);) H = s(H.children);\n            return H;\n          }\n          function U(oe) {\n            let H;\n            if (oe.type === \"html\") H = oe.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);else {\n              let pe;\n              oe.type === \"esComment\" ? pe = oe : oe.type === \"paragraph\" && oe.children.length === 1 && oe.children[0].type === \"esComment\" && (pe = oe.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));\n            }\n            return H ? H[1] || \"next\" : !1;\n          }\n          function Z(oe, H) {\n            let pe = H.parts.length === 0,\n              X = k.includes(oe.type),\n              le = oe.type === \"html\" && M.includes(H.parentNode.type);\n            return !pe && !X && !le;\n          }\n          function se(oe, H) {\n            var pe, X, le;\n            let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type),\n              De = H.parentNode.type === \"listItem\" && !H.parentNode.loose,\n              A = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === \"listItem\" && H.prevNode.loose,\n              G = U(H.prevNode) === \"next\",\n              re = oe.type === \"html\" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === \"html\" && H.prevNode.position.end.line + 1 === oe.position.start.line,\n              ye = oe.type === \"html\" && H.parentNode.type === \"listItem\" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === \"paragraph\" && H.prevNode.position.end.line + 1 === oe.position.start.line;\n            return A || !(Ee || De || G || re || ye);\n          }\n          function fe(oe, H) {\n            let pe = H.prevNode && H.prevNode.type === \"list\",\n              X = oe.type === \"code\" && oe.isIndented;\n            return pe && X;\n          }\n          function ge(oe) {\n            let H = ce(oe, [\"linkReference\", \"imageReference\"]);\n            return H && (H.type !== \"linkReference\" || H.referenceType !== \"full\");\n          }\n          function he(oe) {\n            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],\n              pe = [\" \", ...(Array.isArray(H) ? H : [H])];\n            return new RegExp(pe.map(X => `\\\\${X}`).join(\"|\")).test(oe) ? `<${oe}>` : oe;\n          }\n          function we(oe, H) {\n            let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n            if (!oe) return \"\";\n            if (pe) return \" \" + we(oe, H, !1);\n            if (oe = oe.replace(/\\\\([\"')])/g, \"$1\"), oe.includes('\"') && oe.includes(\"'\") && !oe.includes(\")\")) return `(${oe})`;\n            let X = oe.split(\"'\").length - 1,\n              le = oe.split('\"').length - 1,\n              Ae = X > le ? '\"' : le > X || H.singleQuote ? \"'\" : '\"';\n            return oe = oe.replace(/\\\\/, \"\\\\\\\\\"), oe = oe.replace(new RegExp(`(${Ae})`, \"g\"), \"\\\\$1\"), `${Ae}${oe}${Ae}`;\n          }\n          function ke(oe, H, pe) {\n            return oe < H ? H : oe > pe ? pe : oe;\n          }\n          function Re(oe) {\n            let H = Number(oe.getName());\n            if (H === 0) return !1;\n            let pe = oe.getParentNode().children[H - 1];\n            return U(pe) === \"next\";\n          }\n          function Ne(oe) {\n            return `[${t(oe.label)}]`;\n          }\n          function Pe(oe) {\n            return `[^${oe.label}]`;\n          }\n          r.exports = {\n            preprocess: o,\n            print: Q,\n            embed: D,\n            massageAstNode: d,\n            hasPrettierIgnore: Re,\n            insertPragma: T\n          };\n        }\n      }),\n      Dg = te({\n        \"src/language-markdown/options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Mt();\n          r.exports = {\n            proseWrap: t.proseWrap,\n            singleQuote: t.singleQuote\n          };\n        }\n      }),\n      mg = te({\n        \"src/language-markdown/parsers.js\"() {\n          ne();\n        }\n      }),\n      _a = te({\n        \"node_modules/linguist-languages/data/Markdown.json\"(e, r) {\n          r.exports = {\n            name: \"Markdown\",\n            type: \"prose\",\n            color: \"#083fa1\",\n            aliases: [\"pandoc\"],\n            aceMode: \"markdown\",\n            codemirrorMode: \"gfm\",\n            codemirrorMimeType: \"text/x-gfm\",\n            wrap: !0,\n            extensions: [\".md\", \".livemd\", \".markdown\", \".mdown\", \".mdwn\", \".mdx\", \".mkd\", \".mkdn\", \".mkdown\", \".ronn\", \".scd\", \".workbook\"],\n            filenames: [\"contents.lr\"],\n            tmScope: \"source.gfm\",\n            languageId: 222\n          };\n        }\n      }),\n      dg = te({\n        \"src/language-markdown/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = _t(),\n            s = fg(),\n            a = Dg(),\n            n = mg(),\n            u = [t(_a(), l => ({\n              since: \"1.8.0\",\n              parsers: [\"markdown\"],\n              vscodeLanguageIds: [\"markdown\"],\n              filenames: [...l.filenames, \"README\"],\n              extensions: l.extensions.filter(p => p !== \".mdx\")\n            })), t(_a(), () => ({\n              name: \"MDX\",\n              since: \"1.15.0\",\n              parsers: [\"mdx\"],\n              vscodeLanguageIds: [\"mdx\"],\n              filenames: [],\n              extensions: [\".mdx\"]\n            }))],\n            i = {\n              mdast: s\n            };\n          r.exports = {\n            languages: u,\n            options: a,\n            printers: i,\n            parsers: n\n          };\n        }\n      }),\n      gg = te({\n        \"src/language-html/clean.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              isFrontMatterNode: t\n            } = Ue(),\n            s = new Set([\"sourceSpan\", \"startSourceSpan\", \"endSourceSpan\", \"nameSpan\", \"valueSpan\"]);\n          function a(n, u) {\n            if (n.type === \"text\" || n.type === \"comment\" || t(n) || n.type === \"yaml\" || n.type === \"toml\") return null;\n            n.type === \"attribute\" && delete u.value, n.type === \"docType\" && delete u.value;\n          }\n          a.ignoredProperties = s, r.exports = a;\n        }\n      }),\n      yg = te({\n        \"src/language-html/constants.evaluate.js\"(e, r) {\n          r.exports = {\n            CSS_DISPLAY_TAGS: {\n              area: \"none\",\n              base: \"none\",\n              basefont: \"none\",\n              datalist: \"none\",\n              head: \"none\",\n              link: \"none\",\n              meta: \"none\",\n              noembed: \"none\",\n              noframes: \"none\",\n              param: \"block\",\n              rp: \"none\",\n              script: \"block\",\n              source: \"block\",\n              style: \"none\",\n              template: \"inline\",\n              track: \"block\",\n              title: \"none\",\n              html: \"block\",\n              body: \"block\",\n              address: \"block\",\n              blockquote: \"block\",\n              center: \"block\",\n              div: \"block\",\n              figure: \"block\",\n              figcaption: \"block\",\n              footer: \"block\",\n              form: \"block\",\n              header: \"block\",\n              hr: \"block\",\n              legend: \"block\",\n              listing: \"block\",\n              main: \"block\",\n              p: \"block\",\n              plaintext: \"block\",\n              pre: \"block\",\n              xmp: \"block\",\n              slot: \"contents\",\n              ruby: \"ruby\",\n              rt: \"ruby-text\",\n              article: \"block\",\n              aside: \"block\",\n              h1: \"block\",\n              h2: \"block\",\n              h3: \"block\",\n              h4: \"block\",\n              h5: \"block\",\n              h6: \"block\",\n              hgroup: \"block\",\n              nav: \"block\",\n              section: \"block\",\n              dir: \"block\",\n              dd: \"block\",\n              dl: \"block\",\n              dt: \"block\",\n              ol: \"block\",\n              ul: \"block\",\n              li: \"list-item\",\n              table: \"table\",\n              caption: \"table-caption\",\n              colgroup: \"table-column-group\",\n              col: \"table-column\",\n              thead: \"table-header-group\",\n              tbody: \"table-row-group\",\n              tfoot: \"table-footer-group\",\n              tr: \"table-row\",\n              td: \"table-cell\",\n              th: \"table-cell\",\n              fieldset: \"block\",\n              button: \"inline-block\",\n              details: \"block\",\n              summary: \"block\",\n              dialog: \"block\",\n              meter: \"inline-block\",\n              progress: \"inline-block\",\n              object: \"inline-block\",\n              video: \"inline-block\",\n              audio: \"inline-block\",\n              select: \"inline-block\",\n              option: \"block\",\n              optgroup: \"block\"\n            },\n            CSS_DISPLAY_DEFAULT: \"inline\",\n            CSS_WHITE_SPACE_TAGS: {\n              listing: \"pre\",\n              plaintext: \"pre\",\n              pre: \"pre\",\n              xmp: \"pre\",\n              nobr: \"nowrap\",\n              table: \"initial\",\n              textarea: \"pre-wrap\"\n            },\n            CSS_WHITE_SPACE_DEFAULT: \"normal\"\n          };\n        }\n      }),\n      hg = te({\n        \"src/language-html/utils/is-unknown-namespace.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s) {\n            return s.type === \"element\" && !s.hasExplicitNamespace && ![\"html\", \"svg\"].includes(s.namespace);\n          }\n          r.exports = t;\n        }\n      }),\n      Rt = te({\n        \"src/language-html/utils/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              inferParserByLanguage: t,\n              isFrontMatterNode: s\n            } = Ue(),\n            {\n              builders: {\n                line: a,\n                hardline: n,\n                join: u\n              },\n              utils: {\n                getDocParts: i,\n                replaceTextEndOfLine: l\n              }\n            } = qe(),\n            {\n              CSS_DISPLAY_TAGS: p,\n              CSS_DISPLAY_DEFAULT: y,\n              CSS_WHITE_SPACE_TAGS: h,\n              CSS_WHITE_SPACE_DEFAULT: g\n            } = yg(),\n            c = hg(),\n            f = new Set([\"\t\", `\n`, \"\\f\", \"\\r\", \" \"]),\n            F = A => A.replace(/^[\\t\\n\\f\\r ]+/, \"\"),\n            _ = A => A.replace(/[\\t\\n\\f\\r ]+$/, \"\"),\n            w = A => F(_(A)),\n            E = A => A.replace(/^[\\t\\f\\r ]*\\n/g, \"\"),\n            N = A => E(_(A)),\n            x = A => A.split(/[\\t\\n\\f\\r ]+/),\n            I = A => A.match(/^[\\t\\n\\f\\r ]*/)[0],\n            P = A => {\n              let [, G, re, ye] = A.match(/^([\\t\\n\\f\\r ]*)(.*?)([\\t\\n\\f\\r ]*)$/s);\n              return {\n                leadingWhitespace: G,\n                trailingWhitespace: ye,\n                text: re\n              };\n            },\n            $ = A => /[\\t\\n\\f\\r ]/.test(A);\n          function D(A, G) {\n            return !!(A.type === \"ieConditionalComment\" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === \"ieConditionalComment\" && !A.complete || se(A) && A.children.some(re => re.type !== \"text\" && re.type !== \"interpolation\") || X(A, G) && !o(A) && A.type !== \"interpolation\");\n          }\n          function T(A) {\n            return A.type === \"attribute\" || !A.parent || !A.prev ? !1 : m(A.prev);\n          }\n          function m(A) {\n            return A.type === \"comment\" && A.value.trim() === \"prettier-ignore\";\n          }\n          function C(A) {\n            return A.type === \"text\" || A.type === \"comment\";\n          }\n          function o(A) {\n            return A.type === \"element\" && (A.fullName === \"script\" || A.fullName === \"style\" || A.fullName === \"svg:style\" || c(A) && (A.name === \"script\" || A.name === \"style\"));\n          }\n          function d(A) {\n            return A.children && !o(A);\n          }\n          function v(A) {\n            return o(A) || A.type === \"interpolation\" || S(A);\n          }\n          function S(A) {\n            return we(A).startsWith(\"pre\");\n          }\n          function b(A, G) {\n            let re = ye();\n            if (re && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf) return A.type === \"interpolation\";\n            return re;\n            function ye() {\n              return s(A) ? !1 : (A.type === \"text\" || A.type === \"interpolation\") && A.prev && (A.prev.type === \"text\" || A.prev.type === \"interpolation\") ? !0 : !A.parent || A.parent.cssDisplay === \"none\" ? !1 : se(A.parent) ? !0 : !(!A.prev && (A.parent.type === \"root\" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue(A.parent.cssDisplay)) || A.prev && !U(A.prev.cssDisplay));\n            }\n          }\n          function B(A, G) {\n            return s(A) ? !1 : (A.type === \"text\" || A.type === \"interpolation\") && A.next && (A.next.type === \"text\" || A.next.type === \"interpolation\") ? !0 : !A.parent || A.parent.cssDisplay === \"none\" ? !1 : se(A.parent) ? !0 : !(!A.next && (A.parent.type === \"root\" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));\n          }\n          function k(A) {\n            return Z(A.cssDisplay) && !o(A);\n          }\n          function M(A) {\n            return s(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;\n          }\n          function R(A) {\n            return q(A) || A.type === \"element\" && A.children.length > 0 && ([\"body\", \"script\", \"style\"].includes(A.name) || A.children.some(G => ee(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== \"text\" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));\n          }\n          function q(A) {\n            return A.type === \"element\" && A.children.length > 0 && ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].includes(A.name) || A.cssDisplay.startsWith(\"table\") && A.cssDisplay !== \"table-cell\");\n          }\n          function J(A) {\n            return Y(A) || A.prev && L(A.prev) || Q(A);\n          }\n          function L(A) {\n            return Y(A) || A.type === \"element\" && A.fullName === \"br\" || Q(A);\n          }\n          function Q(A) {\n            return V(A) && j(A);\n          }\n          function V(A) {\n            return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === \"root\" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);\n          }\n          function j(A) {\n            return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === \"root\" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);\n          }\n          function Y(A) {\n            switch (A.type) {\n              case \"ieConditionalComment\":\n              case \"comment\":\n              case \"directive\":\n                return !0;\n              case \"element\":\n                return [\"script\", \"select\"].includes(A.name);\n            }\n            return !1;\n          }\n          function ie(A) {\n            return A.lastChild ? ie(A.lastChild) : A;\n          }\n          function ee(A) {\n            return A.children && A.children.some(G => G.type !== \"text\");\n          }\n          function ce(A) {\n            let {\n              type: G,\n              lang: re\n            } = A.attrMap;\n            if (G === \"module\" || G === \"text/javascript\" || G === \"text/babel\" || G === \"application/javascript\" || re === \"jsx\") return \"babel\";\n            if (G === \"application/x-typescript\" || re === \"ts\" || re === \"tsx\") return \"typescript\";\n            if (G === \"text/markdown\") return \"markdown\";\n            if (G === \"text/html\") return \"html\";\n            if (G && (G.endsWith(\"json\") || G.endsWith(\"importmap\")) || G === \"speculationrules\") return \"json\";\n            if (G === \"text/x-handlebars-template\") return \"glimmer\";\n          }\n          function W(A, G) {\n            let {\n              lang: re\n            } = A.attrMap;\n            if (!re || re === \"postcss\" || re === \"css\") return \"css\";\n            if (re === \"scss\") return \"scss\";\n            if (re === \"less\") return \"less\";\n            if (re === \"stylus\") return t(\"stylus\", G);\n          }\n          function K(A, G) {\n            if (A.name === \"script\" && !A.attrMap.src) return !A.attrMap.lang && !A.attrMap.type ? \"babel\" : ce(A);\n            if (A.name === \"style\") return W(A, G);\n            if (G && X(A, G)) return ce(A) || !(\"src\" in A.attrMap) && t(A.attrMap.lang, G);\n          }\n          function de(A) {\n            return A === \"block\" || A === \"list-item\" || A.startsWith(\"table\");\n          }\n          function ue(A) {\n            return !de(A) && A !== \"inline-block\";\n          }\n          function Fe(A) {\n            return !de(A) && A !== \"inline-block\";\n          }\n          function z(A) {\n            return !de(A);\n          }\n          function U(A) {\n            return !de(A);\n          }\n          function Z(A) {\n            return !de(A) && A !== \"inline-block\";\n          }\n          function se(A) {\n            return we(A).startsWith(\"pre\");\n          }\n          function fe(A, G) {\n            let re = 0;\n            for (let ye = A.stack.length - 1; ye >= 0; ye--) {\n              let Ce = A.stack[ye];\n              Ce && typeof Ce == \"object\" && !Array.isArray(Ce) && G(Ce) && re++;\n            }\n            return re;\n          }\n          function ge(A, G) {\n            let re = A;\n            for (; re;) {\n              if (G(re)) return !0;\n              re = re.parent;\n            }\n            return !1;\n          }\n          function he(A, G) {\n            if (A.prev && A.prev.type === \"comment\") {\n              let ye = A.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);\n              if (ye) return ye[1];\n            }\n            let re = !1;\n            if (A.type === \"element\" && A.namespace === \"svg\") if (ge(A, ye => ye.fullName === \"svg:foreignObject\")) re = !0;else return A.name === \"svg\" ? \"inline-block\" : \"block\";\n            switch (G.htmlWhitespaceSensitivity) {\n              case \"strict\":\n                return \"inline\";\n              case \"ignore\":\n                return \"block\";\n              default:\n                return G.parser === \"vue\" && A.parent && A.parent.type === \"root\" ? \"block\" : A.type === \"element\" && (!A.namespace || re || c(A)) && p[A.name] || y;\n            }\n          }\n          function we(A) {\n            return A.type === \"element\" && (!A.namespace || c(A)) && h[A.name] || g;\n          }\n          function ke(A) {\n            let G = Number.POSITIVE_INFINITY;\n            for (let re of A.split(`\n`)) {\n              if (re.length === 0) continue;\n              if (!f.has(re[0])) return 0;\n              let ye = I(re).length;\n              re.length !== ye && ye < G && (G = ye);\n            }\n            return G === Number.POSITIVE_INFINITY ? 0 : G;\n          }\n          function Re(A) {\n            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A);\n            return G === 0 ? A : A.split(`\n`).map(re => re.slice(G)).join(`\n`);\n          }\n          function Ne(A, G) {\n            let re = 0;\n            for (let ye = 0; ye < A.length; ye++) A[ye] === G && re++;\n            return re;\n          }\n          function Pe(A) {\n            return A.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n          }\n          var oe = new Set([\"template\", \"style\", \"script\"]);\n          function H(A, G) {\n            return pe(A, G) && !oe.has(A.fullName);\n          }\n          function pe(A, G) {\n            return G.parser === \"vue\" && A.type === \"element\" && A.parent.type === \"root\" && A.fullName.toLowerCase() !== \"html\";\n          }\n          function X(A, G) {\n            return pe(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== \"html\");\n          }\n          function le(A) {\n            let G = A.fullName;\n            return G.charAt(0) === \"#\" || G === \"slot-scope\" || G === \"v-slot\" || G.startsWith(\"v-slot:\");\n          }\n          function Ae(A, G) {\n            let re = A.parent;\n            if (!pe(re, G)) return !1;\n            let ye = re.fullName,\n              Ce = A.fullName;\n            return ye === \"script\" && Ce === \"setup\" || ye === \"style\" && Ce === \"vars\";\n          }\n          function Ee(A) {\n            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;\n            return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re(N(G)), n) : i(u(a, x(G)));\n          }\n          function De(A, G) {\n            return pe(A, G) && A.name === \"script\";\n          }\n          r.exports = {\n            htmlTrim: w,\n            htmlTrimPreserveIndentation: N,\n            hasHtmlWhitespace: $,\n            getLeadingAndTrailingHtmlWhitespace: P,\n            canHaveInterpolation: d,\n            countChars: Ne,\n            countParents: fe,\n            dedentString: Re,\n            forceBreakChildren: q,\n            forceBreakContent: R,\n            forceNextEmptyLine: M,\n            getLastDescendant: ie,\n            getNodeCssStyleDisplay: he,\n            getNodeCssStyleWhiteSpace: we,\n            hasPrettierIgnore: T,\n            inferScriptParser: K,\n            isVueCustomBlock: H,\n            isVueNonHtmlBlock: X,\n            isVueScriptTag: De,\n            isVueSlotAttribute: le,\n            isVueSfcBindingsAttribute: Ae,\n            isVueSfcBlock: pe,\n            isDanglingSpaceSensitiveNode: k,\n            isIndentationSensitiveNode: S,\n            isLeadingSpaceSensitiveNode: b,\n            isPreLikeNode: se,\n            isScriptLikeTag: o,\n            isTextLikeNode: C,\n            isTrailingSpaceSensitiveNode: B,\n            isWhitespaceSensitiveNode: v,\n            isUnknownNamespace: c,\n            preferHardlineAsLeadingSpaces: J,\n            preferHardlineAsTrailingSpaces: L,\n            shouldPreserveContent: D,\n            unescapeQuoteEntities: Pe,\n            getTextValueParts: Ee\n          };\n        }\n      }),\n      vg = te({\n        \"node_modules/angular-html-parser/lib/compiler/src/chars.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;\n          function r(i) {\n            return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;\n          }\n          e.isWhitespace = r;\n          function t(i) {\n            return e.$0 <= i && i <= e.$9;\n          }\n          e.isDigit = t;\n          function s(i) {\n            return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;\n          }\n          e.isAsciiLetter = s;\n          function a(i) {\n            return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);\n          }\n          e.isAsciiHexDigit = a;\n          function n(i) {\n            return i === e.$LF || i === e.$CR;\n          }\n          e.isNewLine = n;\n          function u(i) {\n            return e.$0 <= i && i <= e.$7;\n          }\n          e.isOctalDigit = u;\n        }\n      }),\n      Cg = te({\n        \"node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = class {\n            constructor(s, a, n) {\n              this.filePath = s, this.name = a, this.members = n;\n            }\n            assertNoMembers() {\n              if (this.members.length) throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);\n            }\n          };\n          e.StaticSymbol = r;\n          var t = class {\n            constructor() {\n              this.cache = new Map();\n            }\n            get(s, a, n) {\n              n = n || [];\n              let u = n.length ? `.${n.join(\".\")}` : \"\",\n                i = `\"${s}\".${a}${u}`,\n                l = this.cache.get(i);\n              return l || (l = new r(s, a, n), this.cache.set(i, l)), l;\n            }\n          };\n          e.StaticSymbolCache = t;\n        }\n      }),\n      Eg = te({\n        \"node_modules/angular-html-parser/lib/compiler/src/util.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = /-+([a-z0-9])/g;\n          function t(o) {\n            return o.replace(r, function () {\n              for (var d = arguments.length, v = new Array(d), S = 0; S < d; S++) v[S] = arguments[S];\n              return v[1].toUpperCase();\n            });\n          }\n          e.dashCaseToCamelCase = t;\n          function s(o, d) {\n            return n(o, \":\", d);\n          }\n          e.splitAtColon = s;\n          function a(o, d) {\n            return n(o, \".\", d);\n          }\n          e.splitAtPeriod = a;\n          function n(o, d, v) {\n            let S = o.indexOf(d);\n            return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];\n          }\n          function u(o, d, v) {\n            return Array.isArray(o) ? d.visitArray(o, v) : E(o) ? d.visitStringMap(o, v) : o == null || typeof o == \"string\" || typeof o == \"number\" || typeof o == \"boolean\" ? d.visitPrimitive(o, v) : d.visitOther(o, v);\n          }\n          e.visitValue = u;\n          function i(o) {\n            return o != null;\n          }\n          e.isDefined = i;\n          function l(o) {\n            return o === void 0 ? null : o;\n          }\n          e.noUndefined = l;\n          var p = class {\n            visitArray(o, d) {\n              return o.map(v => u(v, this, d));\n            }\n            visitStringMap(o, d) {\n              let v = {};\n              return Object.keys(o).forEach(S => {\n                v[S] = u(o[S], this, d);\n              }), v;\n            }\n            visitPrimitive(o, d) {\n              return o;\n            }\n            visitOther(o, d) {\n              return o;\n            }\n          };\n          e.ValueTransformer = p, e.SyncAsync = {\n            assertSync: o => {\n              if (P(o)) throw new Error(\"Illegal state: value cannot be a promise\");\n              return o;\n            },\n            then: (o, d) => P(o) ? o.then(d) : d(o),\n            all: o => o.some(P) ? Promise.all(o) : o\n          };\n          function y(o) {\n            throw new Error(`Internal Error: ${o}`);\n          }\n          e.error = y;\n          function h(o, d) {\n            let v = Error(o);\n            return v[g] = !0, d && (v[c] = d), v;\n          }\n          e.syntaxError = h;\n          var g = \"ngSyntaxError\",\n            c = \"ngParseErrors\";\n          function f(o) {\n            return o[g];\n          }\n          e.isSyntaxError = f;\n          function F(o) {\n            return o[c] || [];\n          }\n          e.getParseErrors = F;\n          function _(o) {\n            return o.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n          }\n          e.escapeRegExp = _;\n          var w = Object.getPrototypeOf({});\n          function E(o) {\n            return typeof o == \"object\" && o !== null && Object.getPrototypeOf(o) === w;\n          }\n          function N(o) {\n            let d = \"\";\n            for (let v = 0; v < o.length; v++) {\n              let S = o.charCodeAt(v);\n              if (S >= 55296 && S <= 56319 && o.length > v + 1) {\n                let b = o.charCodeAt(v + 1);\n                b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);\n              }\n              S <= 127 ? d += String.fromCharCode(S) : S <= 2047 ? d += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));\n            }\n            return d;\n          }\n          e.utf8Encode = N;\n          function x(o) {\n            if (typeof o == \"string\") return o;\n            if (o instanceof Array) return \"[\" + o.map(x).join(\", \") + \"]\";\n            if (o == null) return \"\" + o;\n            if (o.overriddenName) return `${o.overriddenName}`;\n            if (o.name) return `${o.name}`;\n            if (!o.toString) return \"object\";\n            let d = o.toString();\n            if (d == null) return \"\" + d;\n            let v = d.indexOf(`\n`);\n            return v === -1 ? d : d.substring(0, v);\n          }\n          e.stringify = x;\n          function I(o) {\n            return typeof o == \"function\" && o.hasOwnProperty(\"__forward_ref__\") ? o() : o;\n          }\n          e.resolveForwardRef = I;\n          function P(o) {\n            return !!o && typeof o.then == \"function\";\n          }\n          e.isPromise = P;\n          var $ = class {\n            constructor(o) {\n              this.full = o;\n              let d = o.split(\".\");\n              this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(\".\");\n            }\n          };\n          e.Version = $;\n          var D = typeof window < \"u\" && window,\n            T = typeof self < \"u\" && typeof WorkerGlobalScope < \"u\" && self instanceof WorkerGlobalScope && self,\n            m = typeof globalThis < \"u\" && globalThis,\n            C = m || D || T;\n          e.global = C;\n        }\n      }),\n      Fg = te({\n        \"node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = Cg(),\n            t = Eg(),\n            s = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n          function a(v) {\n            return v.replace(/\\W/g, \"_\");\n          }\n          e.sanitizeIdentifier = a;\n          var n = 0;\n          function u(v) {\n            if (!v || !v.reference) return null;\n            let S = v.reference;\n            if (S instanceof r.StaticSymbol) return S.name;\n            if (S.__anonymousType) return S.__anonymousType;\n            let b = t.stringify(S);\n            return b.indexOf(\"(\") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a(b), b;\n          }\n          e.identifierName = u;\n          function i(v) {\n            let S = v.reference;\n            return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;\n          }\n          e.identifierModuleUrl = i;\n          function l(v, S) {\n            return `View_${u({\n              reference: v\n            })}_${S}`;\n          }\n          e.viewClassName = l;\n          function p(v) {\n            return `RenderType_${u({\n              reference: v\n            })}`;\n          }\n          e.rendererTypeName = p;\n          function y(v) {\n            return `HostView_${u({\n              reference: v\n            })}`;\n          }\n          e.hostViewClassName = y;\n          function h(v) {\n            return `${u({\n              reference: v\n            })}NgFactory`;\n          }\n          e.componentFactoryName = h;\n          var g;\n          (function (v) {\n            v[v.Pipe = 0] = \"Pipe\", v[v.Directive = 1] = \"Directive\", v[v.NgModule = 2] = \"NgModule\", v[v.Injectable = 3] = \"Injectable\";\n          })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));\n          function c(v) {\n            return v.value != null ? a(v.value) : u(v.identifier);\n          }\n          e.tokenName = c;\n          function f(v) {\n            return v.identifier != null ? v.identifier.reference : v.value;\n          }\n          e.tokenReference = f;\n          var F = class {\n            constructor() {\n              let {\n                moduleUrl: v,\n                styles: S,\n                styleUrls: b\n              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n              this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);\n            }\n          };\n          e.CompileStylesheetMetadata = F;\n          var _ = class {\n            constructor(v) {\n              let {\n                encapsulation: S,\n                template: b,\n                templateUrl: B,\n                htmlAst: k,\n                styles: M,\n                styleUrls: R,\n                externalStylesheets: q,\n                animations: J,\n                ngContentSelectors: L,\n                interpolation: Q,\n                isInline: V,\n                preserveWhitespaces: j\n              } = v;\n              if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2) throw new Error(\"'interpolation' should have a start and an end symbol.\");\n              this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;\n            }\n            toSummary() {\n              return {\n                ngContentSelectors: this.ngContentSelectors,\n                encapsulation: this.encapsulation,\n                styles: this.styles,\n                animations: this.animations\n              };\n            }\n          };\n          e.CompileTemplateMetadata = _;\n          var w = class {\n            static create(v) {\n              let {\n                  isHost: S,\n                  type: b,\n                  isComponent: B,\n                  selector: k,\n                  exportAs: M,\n                  changeDetection: R,\n                  inputs: q,\n                  outputs: J,\n                  host: L,\n                  providers: Q,\n                  viewProviders: V,\n                  queries: j,\n                  guards: Y,\n                  viewQueries: ie,\n                  entryComponents: ee,\n                  template: ce,\n                  componentViewType: W,\n                  rendererType: K,\n                  componentFactory: de\n                } = v,\n                ue = {},\n                Fe = {},\n                z = {};\n              L != null && Object.keys(L).forEach(se => {\n                let fe = L[se],\n                  ge = se.match(s);\n                ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);\n              });\n              let U = {};\n              q != null && q.forEach(se => {\n                let fe = t.splitAtColon(se, [se, se]);\n                U[fe[0]] = fe[1];\n              });\n              let Z = {};\n              return J != null && J.forEach(se => {\n                let fe = t.splitAtColon(se, [se, se]);\n                Z[fe[0]] = fe[1];\n              }), new w({\n                isHost: S,\n                type: b,\n                isComponent: !!B,\n                selector: k,\n                exportAs: M,\n                changeDetection: R,\n                inputs: U,\n                outputs: Z,\n                hostListeners: ue,\n                hostProperties: Fe,\n                hostAttributes: z,\n                providers: Q,\n                viewProviders: V,\n                queries: j,\n                guards: Y,\n                viewQueries: ie,\n                entryComponents: ee,\n                template: ce,\n                componentViewType: W,\n                rendererType: K,\n                componentFactory: de\n              });\n            }\n            constructor(v) {\n              let {\n                isHost: S,\n                type: b,\n                isComponent: B,\n                selector: k,\n                exportAs: M,\n                changeDetection: R,\n                inputs: q,\n                outputs: J,\n                hostListeners: L,\n                hostProperties: Q,\n                hostAttributes: V,\n                providers: j,\n                viewProviders: Y,\n                queries: ie,\n                guards: ee,\n                viewQueries: ce,\n                entryComponents: W,\n                template: K,\n                componentViewType: de,\n                rendererType: ue,\n                componentFactory: Fe\n              } = v;\n              this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;\n            }\n            toSummary() {\n              return {\n                summaryKind: g.Directive,\n                type: this.type,\n                isComponent: this.isComponent,\n                selector: this.selector,\n                exportAs: this.exportAs,\n                inputs: this.inputs,\n                outputs: this.outputs,\n                hostListeners: this.hostListeners,\n                hostProperties: this.hostProperties,\n                hostAttributes: this.hostAttributes,\n                providers: this.providers,\n                viewProviders: this.viewProviders,\n                queries: this.queries,\n                guards: this.guards,\n                viewQueries: this.viewQueries,\n                entryComponents: this.entryComponents,\n                changeDetection: this.changeDetection,\n                template: this.template && this.template.toSummary(),\n                componentViewType: this.componentViewType,\n                rendererType: this.rendererType,\n                componentFactory: this.componentFactory\n              };\n            }\n          };\n          e.CompileDirectiveMetadata = w;\n          var E = class {\n            constructor(v) {\n              let {\n                type: S,\n                name: b,\n                pure: B\n              } = v;\n              this.type = S, this.name = b, this.pure = !!B;\n            }\n            toSummary() {\n              return {\n                summaryKind: g.Pipe,\n                type: this.type,\n                name: this.name,\n                pure: this.pure\n              };\n            }\n          };\n          e.CompilePipeMetadata = E;\n          var N = class {};\n          e.CompileShallowModuleMetadata = N;\n          var x = class {\n            constructor(v) {\n              let {\n                type: S,\n                providers: b,\n                declaredDirectives: B,\n                exportedDirectives: k,\n                declaredPipes: M,\n                exportedPipes: R,\n                entryComponents: q,\n                bootstrapComponents: J,\n                importedModules: L,\n                exportedModules: Q,\n                schemas: V,\n                transitiveModule: j,\n                id: Y\n              } = v;\n              this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;\n            }\n            toSummary() {\n              let v = this.transitiveModule;\n              return {\n                summaryKind: g.NgModule,\n                type: this.type,\n                entryComponents: v.entryComponents,\n                providers: v.providers,\n                modules: v.modules,\n                exportedDirectives: v.exportedDirectives,\n                exportedPipes: v.exportedPipes\n              };\n            }\n          };\n          e.CompileNgModuleMetadata = x;\n          var I = class {\n            constructor() {\n              this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];\n            }\n            addProvider(v, S) {\n              this.providers.push({\n                provider: v,\n                module: S\n              });\n            }\n            addDirective(v) {\n              this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));\n            }\n            addExportedDirective(v) {\n              this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));\n            }\n            addPipe(v) {\n              this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));\n            }\n            addExportedPipe(v) {\n              this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));\n            }\n            addModule(v) {\n              this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));\n            }\n            addEntryComponent(v) {\n              this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));\n            }\n          };\n          e.TransitiveCompileNgModuleMetadata = I;\n          function P(v) {\n            return v || [];\n          }\n          var $ = class {\n            constructor(v, S) {\n              let {\n                useClass: b,\n                useValue: B,\n                useExisting: k,\n                useFactory: M,\n                deps: R,\n                multi: q\n              } = S;\n              this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q;\n            }\n          };\n          e.ProviderMeta = $;\n          function D(v) {\n            return v.reduce((S, b) => {\n              let B = Array.isArray(b) ? D(b) : b;\n              return S.concat(B);\n            }, []);\n          }\n          e.flatten = D;\n          function T(v) {\n            return v.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, \"ng:///\");\n          }\n          function m(v, S, b) {\n            let B;\n            return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);\n          }\n          e.templateSourceUrl = m;\n          function C(v, S) {\n            let b = v.moduleUrl.split(/\\/\\\\/g),\n              B = b[b.length - 1];\n            return T(`css/${S}${B}.ngstyle.js`);\n          }\n          e.sharedStylesheetJitUrl = C;\n          function o(v) {\n            return T(`${u(v.type)}/module.ngfactory.js`);\n          }\n          e.ngModuleJitUrl = o;\n          function d(v, S) {\n            return T(`${u(v)}/${u(S.type)}.ngfactory.js`);\n          }\n          e.templateJitUrl = d;\n        }\n      }),\n      Ag = te({\n        \"node_modules/angular-html-parser/lib/compiler/src/parse_util.js\"(e) {\n          \"use strict\";\n\n          ne(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var r = vg(),\n            t = Fg(),\n            s = class {\n              constructor(y, h, g, c) {\n                this.file = y, this.offset = h, this.line = g, this.col = c;\n              }\n              toString() {\n                return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n              }\n              moveBy(y) {\n                let h = this.file.content,\n                  g = h.length,\n                  c = this.offset,\n                  f = this.line,\n                  F = this.col;\n                for (; c > 0 && y < 0;) if (c--, y++, h.charCodeAt(c) == r.$LF) {\n                  f--;\n                  let w = h.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));\n                  F = w > 0 ? c - w : c;\n                } else F--;\n                for (; c < g && y > 0;) {\n                  let _ = h.charCodeAt(c);\n                  c++, y--, _ == r.$LF ? (f++, F = 0) : F++;\n                }\n                return new s(this.file, c, f, F);\n              }\n              getContext(y, h) {\n                let g = this.file.content,\n                  c = this.offset;\n                if (c != null) {\n                  c > g.length - 1 && (c = g.length - 1);\n                  let f = c,\n                    F = 0,\n                    _ = 0;\n                  for (; F < y && c > 0 && (c--, F++, !(g[c] == `\n` && ++_ == h)););\n                  for (F = 0, _ = 0; F < y && f < g.length - 1 && (f++, F++, !(g[f] == `\n` && ++_ == h)););\n                  return {\n                    before: g.substring(c, this.offset),\n                    after: g.substring(this.offset, f + 1)\n                  };\n                }\n                return null;\n              }\n            };\n          e.ParseLocation = s;\n          var a = class {\n            constructor(y, h) {\n              this.content = y, this.url = h;\n            }\n          };\n          e.ParseSourceFile = a;\n          var n = class {\n            constructor(y, h) {\n              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n              this.start = y, this.end = h, this.details = g;\n            }\n            toString() {\n              return this.start.file.content.substring(this.start.offset, this.end.offset);\n            }\n          };\n          e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new a(\"\", \"\"), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);\n          var u;\n          (function (y) {\n            y[y.WARNING = 0] = \"WARNING\", y[y.ERROR = 1] = \"ERROR\";\n          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));\n          var i = class {\n            constructor(y, h) {\n              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;\n              this.span = y, this.msg = h, this.level = g;\n            }\n            contextualMessage() {\n              let y = this.span.start.getContext(100, 3);\n              return y ? `${this.msg} (\"${y.before}[${u[this.level]} ->]${y.after}\")` : this.msg;\n            }\n            toString() {\n              let y = this.span.details ? `, ${this.span.details}` : \"\";\n              return `${this.contextualMessage()}: ${this.span.start}${y}`;\n            }\n          };\n          e.ParseError = i;\n          function l(y, h) {\n            let g = t.identifierModuleUrl(h),\n              c = g != null ? `in ${y} ${t.identifierName(h)} in ${g}` : `in ${y} ${t.identifierName(h)}`,\n              f = new a(\"\", c);\n            return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));\n          }\n          e.typeSourceSpan = l;\n          function p(y, h, g) {\n            let c = `in ${y} ${h} in ${g}`,\n              f = new a(\"\", c);\n            return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));\n          }\n          e.r3JitTypeSourceSpan = p;\n        }\n      }),\n      Sg = te({\n        \"src/language-html/print-preprocess.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              ParseSourceSpan: t\n            } = Ag(),\n            {\n              htmlTrim: s,\n              getLeadingAndTrailingHtmlWhitespace: a,\n              hasHtmlWhitespace: n,\n              canHaveInterpolation: u,\n              getNodeCssStyleDisplay: i,\n              isDanglingSpaceSensitiveNode: l,\n              isIndentationSensitiveNode: p,\n              isLeadingSpaceSensitiveNode: y,\n              isTrailingSpaceSensitiveNode: h,\n              isWhitespaceSensitiveNode: g,\n              isVueScriptTag: c\n            } = Rt(),\n            f = [_, w, N, I, P, T, $, D, m, x, C];\n          function F(o, d) {\n            for (let v of f) v(o, d);\n            return o;\n          }\n          function _(o) {\n            o.walk(d => {\n              if (d.type === \"element\" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === \"text\" && d.children[0].value[0] === `\n`) {\n                let v = d.children[0];\n                v.value.length === 1 ? d.removeChild(v) : v.value = v.value.slice(1);\n              }\n            });\n          }\n          function w(o) {\n            let d = v => v.type === \"element\" && v.prev && v.prev.type === \"ieConditionalStartComment\" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === \"ieConditionalEndComment\" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;\n            o.walk(v => {\n              if (v.children) for (let S = 0; S < v.children.length; S++) {\n                let b = v.children[S];\n                if (!d(b)) continue;\n                let B = b.prev,\n                  k = b.firstChild;\n                v.removeChild(B), S--;\n                let M = new t(B.sourceSpan.start, k.sourceSpan.end),\n                  R = new t(M.start, b.sourceSpan.end);\n                b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);\n              }\n            });\n          }\n          function E(o, d, v) {\n            o.walk(S => {\n              if (S.children) for (let b = 0; b < S.children.length; b++) {\n                let B = S.children[b];\n                if (B.type !== \"text\" && !d(B)) continue;\n                B.type !== \"text\" && (B.type = \"text\", B.value = v(B));\n                let k = B.prev;\n                !k || k.type !== \"text\" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);\n              }\n            });\n          }\n          function N(o) {\n            return E(o, d => d.type === \"cdata\", d => `<![CDATA[${d.value}]]>`);\n          }\n          function x(o) {\n            let d = v => v.type === \"element\" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === \"text\" && !n(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === \"text\" && v.next && v.next.type === \"text\";\n            o.walk(v => {\n              if (v.children) for (let S = 0; S < v.children.length; S++) {\n                let b = v.children[S];\n                if (!d(b)) continue;\n                let B = b.prev,\n                  k = b.next;\n                B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);\n              }\n            });\n          }\n          function I(o, d) {\n            if (d.parser === \"html\") return;\n            let v = /{{(.+?)}}/s;\n            o.walk(S => {\n              if (u(S)) for (let b of S.children) {\n                if (b.type !== \"text\") continue;\n                let B = b.sourceSpan.start,\n                  k = null,\n                  M = b.value.split(v);\n                for (let R = 0; R < M.length; R++, B = k) {\n                  let q = M[R];\n                  if (R % 2 === 0) {\n                    k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, {\n                      type: \"text\",\n                      value: q,\n                      sourceSpan: new t(B, k)\n                    });\n                    continue;\n                  }\n                  k = B.moveBy(q.length + 4), S.insertChildBefore(b, {\n                    type: \"interpolation\",\n                    sourceSpan: new t(B, k),\n                    children: q.length === 0 ? [] : [{\n                      type: \"text\",\n                      value: q,\n                      sourceSpan: new t(B.moveBy(2), k.moveBy(-2))\n                    }]\n                  });\n                }\n                S.removeChild(b);\n              }\n            });\n          }\n          function P(o) {\n            o.walk(d => {\n              if (!d.children) return;\n              if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === \"text\" && s(d.children[0].value).length === 0) {\n                d.hasDanglingSpaces = d.children.length > 0, d.children = [];\n                return;\n              }\n              let v = g(d),\n                S = p(d);\n              if (!v) for (let b = 0; b < d.children.length; b++) {\n                let B = d.children[b];\n                if (B.type !== \"text\") continue;\n                let {\n                    leadingWhitespace: k,\n                    text: M,\n                    trailingWhitespace: R\n                  } = a(B.value),\n                  q = B.prev,\n                  J = B.next;\n                M ? (B.value = M, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q && (q.hasTrailingSpaces = !0), B.hasLeadingSpaces = !0), R && (B.hasTrailingSpaces = !0, J && (J.hasLeadingSpaces = !0))) : (d.removeChild(B), b--, (k || R) && (q && (q.hasTrailingSpaces = !0), J && (J.hasLeadingSpaces = !0)));\n              }\n              d.isWhitespaceSensitive = v, d.isIndentationSensitive = S;\n            });\n          }\n          function $(o) {\n            o.walk(d => {\n              d.isSelfClosing = !d.children || d.type === \"element\" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);\n            });\n          }\n          function D(o, d) {\n            o.walk(v => {\n              v.type === \"element\" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\\s*\\/\\s*\\/\\s*>$/.test(d.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));\n            });\n          }\n          function T(o, d) {\n            o.walk(v => {\n              v.cssDisplay = i(v, d);\n            });\n          }\n          function m(o, d) {\n            o.walk(v => {\n              let {\n                children: S\n              } = v;\n              if (S) {\n                if (S.length === 0) {\n                  v.isDanglingSpaceSensitive = l(v);\n                  return;\n                }\n                for (let b of S) b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h(b, d);\n                for (let b = 0; b < S.length; b++) {\n                  let B = S[b];\n                  B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;\n                }\n              }\n            });\n          }\n          function C(o, d) {\n            if (d.parser === \"vue\") {\n              let v = o.children.find(b => c(b, d));\n              if (!v) return;\n              let {\n                lang: S\n              } = v.attrMap;\n              (S === \"ts\" || S === \"typescript\") && (d.__should_parse_vue_template_with_ts = !0);\n            }\n          }\n          r.exports = F;\n        }\n      }),\n      xg = te({\n        \"src/language-html/pragma.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(a) {\n            return /^\\s*<!--\\s*@(?:format|prettier)\\s*-->/.test(a);\n          }\n          function s(a) {\n            return `<!-- @format -->\n\n` + a.replace(/^\\s*\\n/, \"\");\n          }\n          r.exports = {\n            hasPragma: t,\n            insertPragma: s\n          };\n        }\n      }),\n      au = te({\n        \"src/language-html/loc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(a) {\n            return a.sourceSpan.start.offset;\n          }\n          function s(a) {\n            return a.sourceSpan.end.offset;\n          }\n          r.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      ur = te({\n        \"src/language-html/print/tag.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Zt(),\n            {\n              isNonEmptyArray: s\n            } = Ue(),\n            {\n              builders: {\n                indent: a,\n                join: n,\n                line: u,\n                softline: i,\n                hardline: l\n              },\n              utils: {\n                replaceTextEndOfLine: p\n              }\n            } = qe(),\n            {\n              locStart: y,\n              locEnd: h\n            } = au(),\n            {\n              isTextLikeNode: g,\n              getLastDescendant: c,\n              isPreLikeNode: f,\n              hasPrettierIgnore: F,\n              shouldPreserveContent: _,\n              isVueSfcBlock: w\n            } = Rt();\n          function E(L, Q) {\n            return [L.isSelfClosing ? \"\" : N(L, Q), x(L, Q)];\n          }\n          function N(L, Q) {\n            return L.lastChild && o(L.lastChild) ? \"\" : [I(L, Q), $(L, Q)];\n          }\n          function x(L, Q) {\n            return (L.next ? m(L.next) : C(L.parent)) ? \"\" : [D(L, Q), P(L, Q)];\n          }\n          function I(L, Q) {\n            return C(L) ? D(L.lastChild, Q) : \"\";\n          }\n          function P(L, Q) {\n            return o(L) ? $(L.parent, Q) : d(L) ? q(L.next) : \"\";\n          }\n          function $(L, Q) {\n            if (t(!L.isSelfClosing), T(L, Q)) return \"\";\n            switch (L.type) {\n              case \"ieConditionalComment\":\n                return \"<!\";\n              case \"element\":\n                if (L.hasHtmComponentClosingTag) return \"<//\";\n              default:\n                return `</${L.rawName}`;\n            }\n          }\n          function D(L, Q) {\n            if (T(L, Q)) return \"\";\n            switch (L.type) {\n              case \"ieConditionalComment\":\n              case \"ieConditionalEndComment\":\n                return \"[endif]-->\";\n              case \"ieConditionalStartComment\":\n                return \"]><!-->\";\n              case \"interpolation\":\n                return \"}}\";\n              case \"element\":\n                if (L.isSelfClosing) return \"/>\";\n              default:\n                return \">\";\n            }\n          }\n          function T(L, Q) {\n            return !L.isSelfClosing && !L.endSourceSpan && (F(L) || _(L.parent, Q));\n          }\n          function m(L) {\n            return L.prev && L.prev.type !== \"docType\" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;\n          }\n          function C(L) {\n            return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c(L.lastChild)) && !f(L);\n          }\n          function o(L) {\n            return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c(L));\n          }\n          function d(L) {\n            return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;\n          }\n          function v(L) {\n            let Q = L.trim().match(/^prettier-ignore-attribute(?:\\s+(.+))?$/s);\n            return Q ? Q[1] ? Q[1].split(/\\s+/) : !0 : !1;\n          }\n          function S(L) {\n            return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;\n          }\n          function b(L, Q, V) {\n            let j = L.getValue();\n            if (!s(j.attrs)) return j.isSelfClosing ? \" \" : \"\";\n            let Y = j.prev && j.prev.type === \"comment\" && v(j.prev.value),\n              ie = typeof Y == \"boolean\" ? () => Y : Array.isArray(Y) ? ue => Y.includes(ue.rawName) : () => !1,\n              ee = L.map(ue => {\n                let Fe = ue.getValue();\n                return ie(Fe) ? p(Q.originalText.slice(y(Fe), h(Fe))) : V();\n              }, \"attrs\"),\n              ce = j.type === \"element\" && j.fullName === \"script\" && j.attrs.length === 1 && j.attrs[0].fullName === \"src\" && j.children.length === 0,\n              K = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u,\n              de = [a([ce ? \" \" : u, n(K, ee)])];\n            return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? \" \" : \"\") : de.push(Q.bracketSameLine ? j.isSelfClosing ? \" \" : \"\" : j.isSelfClosing ? u : i), de;\n          }\n          function B(L) {\n            return L.firstChild && S(L.firstChild) ? \"\" : J(L);\n          }\n          function k(L, Q, V) {\n            let j = L.getValue();\n            return [M(j, Q), b(L, Q, V), j.isSelfClosing ? \"\" : B(j)];\n          }\n          function M(L, Q) {\n            return L.prev && d(L.prev) ? \"\" : [R(L, Q), q(L)];\n          }\n          function R(L, Q) {\n            return S(L) ? J(L.parent) : m(L) ? D(L.prev, Q) : \"\";\n          }\n          function q(L) {\n            switch (L.type) {\n              case \"ieConditionalComment\":\n              case \"ieConditionalStartComment\":\n                return `<!--[if ${L.condition}`;\n              case \"ieConditionalEndComment\":\n                return \"<!--<!\";\n              case \"interpolation\":\n                return \"{{\";\n              case \"docType\":\n                return \"<!DOCTYPE\";\n              case \"element\":\n                if (L.condition) return `<!--[if ${L.condition}]><!--><${L.rawName}`;\n              default:\n                return `<${L.rawName}`;\n            }\n          }\n          function J(L) {\n            switch (t(!L.isSelfClosing), L.type) {\n              case \"ieConditionalComment\":\n                return \"]>\";\n              case \"element\":\n                if (L.condition) return \"><!--<![endif]-->\";\n              default:\n                return \">\";\n            }\n          }\n          r.exports = {\n            printClosingTag: E,\n            printClosingTagStart: N,\n            printClosingTagStartMarker: $,\n            printClosingTagEndMarker: D,\n            printClosingTagSuffix: P,\n            printClosingTagEnd: x,\n            needsToBorrowLastChildClosingTagEndMarker: C,\n            needsToBorrowParentClosingTagStartMarker: o,\n            needsToBorrowPrevClosingTagEndMarker: m,\n            printOpeningTag: k,\n            printOpeningTagStart: M,\n            printOpeningTagPrefix: R,\n            printOpeningTagStartMarker: q,\n            printOpeningTagEndMarker: J,\n            needsToBorrowNextOpeningTagStartMarker: d,\n            needsToBorrowParentOpeningTagEndMarker: S\n          };\n        }\n      }),\n      bg = te({\n        \"node_modules/parse-srcset/src/parse-srcset.js\"(e, r) {\n          ne(), function (t, s) {\n             true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (s),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n          }(e, function () {\n            return function (t, s) {\n              var a = s && s.logger || console;\n              function n($) {\n                return $ === \" \" || $ === \"\t\" || $ === `\n` || $ === \"\\f\" || $ === \"\\r\";\n              }\n              function u($) {\n                var D,\n                  T = $.exec(t.substring(N));\n                if (T) return D = T[0], N += D.length, D;\n              }\n              for (var i = t.length, l = /^[ \\t\\n\\r\\u000c]+/, p = /^[, \\t\\n\\r\\u000c]+/, y = /^[^ \\t\\n\\r\\u000c]+/, h = /[,]+$/, g = /^\\d+$/, c = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, F, _, w, E, N = 0, x = [];;) {\n                if (u(p), N >= i) return x;\n                f = u(y), F = [], f.slice(-1) === \",\" ? (f = f.replace(h, \"\"), P()) : I();\n              }\n              function I() {\n                for (u(l), _ = \"\", w = \"in descriptor\";;) {\n                  if (E = t.charAt(N), w === \"in descriptor\") {\n                    if (n(E)) _ && (F.push(_), _ = \"\", w = \"after descriptor\");else if (E === \",\") {\n                      N += 1, _ && F.push(_), P();\n                      return;\n                    } else if (E === \"(\") _ = _ + E, w = \"in parens\";else if (E === \"\") {\n                      _ && F.push(_), P();\n                      return;\n                    } else _ = _ + E;\n                  } else if (w === \"in parens\") {\n                    if (E === \")\") _ = _ + E, w = \"in descriptor\";else if (E === \"\") {\n                      F.push(_), P();\n                      return;\n                    } else _ = _ + E;\n                  } else if (w === \"after descriptor\" && !n(E)) if (E === \"\") {\n                    P();\n                    return;\n                  } else w = \"in descriptor\", N -= 1;\n                  N += 1;\n                }\n              }\n              function P() {\n                var $ = !1,\n                  D,\n                  T,\n                  m,\n                  C,\n                  o = {},\n                  d,\n                  v,\n                  S,\n                  b,\n                  B;\n                for (C = 0; C < F.length; C++) d = F[C], v = d[d.length - 1], S = d.substring(0, d.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === \"w\" ? ((D || T) && ($ = !0), b === 0 ? $ = !0 : D = b) : c.test(S) && v === \"x\" ? ((D || T || m) && ($ = !0), B < 0 ? $ = !0 : T = B) : g.test(S) && v === \"h\" ? ((m || T) && ($ = !0), b === 0 ? $ = !0 : m = b) : $ = !0;\n                $ ? a && a.error && a.error(\"Invalid srcset descriptor found in '\" + t + \"' at '\" + d + \"'.\") : (o.url = f, D && (o.w = D), T && (o.d = T), m && (o.h = m), x.push(o));\n              }\n            };\n          });\n        }\n      }),\n      Tg = te({\n        \"src/language-html/syntax-attribute.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = bg(),\n            {\n              builders: {\n                ifBreak: s,\n                join: a,\n                line: n\n              }\n            } = qe();\n          function u(l) {\n            let p = t(l, {\n                logger: {\n                  error(I) {\n                    throw new Error(I);\n                  }\n                }\n              }),\n              y = p.some(I => {\n                let {\n                  w: P\n                } = I;\n                return P;\n              }),\n              h = p.some(I => {\n                let {\n                  h: P\n                } = I;\n                return P;\n              }),\n              g = p.some(I => {\n                let {\n                  d: P\n                } = I;\n                return P;\n              });\n            if (y + h + g > 1) throw new Error(\"Mixed descriptor in srcset is not supported\");\n            let c = y ? \"w\" : h ? \"h\" : \"d\",\n              f = y ? \"w\" : h ? \"h\" : \"x\",\n              F = I => Math.max(...I),\n              _ = p.map(I => I.url),\n              w = F(_.map(I => I.length)),\n              E = p.map(I => I[c]).map(I => I ? I.toString() : \"\"),\n              N = E.map(I => {\n                let P = I.indexOf(\".\");\n                return P === -1 ? I.length : P;\n              }),\n              x = F(N);\n            return a([\",\", n], _.map((I, P) => {\n              let $ = [I],\n                D = E[P];\n              if (D) {\n                let T = w - I.length + 1,\n                  m = x - N[P],\n                  C = \" \".repeat(T + m);\n                $.push(s(C, \" \"), D + f);\n              }\n              return $;\n            }));\n          }\n          function i(l) {\n            return l.trim().split(/\\s+/).join(\" \");\n          }\n          r.exports = {\n            printImgSrcset: u,\n            printClassNames: i\n          };\n        }\n      }),\n      Bg = te({\n        \"src/language-html/syntax-vue.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            builders: {\n              group: t\n            }\n          } = qe();\n          function s(i, l) {\n            let {\n              left: p,\n              operator: y,\n              right: h\n            } = a(i);\n            return [t(l(`function _(${p}) {}`, {\n              parser: \"babel\",\n              __isVueForBindingLeft: !0\n            })), \" \", y, \" \", l(h, {\n              parser: \"__js_expression\"\n            }, {\n              stripTrailingHardline: !0\n            })];\n          }\n          function a(i) {\n            let l = /(.*?)\\s+(in|of)\\s+(.*)/s,\n              p = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/,\n              y = /^\\(|\\)$/g,\n              h = i.match(l);\n            if (!h) return;\n            let g = {};\n            if (g.for = h[3].trim(), !g.for) return;\n            let c = h[1].trim().replace(y, \"\"),\n              f = c.match(p);\n            f ? (g.alias = c.replace(p, \"\"), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = c;\n            let F = [g.alias, g.iterator1, g.iterator2];\n            if (!F.some((_, w) => !_ && (w === 0 || F.slice(w + 1).some(Boolean)))) return {\n              left: F.filter(Boolean).join(\",\"),\n              operator: h[2],\n              right: g.for\n            };\n          }\n          function n(i, l) {\n            return l(`function _(${i}) {}`, {\n              parser: \"babel\",\n              __isVueBindings: !0\n            });\n          }\n          function u(i) {\n            let l = /^(?:[\\w$]+|\\([^)]*\\))\\s*=>|^function\\s*\\(/,\n              p = /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\['[^']*']|\\[\"[^\"]*\"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/,\n              y = i.trim();\n            return l.test(y) || p.test(y);\n          }\n          r.exports = {\n            isVueEventBindingExpression: u,\n            printVueFor: s,\n            printVueBindings: n\n          };\n        }\n      }),\n      Lo = te({\n        \"src/language-html/get-node-content.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            needsToBorrowParentClosingTagStartMarker: t,\n            printClosingTagStartMarker: s,\n            needsToBorrowLastChildClosingTagEndMarker: a,\n            printClosingTagEndMarker: n,\n            needsToBorrowParentOpeningTagEndMarker: u,\n            printOpeningTagEndMarker: i\n          } = ur();\n          function l(p, y) {\n            let h = p.startSourceSpan.end.offset;\n            p.firstChild && u(p.firstChild) && (h -= i(p).length);\n            let g = p.endSourceSpan.start.offset;\n            return p.lastChild && t(p.lastChild) ? g += s(p, y).length : a(p) && (g -= n(p.lastChild, y).length), y.originalText.slice(h, g);\n          }\n          r.exports = l;\n        }\n      }),\n      Ng = te({\n        \"src/language-html/embed.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                breakParent: t,\n                group: s,\n                hardline: a,\n                indent: n,\n                line: u,\n                fill: i,\n                softline: l\n              },\n              utils: {\n                mapDoc: p,\n                replaceTextEndOfLine: y\n              }\n            } = qe(),\n            h = su(),\n            {\n              printClosingTag: g,\n              printClosingTagSuffix: c,\n              needsToBorrowPrevClosingTagEndMarker: f,\n              printOpeningTagPrefix: F,\n              printOpeningTag: _\n            } = ur(),\n            {\n              printImgSrcset: w,\n              printClassNames: E\n            } = Tg(),\n            {\n              printVueFor: N,\n              printVueBindings: x,\n              isVueEventBindingExpression: I\n            } = Bg(),\n            {\n              isScriptLikeTag: P,\n              isVueNonHtmlBlock: $,\n              inferScriptParser: D,\n              htmlTrimPreserveIndentation: T,\n              dedentString: m,\n              unescapeQuoteEntities: C,\n              isVueSlotAttribute: o,\n              isVueSfcBindingsAttribute: d,\n              getTextValueParts: v\n            } = Rt(),\n            S = Lo();\n          function b(k, M, R) {\n            let q = ee => new RegExp(ee.join(\"|\")).test(k.fullName),\n              J = () => C(k.value),\n              L = !1,\n              Q = (ee, ce) => {\n                let W = ee.type === \"NGRoot\" ? ee.node.type === \"NGMicrosyntax\" && ee.node.body.length === 1 && ee.node.body[0].type === \"NGMicrosyntaxExpression\" ? ee.node.body[0].expression : ee.node : ee.type === \"JsExpressionRoot\" ? ee.node : ee;\n                W && (W.type === \"ObjectExpression\" || W.type === \"ArrayExpression\" || ce.parser === \"__vue_expression\" && (W.type === \"TemplateLiteral\" || W.type === \"StringLiteral\")) && (L = !0);\n              },\n              V = ee => s(ee),\n              j = function (ee) {\n                let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n                return s([n([l, ee]), ce ? l : \"\"]);\n              },\n              Y = ee => L ? V(ee) : j(ee),\n              ie = (ee, ce) => M(ee, Object.assign({\n                __onHtmlBindingRoot: Q,\n                __embeddedInHtml: !0\n              }, ce));\n            if (k.fullName === \"srcset\" && (k.parent.fullName === \"img\" || k.parent.fullName === \"source\")) return j(w(J()));\n            if (k.fullName === \"class\" && !R.parentParser) {\n              let ee = J();\n              if (!ee.includes(\"{{\")) return E(ee);\n            }\n            if (k.fullName === \"style\" && !R.parentParser) {\n              let ee = J();\n              if (!ee.includes(\"{{\")) return j(ie(ee, {\n                parser: \"css\",\n                __isHTMLStyleAttribute: !0\n              }));\n            }\n            if (R.parser === \"vue\") {\n              if (k.fullName === \"v-for\") return N(J(), ie);\n              if (o(k) || d(k, R)) return x(J(), ie);\n              let ee = [\"^@\", \"^v-on:\"],\n                ce = [\"^:\", \"^v-bind:\"],\n                W = [\"^v-\"];\n              if (q(ee)) {\n                let K = J(),\n                  de = I(K) ? \"__js_expression\" : R.__should_parse_vue_template_with_ts ? \"__vue_ts_event_binding\" : \"__vue_event_binding\";\n                return Y(ie(K, {\n                  parser: de\n                }));\n              }\n              if (q(ce)) return Y(ie(J(), {\n                parser: \"__vue_expression\"\n              }));\n              if (q(W)) return Y(ie(J(), {\n                parser: \"__js_expression\"\n              }));\n            }\n            if (R.parser === \"angular\") {\n              let ee = (z, U) => ie(z, Object.assign(Object.assign({}, U), {}, {\n                  trailingComma: \"none\"\n                })),\n                ce = [\"^\\\\*\"],\n                W = [\"^\\\\(.+\\\\)$\", \"^on-\"],\n                K = [\"^\\\\[.+\\\\]$\", \"^bind(on)?-\", \"^ng-(if|show|hide|class|style)$\"],\n                de = [\"^i18n(-.+)?$\"];\n              if (q(W)) return Y(ee(J(), {\n                parser: \"__ng_action\"\n              }));\n              if (q(K)) return Y(ee(J(), {\n                parser: \"__ng_binding\"\n              }));\n              if (q(de)) {\n                let z = J().trim();\n                return j(i(v(k, z)), !z.includes(\"@@\"));\n              }\n              if (q(ce)) return Y(ee(J(), {\n                parser: \"__ng_directive\"\n              }));\n              let ue = /{{(.+?)}}/s,\n                Fe = J();\n              if (ue.test(Fe)) {\n                let z = [];\n                for (let [U, Z] of Fe.split(ue).entries()) if (U % 2 === 0) z.push(y(Z));else try {\n                  z.push(s([\"{{\", n([u, ee(Z, {\n                    parser: \"__ng_interpolation\",\n                    __isInHtmlInterpolation: !0\n                  })]), u, \"}}\"]));\n                } catch {\n                  z.push(\"{{\", y(Z), \"}}\");\n                }\n                return s(z);\n              }\n            }\n            return null;\n          }\n          function B(k, M, R, q) {\n            let J = k.getValue();\n            switch (J.type) {\n              case \"element\":\n                {\n                  if (P(J) || J.type === \"interpolation\") return;\n                  if (!J.isSelfClosing && $(J, q)) {\n                    let L = D(J, q);\n                    if (!L) return;\n                    let Q = S(J, q),\n                      V = /^\\s*$/.test(Q),\n                      j = \"\";\n                    return V || (j = R(T(Q), {\n                      parser: L,\n                      __embeddedInHtml: !0\n                    }, {\n                      stripTrailingHardline: !0\n                    }), V = j === \"\"), [F(J, q), s(_(k, q, M)), V ? \"\" : a, j, V ? \"\" : a, g(J, q), c(J, q)];\n                  }\n                  break;\n                }\n              case \"text\":\n                {\n                  if (P(J.parent)) {\n                    let L = D(J.parent, q);\n                    if (L) {\n                      let Q = L === \"markdown\" ? m(J.value.replace(/^[^\\S\\n]*\\n/, \"\")) : J.value,\n                        V = {\n                          parser: L,\n                          __embeddedInHtml: !0\n                        };\n                      if (q.parser === \"html\" && L === \"babel\") {\n                        let j = \"script\",\n                          {\n                            attrMap: Y\n                          } = J.parent;\n                        Y && (Y.type === \"module\" || Y.type === \"text/babel\" && Y[\"data-type\"] === \"module\") && (j = \"module\"), V.__babelSourceType = j;\n                      }\n                      return [t, F(J, q), R(Q, V, {\n                        stripTrailingHardline: !0\n                      }), c(J, q)];\n                    }\n                  } else if (J.parent.type === \"interpolation\") {\n                    let L = {\n                      __isInHtmlInterpolation: !0,\n                      __embeddedInHtml: !0\n                    };\n                    return q.parser === \"angular\" ? (L.parser = \"__ng_interpolation\", L.trailingComma = \"none\") : q.parser === \"vue\" ? L.parser = q.__should_parse_vue_template_with_ts ? \"__vue_ts_expression\" : \"__vue_expression\" : L.parser = \"__js_expression\", [n([u, R(J.value, L, {\n                      stripTrailingHardline: !0\n                    })]), J.parent.next && f(J.parent.next) ? \" \" : u];\n                  }\n                  break;\n                }\n              case \"attribute\":\n                {\n                  if (!J.value) break;\n                  if (/^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset))) return [J.rawName, \"=\", J.value];\n                  if (q.parser === \"lwc\" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset))) return [J.rawName, \"=\", J.value];\n                  let L = b(J, (Q, V) => R(Q, Object.assign({\n                    __isInHtmlAttribute: !0,\n                    __embeddedInHtml: !0\n                  }, V), {\n                    stripTrailingHardline: !0\n                  }), q);\n                  if (L) return [J.rawName, '=\"', s(p(L, Q => typeof Q == \"string\" ? Q.replace(/\"/g, \"&quot;\") : Q)), '\"'];\n                  break;\n                }\n              case \"front-matter\":\n                return h(J, R);\n            }\n          }\n          r.exports = B;\n        }\n      }),\n      Oo = te({\n        \"src/language-html/print/children.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                breakParent: t,\n                group: s,\n                ifBreak: a,\n                line: n,\n                softline: u,\n                hardline: i\n              },\n              utils: {\n                replaceTextEndOfLine: l\n              }\n            } = qe(),\n            {\n              locStart: p,\n              locEnd: y\n            } = au(),\n            {\n              forceBreakChildren: h,\n              forceNextEmptyLine: g,\n              isTextLikeNode: c,\n              hasPrettierIgnore: f,\n              preferHardlineAsLeadingSpaces: F\n            } = Rt(),\n            {\n              printOpeningTagPrefix: _,\n              needsToBorrowNextOpeningTagStartMarker: w,\n              printOpeningTagStartMarker: E,\n              needsToBorrowPrevClosingTagEndMarker: N,\n              printClosingTagEndMarker: x,\n              printClosingTagSuffix: I,\n              needsToBorrowParentClosingTagStartMarker: P\n            } = ur();\n          function $(m, C, o) {\n            let d = m.getValue();\n            return f(d) ? [_(d, C), ...l(C.originalText.slice(p(d) + (d.prev && w(d.prev) ? E(d).length : 0), y(d) - (d.next && N(d.next) ? x(d, C).length : 0))), I(d, C)] : o();\n          }\n          function D(m, C) {\n            return c(m) && c(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? F(C) ? i : n : \"\" : F(C) ? i : u : w(m) && (f(C) || C.firstChild || C.isSelfClosing || C.type === \"element\" && C.attrs.length > 0) || m.type === \"element\" && m.isSelfClosing && N(C) ? \"\" : !C.isLeadingSpaceSensitive || F(C) || N(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;\n          }\n          function T(m, C, o) {\n            let d = m.getValue();\n            if (h(d)) return [t, ...m.map(S => {\n              let b = S.getValue(),\n                B = b.prev ? D(b.prev, b) : \"\";\n              return [B ? [B, g(b.prev) ? i : \"\"] : \"\", $(S, C, o)];\n            }, \"children\")];\n            let v = d.children.map(() => Symbol(\"\"));\n            return m.map((S, b) => {\n              let B = S.getValue();\n              if (c(B)) {\n                if (B.prev && c(B.prev)) {\n                  let Q = D(B.prev, B);\n                  if (Q) return g(B.prev) ? [i, i, $(S, C, o)] : [Q, $(S, C, o)];\n                }\n                return $(S, C, o);\n              }\n              let k = [],\n                M = [],\n                R = [],\n                q = [],\n                J = B.prev ? D(B.prev, B) : \"\",\n                L = B.next ? D(B, B.next) : \"\";\n              return J && (g(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c(B.prev) ? M.push(J) : M.push(a(\"\", u, {\n                groupId: v[b - 1]\n              }))), L && (g(B) ? c(B.next) && q.push(i, i) : L === i ? c(B.next) && q.push(i) : R.push(L)), [...k, s([...M, s([$(S, C, o), ...R], {\n                id: v[b]\n              })]), ...q];\n            }, \"children\");\n          }\n          r.exports = {\n            printChildren: T\n          };\n        }\n      }),\n      wg = te({\n        \"src/language-html/print/element.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                breakParent: t,\n                dedentToRoot: s,\n                group: a,\n                ifBreak: n,\n                indentIfBreak: u,\n                indent: i,\n                line: l,\n                softline: p\n              },\n              utils: {\n                replaceTextEndOfLine: y\n              }\n            } = qe(),\n            h = Lo(),\n            {\n              shouldPreserveContent: g,\n              isScriptLikeTag: c,\n              isVueCustomBlock: f,\n              countParents: F,\n              forceBreakContent: _\n            } = Rt(),\n            {\n              printOpeningTagPrefix: w,\n              printOpeningTag: E,\n              printClosingTagSuffix: N,\n              printClosingTag: x,\n              needsToBorrowPrevClosingTagEndMarker: I,\n              needsToBorrowLastChildClosingTagEndMarker: P\n            } = ur(),\n            {\n              printChildren: $\n            } = Oo();\n          function D(T, m, C) {\n            let o = T.getValue();\n            if (g(o, m)) return [w(o, m), a(E(T, m, C)), ...y(h(o, m)), ...x(o, m), N(o, m)];\n            let d = o.children.length === 1 && o.firstChild.type === \"interpolation\" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces,\n              v = Symbol(\"element-attr-group-id\"),\n              S = M => a([a(E(T, m, C), {\n                id: v\n              }), M, x(o, m)]),\n              b = M => d ? u(M, {\n                groupId: v\n              }) : (c(o) || f(o, m)) && o.parent.type === \"root\" && m.parser === \"vue\" && !m.vueIndentScriptAndStyle ? M : i(M),\n              B = () => d ? n(p, \"\", {\n                groupId: v\n              }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === \"text\" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p,\n              k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? \" \" : \"\" : d ? n(p, \"\", {\n                groupId: v\n              }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === \"comment\" || o.lastChild.type === \"text\" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\\\n[\\\\t ]{${m.tabWidth * F(T, R => R.parent && R.parent.type !== \"root\")}}$`).test(o.lastChild.value) ? \"\" : p;\n            return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : \"\") : S([_(o) ? t : \"\", b([B(), $(T, m, C)]), k()]);\n          }\n          r.exports = {\n            printElement: D\n          };\n        }\n      }),\n      _g = te({\n        \"src/language-html/printer-html.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                fill: t,\n                group: s,\n                hardline: a,\n                literalline: n\n              },\n              utils: {\n                cleanDoc: u,\n                getDocParts: i,\n                isConcat: l,\n                replaceTextEndOfLine: p\n              }\n            } = qe(),\n            y = gg(),\n            {\n              countChars: h,\n              unescapeQuoteEntities: g,\n              getTextValueParts: c\n            } = Rt(),\n            f = Sg(),\n            {\n              insertPragma: F\n            } = xg(),\n            {\n              locStart: _,\n              locEnd: w\n            } = au(),\n            E = Ng(),\n            {\n              printClosingTagSuffix: N,\n              printClosingTagEnd: x,\n              printOpeningTagPrefix: I,\n              printOpeningTagStart: P\n            } = ur(),\n            {\n              printElement: $\n            } = wg(),\n            {\n              printChildren: D\n            } = Oo();\n          function T(m, C, o) {\n            let d = m.getValue();\n            switch (d.type) {\n              case \"front-matter\":\n                return p(d.raw);\n              case \"root\":\n                return C.__onHtmlRoot && C.__onHtmlRoot(d), [s(D(m, C, o)), a];\n              case \"element\":\n              case \"ieConditionalComment\":\n                return $(m, C, o);\n              case \"ieConditionalStartComment\":\n              case \"ieConditionalEndComment\":\n                return [P(d), x(d)];\n              case \"interpolation\":\n                return [P(d, C), ...m.map(o, \"children\"), x(d, C)];\n              case \"text\":\n                {\n                  if (d.parent.type === \"interpolation\") {\n                    let S = /\\n[^\\S\\n]*$/,\n                      b = S.test(d.value),\n                      B = b ? d.value.replace(S, \"\") : d.value;\n                    return [...p(B), b ? a : \"\"];\n                  }\n                  let v = u([I(d, C), ...c(d), N(d, C)]);\n                  return l(v) || v.type === \"fill\" ? t(i(v)) : v;\n                }\n              case \"docType\":\n                return [s([P(d, C), \" \", d.value.replace(/^html\\b/i, \"html\").replace(/\\s+/g, \" \")]), x(d, C)];\n              case \"comment\":\n                return [I(d, C), ...p(C.originalText.slice(_(d), w(d)), n), N(d, C)];\n              case \"attribute\":\n                {\n                  if (d.value === null) return d.rawName;\n                  let v = g(d.value),\n                    S = h(v, \"'\"),\n                    b = h(v, '\"'),\n                    B = S < b ? \"'\" : '\"';\n                  return [d.rawName, \"=\", B, ...p(B === '\"' ? v.replace(/\"/g, \"&quot;\") : v.replace(/'/g, \"&apos;\")), B];\n                }\n              default:\n                throw new Error(`Unexpected node type ${d.type}`);\n            }\n          }\n          r.exports = {\n            preprocess: f,\n            print: T,\n            insertPragma: F,\n            massageAstNode: y,\n            embed: E\n          };\n        }\n      }),\n      Pg = te({\n        \"src/language-html/options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Mt(),\n            s = \"HTML\";\n          r.exports = {\n            bracketSameLine: t.bracketSameLine,\n            htmlWhitespaceSensitivity: {\n              since: \"1.15.0\",\n              category: s,\n              type: \"choice\",\n              default: \"css\",\n              description: \"How to handle whitespaces in HTML.\",\n              choices: [{\n                value: \"css\",\n                description: \"Respect the default value of CSS display property.\"\n              }, {\n                value: \"strict\",\n                description: \"Whitespaces are considered sensitive.\"\n              }, {\n                value: \"ignore\",\n                description: \"Whitespaces are considered insensitive.\"\n              }]\n            },\n            singleAttributePerLine: t.singleAttributePerLine,\n            vueIndentScriptAndStyle: {\n              since: \"1.19.0\",\n              category: s,\n              type: \"boolean\",\n              default: !1,\n              description: \"Indent script and style tags in Vue files.\"\n            }\n          };\n        }\n      }),\n      Ig = te({\n        \"src/language-html/parsers.js\"() {\n          ne();\n        }\n      }),\n      On = te({\n        \"node_modules/linguist-languages/data/HTML.json\"(e, r) {\n          r.exports = {\n            name: \"HTML\",\n            type: \"markup\",\n            tmScope: \"text.html.basic\",\n            aceMode: \"html\",\n            codemirrorMode: \"htmlmixed\",\n            codemirrorMimeType: \"text/html\",\n            color: \"#e34c26\",\n            aliases: [\"xhtml\"],\n            extensions: [\".html\", \".hta\", \".htm\", \".html.hl\", \".inc\", \".xht\", \".xhtml\"],\n            languageId: 146\n          };\n        }\n      }),\n      kg = te({\n        \"node_modules/linguist-languages/data/Vue.json\"(e, r) {\n          r.exports = {\n            name: \"Vue\",\n            type: \"markup\",\n            color: \"#41b883\",\n            extensions: [\".vue\"],\n            tmScope: \"text.html.vue\",\n            aceMode: \"html\",\n            languageId: 391\n          };\n        }\n      }),\n      Lg = te({\n        \"src/language-html/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = _t(),\n            s = _g(),\n            a = Pg(),\n            n = Ig(),\n            u = [t(On(), () => ({\n              name: \"Angular\",\n              since: \"1.15.0\",\n              parsers: [\"angular\"],\n              vscodeLanguageIds: [\"html\"],\n              extensions: [\".component.html\"],\n              filenames: []\n            })), t(On(), l => ({\n              since: \"1.15.0\",\n              parsers: [\"html\"],\n              vscodeLanguageIds: [\"html\"],\n              extensions: [...l.extensions, \".mjml\"]\n            })), t(On(), () => ({\n              name: \"Lightning Web Components\",\n              since: \"1.17.0\",\n              parsers: [\"lwc\"],\n              vscodeLanguageIds: [\"html\"],\n              extensions: [],\n              filenames: []\n            })), t(kg(), () => ({\n              since: \"1.10.0\",\n              parsers: [\"vue\"],\n              vscodeLanguageIds: [\"vue\"]\n            }))],\n            i = {\n              html: s\n            };\n          r.exports = {\n            languages: u,\n            printers: i,\n            options: a,\n            parsers: n\n          };\n        }\n      }),\n      Og = te({\n        \"src/language-yaml/pragma.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(n) {\n            return /^\\s*@(?:prettier|format)\\s*$/.test(n);\n          }\n          function s(n) {\n            return /^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(n);\n          }\n          function a(n) {\n            return `# @format\n\n${n}`;\n          }\n          r.exports = {\n            isPragma: t,\n            hasPragma: s,\n            insertPragma: a\n          };\n        }\n      }),\n      jg = te({\n        \"src/language-yaml/loc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(a) {\n            return a.position.start.offset;\n          }\n          function s(a) {\n            return a.position.end.offset;\n          }\n          r.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      qg = te({\n        \"src/language-yaml/embed.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          function t(s, a, n, u) {\n            if (s.getValue().type === \"root\" && u.filepath && /(?:[/\\\\]|^)\\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath)) return n(u.originalText, Object.assign(Object.assign({}, u), {}, {\n              parser: \"json\"\n            }));\n          }\n          r.exports = t;\n        }\n      }),\n      $t = te({\n        \"src/language-yaml/utils.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            getLast: t,\n            isNonEmptyArray: s\n          } = Ue();\n          function a(D, T) {\n            let m = 0,\n              C = D.stack.length - 1;\n            for (let o = 0; o < C; o++) {\n              let d = D.stack[o];\n              n(d) && T(d) && m++;\n            }\n            return m;\n          }\n          function n(D, T) {\n            return D && typeof D.type == \"string\" && (!T || T.includes(D.type));\n          }\n          function u(D, T, m) {\n            return T(\"children\" in D ? Object.assign(Object.assign({}, D), {}, {\n              children: D.children.map(C => u(C, T, D))\n            }) : D, m);\n          }\n          function i(D, T, m) {\n            Object.defineProperty(D, T, {\n              get: m,\n              enumerable: !1\n            });\n          }\n          function l(D, T) {\n            let m = 0,\n              C = T.length;\n            for (let o = D.position.end.offset - 1; o < C; o++) {\n              let d = T[o];\n              if (d === `\n` && m++, m === 1 && /\\S/.test(d)) return !1;\n              if (m === 2) return !0;\n            }\n            return !1;\n          }\n          function p(D) {\n            switch (D.getValue().type) {\n              case \"tag\":\n              case \"anchor\":\n              case \"comment\":\n                return !1;\n            }\n            let m = D.stack.length;\n            for (let C = 1; C < m; C++) {\n              let o = D.stack[C],\n                d = D.stack[C - 1];\n              if (Array.isArray(d) && typeof o == \"number\" && o !== d.length - 1) return !1;\n            }\n            return !0;\n          }\n          function y(D) {\n            return s(D.children) ? y(t(D.children)) : D;\n          }\n          function h(D) {\n            return D.value.trim() === \"prettier-ignore\";\n          }\n          function g(D) {\n            let T = D.getValue();\n            if (T.type === \"documentBody\") {\n              let m = D.getParentNode();\n              return N(m.head) && h(t(m.head.endComments));\n            }\n            return F(T) && h(t(T.leadingComments));\n          }\n          function c(D) {\n            return !s(D.children) && !f(D);\n          }\n          function f(D) {\n            return F(D) || _(D) || w(D) || E(D) || N(D);\n          }\n          function F(D) {\n            return s(D == null ? void 0 : D.leadingComments);\n          }\n          function _(D) {\n            return s(D == null ? void 0 : D.middleComments);\n          }\n          function w(D) {\n            return D == null ? void 0 : D.indicatorComment;\n          }\n          function E(D) {\n            return D == null ? void 0 : D.trailingComment;\n          }\n          function N(D) {\n            return s(D == null ? void 0 : D.endComments);\n          }\n          function x(D) {\n            let T = [],\n              m;\n            for (let C of D.split(/( +)/)) C !== \" \" ? m === \" \" ? T.push(C) : T.push((T.pop() || \"\") + C) : m === void 0 && T.unshift(\"\"), m = C;\n            return m === \" \" && T.push((T.pop() || \"\") + \" \"), T[0] === \"\" && (T.shift(), T.unshift(\" \" + (T.shift() || \"\"))), T;\n          }\n          function I(D, T, m) {\n            let C = T.split(`\n`).map((o, d, v) => d === 0 && d === v.length - 1 ? o : d !== 0 && d !== v.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());\n            return m.proseWrap === \"preserve\" ? C.map(o => o.length === 0 ? [] : [o]) : C.map(o => o.length === 0 ? [] : x(o)).reduce((o, d, v) => v !== 0 && C[v - 1].length > 0 && d.length > 0 && !(D === \"quoteDouble\" && t(t(o)).endsWith(\"\\\\\")) ? [...o.slice(0, -1), [...t(o), ...d]] : [...o, d], []).map(o => m.proseWrap === \"never\" ? [o.join(\" \")] : o);\n          }\n          function P(D, T) {\n            let {\n                parentIndent: m,\n                isLastDescendant: C,\n                options: o\n              } = T,\n              d = D.position.start.line === D.position.end.line ? \"\" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\\n]*\\n(.*)$/s)[1],\n              v;\n            if (D.indent === null) {\n              let B = d.match(/^(?<leadingSpace> *)[^\\n\\r ]/m);\n              v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;\n            } else v = D.indent - 1 + m;\n            let S = d.split(`\n`).map(B => B.slice(v));\n            if (o.proseWrap === \"preserve\" || D.type === \"blockLiteral\") return b(S.map(B => B.length === 0 ? [] : [B]));\n            return b(S.map(B => B.length === 0 ? [] : x(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\\s/.test(k[0]) && !/^\\s|\\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map(B => B.reduce((k, M) => k.length > 0 && /\\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + \" \" + M] : [...k, M], [])).map(B => o.proseWrap === \"never\" ? [B.join(\" \")] : B));\n            function b(B) {\n              if (D.chomping === \"keep\") return t(B).length === 0 ? B.slice(0, -1) : B;\n              let k = 0;\n              for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--) k++;\n              return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);\n            }\n          }\n          function $(D) {\n            if (!D) return !0;\n            switch (D.type) {\n              case \"plain\":\n              case \"quoteDouble\":\n              case \"quoteSingle\":\n              case \"alias\":\n              case \"flowMapping\":\n              case \"flowSequence\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          r.exports = {\n            getLast: t,\n            getAncestorCount: a,\n            isNode: n,\n            isEmptyNode: c,\n            isInlineNode: $,\n            mapNode: u,\n            defineShortcut: i,\n            isNextLineEmpty: l,\n            isLastDescendantNode: p,\n            getBlockValueLineContents: P,\n            getFlowScalarLineContents: I,\n            getLastDescendantNode: y,\n            hasPrettierIgnore: g,\n            hasLeadingComments: F,\n            hasMiddleComments: _,\n            hasIndicatorComment: w,\n            hasTrailingComment: E,\n            hasEndComments: N\n          };\n        }\n      }),\n      Mg = te({\n        \"src/language-yaml/print-preprocess.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n            defineShortcut: t,\n            mapNode: s\n          } = $t();\n          function a(u) {\n            return s(u, n);\n          }\n          function n(u) {\n            switch (u.type) {\n              case \"document\":\n                t(u, \"head\", () => u.children[0]), t(u, \"body\", () => u.children[1]);\n                break;\n              case \"documentBody\":\n              case \"sequenceItem\":\n              case \"flowSequenceItem\":\n              case \"mappingKey\":\n              case \"mappingValue\":\n                t(u, \"content\", () => u.children[0]);\n                break;\n              case \"mappingItem\":\n              case \"flowMappingItem\":\n                t(u, \"key\", () => u.children[0]), t(u, \"value\", () => u.children[1]);\n                break;\n            }\n            return u;\n          }\n          r.exports = a;\n        }\n      }),\n      Mr = te({\n        \"src/language-yaml/print/misc.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                softline: t,\n                align: s\n              }\n            } = qe(),\n            {\n              hasEndComments: a,\n              isNextLineEmpty: n,\n              isNode: u\n            } = $t(),\n            i = new WeakMap();\n          function l(h, g) {\n            let c = h.getValue(),\n              f = h.stack[0],\n              F;\n            return i.has(f) ? F = i.get(f) : (F = new Set(), i.set(f, F)), !F.has(c.position.end.line) && (F.add(c.position.end.line), n(c, g) && !p(h.getParentNode())) ? t : \"\";\n          }\n          function p(h) {\n            return a(h) && !u(h, [\"documentHead\", \"documentBody\", \"flowMapping\", \"flowSequence\"]);\n          }\n          function y(h, g) {\n            return s(\" \".repeat(h), g);\n          }\n          r.exports = {\n            alignWithSpaces: y,\n            shouldPrintEndComments: p,\n            printNextEmptyLine: l\n          };\n        }\n      }),\n      Rg = te({\n        \"src/language-yaml/print/flow-mapping-sequence.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                ifBreak: t,\n                line: s,\n                softline: a,\n                hardline: n,\n                join: u\n              }\n            } = qe(),\n            {\n              isEmptyNode: i,\n              getLast: l,\n              hasEndComments: p\n            } = $t(),\n            {\n              printNextEmptyLine: y,\n              alignWithSpaces: h\n            } = Mr();\n          function g(f, F, _) {\n            let w = f.getValue(),\n              E = w.type === \"flowMapping\",\n              N = E ? \"{\" : \"[\",\n              x = E ? \"}\" : \"]\",\n              I = a;\n            E && w.children.length > 0 && _.bracketSpacing && (I = s);\n            let P = l(w.children),\n              $ = P && P.type === \"flowMappingItem\" && i(P.key) && i(P.value);\n            return [N, h(_.tabWidth, [I, c(f, F, _), _.trailingComma === \"none\" ? \"\" : t(\",\"), p(w) ? [n, u(n, f.map(F, \"endComments\"))] : \"\"]), $ ? \"\" : I, x];\n          }\n          function c(f, F, _) {\n            let w = f.getValue();\n            return f.map((N, x) => [F(), x === w.children.length - 1 ? \"\" : [\",\", s, w.children[x].position.start.line !== w.children[x + 1].position.start.line ? y(N, _.originalText) : \"\"]], \"children\");\n          }\n          r.exports = {\n            printFlowMapping: g,\n            printFlowSequence: g\n          };\n        }\n      }),\n      $g = te({\n        \"src/language-yaml/print/mapping-item.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                conditionalGroup: t,\n                group: s,\n                hardline: a,\n                ifBreak: n,\n                join: u,\n                line: i\n              }\n            } = qe(),\n            {\n              hasLeadingComments: l,\n              hasMiddleComments: p,\n              hasTrailingComment: y,\n              hasEndComments: h,\n              isNode: g,\n              isEmptyNode: c,\n              isInlineNode: f\n            } = $t(),\n            {\n              alignWithSpaces: F\n            } = Mr();\n          function _(x, I, P, $, D) {\n            let {\n                key: T,\n                value: m\n              } = x,\n              C = c(T),\n              o = c(m);\n            if (C && o) return \": \";\n            let d = $(\"key\"),\n              v = E(x) ? \" \" : \"\";\n            if (o) return x.type === \"flowMappingItem\" && I.type === \"flowMapping\" ? d : x.type === \"mappingItem\" && w(T.content, D) && !y(T.content) && (!I.tag || I.tag.value !== \"tag:yaml.org,2002:set\") ? [d, v, \":\"] : [\"? \", F(2, d)];\n            let S = $(\"value\");\n            if (C) return [\": \", F(2, S)];\n            if (l(m) || !f(T.content)) return [\"? \", F(2, d), a, u(\"\", P.map($, \"value\", \"leadingComments\").map(q => [q, a])), \": \", F(2, S)];\n            if (N(T.content) && !l(T.content) && !p(T.content) && !y(T.content) && !h(T) && !l(m.content) && !p(m.content) && !h(m) && w(m.content, D)) return [d, v, \": \", S];\n            let b = Symbol(\"mappingKey\"),\n              B = s([n(\"? \"), s(F(2, d), {\n                id: b\n              })]),\n              k = [a, \": \", F(2, S)],\n              M = [v, \":\"];\n            l(m.content) || h(m) && m.content && !g(m.content, [\"mapping\", \"sequence\"]) || I.type === \"mapping\" && y(T.content) && f(m.content) || g(m.content, [\"mapping\", \"sequence\"]) && m.content.tag === null && m.content.anchor === null ? M.push(a) : m.content && M.push(i), M.push(S);\n            let R = F(D.tabWidth, M);\n            return w(T.content, D) && !l(T.content) && !p(T.content) && !h(T) ? t([[d, R]]) : t([[B, n(k, R, {\n              groupId: b\n            })]]);\n          }\n          function w(x, I) {\n            if (!x) return !0;\n            switch (x.type) {\n              case \"plain\":\n              case \"quoteSingle\":\n              case \"quoteDouble\":\n                break;\n              case \"alias\":\n                return !0;\n              default:\n                return !1;\n            }\n            if (I.proseWrap === \"preserve\") return x.position.start.line === x.position.end.line;\n            if (/\\\\$/m.test(I.originalText.slice(x.position.start.offset, x.position.end.offset))) return !1;\n            switch (I.proseWrap) {\n              case \"never\":\n                return !x.value.includes(`\n`);\n              case \"always\":\n                return !/[\\n ]/.test(x.value);\n              default:\n                return !1;\n            }\n          }\n          function E(x) {\n            return x.key.content && x.key.content.type === \"alias\";\n          }\n          function N(x) {\n            if (!x) return !0;\n            switch (x.type) {\n              case \"plain\":\n              case \"quoteDouble\":\n              case \"quoteSingle\":\n                return x.position.start.line === x.position.end.line;\n              case \"alias\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          r.exports = _;\n        }\n      }),\n      Vg = te({\n        \"src/language-yaml/print/block.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                dedent: t,\n                dedentToRoot: s,\n                fill: a,\n                hardline: n,\n                join: u,\n                line: i,\n                literalline: l,\n                markAsRoot: p\n              },\n              utils: {\n                getDocParts: y\n              }\n            } = qe(),\n            {\n              getAncestorCount: h,\n              getBlockValueLineContents: g,\n              hasIndicatorComment: c,\n              isLastDescendantNode: f,\n              isNode: F\n            } = $t(),\n            {\n              alignWithSpaces: _\n            } = Mr();\n          function w(E, N, x) {\n            let I = E.getValue(),\n              P = h(E, C => F(C, [\"sequence\", \"mapping\"])),\n              $ = f(E),\n              D = [I.type === \"blockFolded\" ? \">\" : \"|\"];\n            I.indent !== null && D.push(I.indent.toString()), I.chomping !== \"clip\" && D.push(I.chomping === \"keep\" ? \"+\" : \"-\"), c(I) && D.push(\" \", N(\"indicatorComment\"));\n            let T = g(I, {\n                parentIndent: P,\n                isLastDescendant: $,\n                options: x\n              }),\n              m = [];\n            for (let [C, o] of T.entries()) C === 0 && m.push(n), m.push(a(y(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n : p(l)) : I.chomping === \"keep\" && $ && m.push(s(o.length === 0 ? n : l));\n            return I.indent === null ? D.push(t(_(x.tabWidth, m))) : D.push(s(_(I.indent - 1 + P, m))), D;\n          }\n          r.exports = w;\n        }\n      }),\n      Wg = te({\n        \"src/language-yaml/printer-yaml.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var {\n              builders: {\n                breakParent: t,\n                fill: s,\n                group: a,\n                hardline: n,\n                join: u,\n                line: i,\n                lineSuffix: l,\n                literalline: p\n              },\n              utils: {\n                getDocParts: y,\n                replaceTextEndOfLine: h\n              }\n            } = qe(),\n            {\n              isPreviousLineEmpty: g\n            } = Ue(),\n            {\n              insertPragma: c,\n              isPragma: f\n            } = Og(),\n            {\n              locStart: F\n            } = jg(),\n            _ = qg(),\n            {\n              getFlowScalarLineContents: w,\n              getLastDescendantNode: E,\n              hasLeadingComments: N,\n              hasMiddleComments: x,\n              hasTrailingComment: I,\n              hasEndComments: P,\n              hasPrettierIgnore: $,\n              isLastDescendantNode: D,\n              isNode: T,\n              isInlineNode: m\n            } = $t(),\n            C = Mg(),\n            {\n              alignWithSpaces: o,\n              printNextEmptyLine: d,\n              shouldPrintEndComments: v\n            } = Mr(),\n            {\n              printFlowMapping: S,\n              printFlowSequence: b\n            } = Rg(),\n            B = $g(),\n            k = Vg();\n          function M(j, Y, ie) {\n            let ee = j.getValue(),\n              ce = [];\n            ee.type !== \"mappingValue\" && N(ee) && ce.push([u(n, j.map(ie, \"leadingComments\")), n]);\n            let {\n              tag: W,\n              anchor: K\n            } = ee;\n            W && ce.push(ie(\"tag\")), W && K && ce.push(\" \"), K && ce.push(ie(\"anchor\"));\n            let de = \"\";\n            T(ee, [\"mapping\", \"sequence\", \"comment\", \"directive\", \"mappingItem\", \"sequenceItem\"]) && !D(j) && (de = d(j, Y.originalText)), (W || K) && (T(ee, [\"sequence\", \"mapping\"]) && !x(ee) ? ce.push(n) : ce.push(\" \")), x(ee) && ce.push([ee.middleComments.length === 1 ? \"\" : n, u(n, j.map(ie, \"middleComments\")), n]);\n            let ue = j.getParentNode();\n            return $(j) ? ce.push(h(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p)) : ce.push(a(R(ee, ue, j, Y, ie))), I(ee) && !T(ee, [\"document\", \"documentHead\"]) && ce.push(l([ee.type === \"mappingValue\" && !ee.content ? \"\" : \" \", ue.type === \"mappingKey\" && j.getParentNode(2).type === \"mapping\" && m(ee) ? \"\" : t, ie(\"trailingComment\")])), v(ee) && ce.push(o(ee.type === \"sequenceItem\" ? 2 : 0, [n, u(n, j.map(Fe => [g(Y.originalText, Fe.getValue(), F) ? n : \"\", ie()], \"endComments\"))])), ce.push(de), ce;\n          }\n          function R(j, Y, ie, ee, ce) {\n            switch (j.type) {\n              case \"root\":\n                {\n                  let {\n                      children: W\n                    } = j,\n                    K = [];\n                  ie.each((ue, Fe) => {\n                    let z = W[Fe],\n                      U = W[Fe + 1];\n                    Fe !== 0 && K.push(n), K.push(ce()), J(z, U) ? (K.push(n, \"...\"), I(z) && K.push(\" \", ce(\"trailingComment\"))) : U && !I(U.head) && K.push(n, \"---\");\n                  }, \"children\");\n                  let de = E(j);\n                  return (!T(de, [\"blockLiteral\", \"blockFolded\"]) || de.chomping !== \"keep\") && K.push(n), K;\n                }\n              case \"document\":\n                {\n                  let W = Y.children[ie.getName() + 1],\n                    K = [];\n                  return L(j, W, Y, ee) === \"head\" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce(\"head\")), I(j.head) ? K.push([\"---\", \" \", ce([\"head\", \"trailingComment\"])]) : K.push(\"---\")), q(j) && K.push(ce(\"body\")), u(n, K);\n                }\n              case \"documentHead\":\n                return u(n, [...ie.map(ce, \"children\"), ...ie.map(ce, \"endComments\")]);\n              case \"documentBody\":\n                {\n                  let {\n                      children: W,\n                      endComments: K\n                    } = j,\n                    de = \"\";\n                  if (W.length > 0 && K.length > 0) {\n                    let ue = E(j);\n                    T(ue, [\"blockFolded\", \"blockLiteral\"]) ? ue.chomping !== \"keep\" && (de = [n, n]) : de = n;\n                  }\n                  return [u(n, ie.map(ce, \"children\")), de, u(n, ie.map(ce, \"endComments\"))];\n                }\n              case \"directive\":\n                return [\"%\", u(\" \", [j.name, ...j.parameters])];\n              case \"comment\":\n                return [\"#\", j.value];\n              case \"alias\":\n                return [\"*\", j.value];\n              case \"tag\":\n                return ee.originalText.slice(j.position.start.offset, j.position.end.offset);\n              case \"anchor\":\n                return [\"&\", j.value];\n              case \"plain\":\n                return Q(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);\n              case \"quoteDouble\":\n              case \"quoteSingle\":\n                {\n                  let W = \"'\",\n                    K = '\"',\n                    de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);\n                  if (j.type === \"quoteSingle\" && de.includes(\"\\\\\") || j.type === \"quoteDouble\" && /\\\\[^\"]/.test(de)) {\n                    let Fe = j.type === \"quoteDouble\" ? K : W;\n                    return [Fe, Q(j.type, de, ee), Fe];\n                  }\n                  if (de.includes(K)) return [W, Q(j.type, j.type === \"quoteDouble\" ? de.replace(/\\\\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];\n                  if (de.includes(W)) return [K, Q(j.type, j.type === \"quoteSingle\" ? de.replace(/''/g, W) : de, ee), K];\n                  let ue = ee.singleQuote ? W : K;\n                  return [ue, Q(j.type, de, ee), ue];\n                }\n              case \"blockFolded\":\n              case \"blockLiteral\":\n                return k(ie, ce, ee);\n              case \"mapping\":\n              case \"sequence\":\n                return u(n, ie.map(ce, \"children\"));\n              case \"sequenceItem\":\n                return [\"- \", o(2, j.content ? ce(\"content\") : \"\")];\n              case \"mappingKey\":\n              case \"mappingValue\":\n                return j.content ? ce(\"content\") : \"\";\n              case \"mappingItem\":\n              case \"flowMappingItem\":\n                return B(j, Y, ie, ce, ee);\n              case \"flowMapping\":\n                return S(ie, ce, ee);\n              case \"flowSequence\":\n                return b(ie, ce, ee);\n              case \"flowSequenceItem\":\n                return ce(\"content\");\n              default:\n                throw new Error(`Unexpected node type ${j.type}`);\n            }\n          }\n          function q(j) {\n            return j.body.children.length > 0 || P(j.body);\n          }\n          function J(j, Y) {\n            return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));\n          }\n          function L(j, Y, ie, ee) {\n            return ie.children[0] === j && /---(?:\\s|$)/.test(ee.originalText.slice(F(j), F(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? \"head\" : J(j, Y) ? !1 : Y ? \"root\" : !1;\n          }\n          function Q(j, Y, ie) {\n            let ee = w(j, Y, ie);\n            return u(n, ee.map(ce => s(y(u(i, ce)))));\n          }\n          function V(j, Y) {\n            if (T(Y)) switch (delete Y.position, Y.type) {\n              case \"comment\":\n                if (f(Y.value)) return null;\n                break;\n              case \"quoteDouble\":\n              case \"quoteSingle\":\n                Y.type = \"quote\";\n                break;\n            }\n          }\n          r.exports = {\n            preprocess: C,\n            embed: _,\n            print: M,\n            massageAstNode: V,\n            insertPragma: c\n          };\n        }\n      }),\n      Hg = te({\n        \"src/language-yaml/options.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = Mt();\n          r.exports = {\n            bracketSpacing: t.bracketSpacing,\n            singleQuote: t.singleQuote,\n            proseWrap: t.proseWrap\n          };\n        }\n      }),\n      Gg = te({\n        \"src/language-yaml/parsers.js\"() {\n          ne();\n        }\n      }),\n      Ug = te({\n        \"node_modules/linguist-languages/data/YAML.json\"(e, r) {\n          r.exports = {\n            name: \"YAML\",\n            type: \"data\",\n            color: \"#cb171e\",\n            tmScope: \"source.yaml\",\n            aliases: [\"yml\"],\n            extensions: [\".yml\", \".mir\", \".reek\", \".rviz\", \".sublime-syntax\", \".syntax\", \".yaml\", \".yaml-tmlanguage\", \".yaml.sed\", \".yml.mysql\"],\n            filenames: [\".clang-format\", \".clang-tidy\", \".gemrc\", \"CITATION.cff\", \"glide.lock\", \"yarn.lock\"],\n            aceMode: \"yaml\",\n            codemirrorMode: \"yaml\",\n            codemirrorMimeType: \"text/x-yaml\",\n            languageId: 407\n          };\n        }\n      }),\n      Jg = te({\n        \"src/language-yaml/index.js\"(e, r) {\n          \"use strict\";\n\n          ne();\n          var t = _t(),\n            s = Wg(),\n            a = Hg(),\n            n = Gg(),\n            u = [t(Ug(), i => ({\n              since: \"1.14.0\",\n              parsers: [\"yaml\"],\n              vscodeLanguageIds: [\"yaml\", \"ansible\", \"home-assistant\"],\n              filenames: [...i.filenames.filter(l => l !== \"yarn.lock\"), \".prettierrc\", \".stylelintrc\", \".lintstagedrc\"]\n            }))];\n          r.exports = {\n            languages: u,\n            printers: {\n              yaml: s\n            },\n            options: a,\n            parsers: n\n          };\n        }\n      }),\n      zg = te({\n        \"src/languages.js\"(e, r) {\n          \"use strict\";\n\n          ne(), r.exports = [Bd(), Ud(), eg(), ag(), dg(), Lg(), Jg()];\n        }\n      });\n    ne();\n    var {\n        version: Xg\n      } = Ia(),\n      Ot = Gm(),\n      {\n        getSupportInfo: Kg\n      } = Xn(),\n      Yg = Um(),\n      Qg = zg(),\n      Zg = qe();\n    function Nt(e) {\n      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n      return function () {\n        for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];\n        let n = s[r] || {},\n          u = n.plugins || [];\n        return s[r] = Object.assign(Object.assign({}, n), {}, {\n          plugins: [...Qg, ...(Array.isArray(u) ? u : Object.values(u))]\n        }), e(...s);\n      };\n    }\n    var jn = Nt(Ot.formatWithCursor);\n    jo.exports = {\n      formatWithCursor: jn,\n      format(e, r) {\n        return jn(e, r).formatted;\n      },\n      check(e, r) {\n        let {\n          formatted: t\n        } = jn(e, r);\n        return t === e;\n      },\n      doc: Zg,\n      getSupportInfo: Nt(Kg, 0),\n      version: Xg,\n      util: Yg,\n      __debug: {\n        parse: Nt(Ot.parse),\n        formatAST: Nt(Ot.formatAST),\n        formatDoc: Nt(Ot.formatDoc),\n        printToDoc: Nt(Ot.printToDoc),\n        printDocToString: Nt(Ot.printDocToString)\n      }\n    };\n  });\n  return e0();\n});\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/prettier/standalone.js?");

/***/ }),

/***/ "./src/addListItem.js":
/*!****************************!*\
  !*** ./src/addListItem.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ addListItem)\n/* harmony export */ });\nfunction addListItem(input) {\n  var newEntry = document.createElement('div');\n  newEntry.className = \"entry\";\n  var checkbox = document.createElement('input');\n  checkbox.type = \"checkbox\";\n  checkbox.className = \"check\";\n  newEntry.appendChild(checkbox);\n  var newLabel = document.createElement('label');\n  newLabel.innerHTML = input;\n  newLabel.setAttribute(\"for\", checkbox);\n  newEntry.appendChild(newLabel);\n  var deleteBtn = document.createElement('button');\n  deleteBtn.innerHTML = \"Delete\";\n  deleteBtn.className = \"delete\";\n  newEntry.appendChild(deleteBtn);\n  var tdList = document.getElementById('tdList');\n  tdList.appendChild(newEntry);\n}\n\n//# sourceURL=webpack://my-webpack-project/./src/addListItem.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n/* harmony import */ var _addListItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addListItem */ \"./src/addListItem.js\");\n/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prettier */ \"./node_modules/prettier/standalone.js\");\n/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prettier__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nvar tdList = document.getElementById('tdList');\nvar addInput = document.getElementById('input');\nvar addBtn = document.getElementById('addBtn');\naddBtn.addEventListener('click', function () {\n  if (addInput.value) {\n    (0,_addListItem__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(addInput.value);\n    addInput.value = \"\";\n  }\n});\nvar checkbox = document.querySelectorAll('.check');\ncheckbox.forEach(function (check) {\n  check.addEventListener('change', function () {\n    var labelChange = check.nextSibling.nextSibling;\n    if (check.checked) {\n      labelChange.style.setProperty(\"text-decoration\", \"line-through\");\n    } else {\n      labelChange.style.setProperty(\"text-decoration\", \"\");\n    }\n  });\n});\nvar deleteBtn = document.querySelectorAll('.delete');\ndeleteBtn.forEach(function (button) {\n  button.addEventListener('click', function () {\n    button.parentNode.remove();\n  });\n});\n\n//# sourceURL=webpack://my-webpack-project/./src/index.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.entry {\r\n    display: flex;\r\n    margin: 5px;\r\n}\r\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://my-webpack-project/./src/style.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://my-webpack-project/./src/style.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;